[{"title":"Linux增加开机启动项","url":"/2021/05/07/Linux/Linux%E5%A2%9E%E5%8A%A0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E9%A1%B9/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><ul>\n<li>vi /etc/rc.local</li>\n<li>按i键进入编辑模式，然后在最后一行加入需要开机启动的命令  例如:</li>\n<li>ssserver -c /etc/shadowsocks/config.json -d start  –log-file /etc/shadowsocks/ss.log –pid-file /etc/shadowsocks/ss.pid</li>\n</ul>\n","categories":["Linux","web"],"tags":["开机"]},{"title":"apache 代理转发","url":"/2021/05/07/Linux/apache%20%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"一、转发时需开启如下：\"><a href=\"#一、转发时需开启如下：\" class=\"headerlink\" title=\"一、转发时需开启如下：\"></a>一、转发时需开启如下：</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo a2enmod proxy</span><br><span class=\"line\">sudo a2enmod proxy_http</span><br><span class=\"line\">sudo a2enmod proxy_ajp</span><br><span class=\"line\">sudo a2enmod proxy_balancer</span><br><span class=\"line\">sudo a2enmod proxy_connect</span><br><span class=\"line\">sudo a2enmod proxy_html</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://superuser.com/questions/1287647/apache2-not-starting-error-invalid-command-proxyrequests\">参考链接</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"二、相关代码：\"><a href=\"#二、相关代码：\" class=\"headerlink\" title=\"二、相关代码：\"></a>二、相关代码：</h2><h4 id=\"80端口转发其他多个项目端口\"><a href=\"#80端口转发其他多个项目端口\" class=\"headerlink\" title=\"80端口转发其他多个项目端口\"></a>80端口转发其他多个项目端口</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;VirtualHost *:80&gt;</span><br><span class=\"line\">        ServerAdmin webmaster@localhost</span><br><span class=\"line\">        DocumentRoot &#x2F;var&#x2F;www&#x2F;html&#x2F;xunke</span><br><span class=\"line\">        ErrorLog &#x2F;etc&#x2F;apache2&#x2F;error.log</span><br><span class=\"line\">        CustomLog &#x2F;etc&#x2F;apache2&#x2F;access.log combined</span><br><span class=\"line\">        #ProxyPassMatch  &#x2F;xunke&#x2F;  http:&#x2F;&#x2F;localhost:8003&#x2F;   # 匹配带有xunke的url 不适用</span><br><span class=\"line\">        ProxyPass  &#x2F;xunke  http:&#x2F;&#x2F;localhost:8003&#x2F;</span><br><span class=\"line\">        ProxyPassReverse &#x2F;xunke  http:&#x2F;&#x2F;localhost:8003&#x2F;</span><br><span class=\"line\">&lt;&#x2F;VirtualHost&gt;</span><br><span class=\"line\">&lt;VirtualHost *:80&gt;</span><br><span class=\"line\">        ServerAdmin webmaster@localhost</span><br><span class=\"line\">        DocumentRoot &#x2F;var&#x2F;www&#x2F;html&#x2F;topmps</span><br><span class=\"line\">        ErrorLog &#x2F;etc&#x2F;apache2&#x2F;error.log</span><br><span class=\"line\">        CustomLog &#x2F;etc&#x2F;apache2&#x2F;access.log combined</span><br><span class=\"line\">        #ProxyPassMatch  &#x2F;topmps&#x2F;  http:&#x2F;&#x2F;localhost:8002&#x2F;</span><br><span class=\"line\">        ProxyPass  &#x2F;topmps&#x2F;  http:&#x2F;&#x2F;localhost:8002&#x2F;</span><br><span class=\"line\">        ProxyPassReverse  &#x2F;topmps&#x2F;  http:&#x2F;&#x2F;localhost:8002&#x2F;</span><br><span class=\"line\">&lt;&#x2F;VirtualHost&gt;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://blog.csdn.net/xiaokui_wingfly/article/details/51481653\">参考链接1</a><br><a href=\"https://blog.csdn.net/u011277123/article/details/77165137\">参考链接2</a></p>\n<h4 id=\"apache-监听多个端口\"><a href=\"#apache-监听多个端口\" class=\"headerlink\" title=\"apache 监听多个端口\"></a>apache 监听多个端口</h4><ul>\n<li><p>目录：/etc/apache2/ports.conf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Listen 80</span><br><span class=\"line\">Listen 8003</span><br><span class=\"line\">Listen 8004</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;IfModule ssl_module&gt;</span><br><span class=\"line\">        Listen 443</span><br><span class=\"line\">&lt;&#x2F;IfModule&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;IfModule mod_gnutls.c&gt;</span><br><span class=\"line\">        Listen 443</span><br><span class=\"line\">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>目录：/etc/apache2/sites-available/000-default.conf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;VirtualHost *:8003&gt;</span><br><span class=\"line\">        ServerAdmin webmaster@localhost</span><br><span class=\"line\">        DocumentRoot &#x2F;var&#x2F;www&#x2F;html&#x2F;xunke</span><br><span class=\"line\">        ErrorLog &#x2F;etc&#x2F;apache2&#x2F;error.log</span><br><span class=\"line\">        CustomLog &#x2F;etc&#x2F;apache2&#x2F;access.log combined</span><br><span class=\"line\">&lt;&#x2F;VirtualHost&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;VirtualHost *:8004&gt;</span><br><span class=\"line\">        ServerAdmin webmaster@localhost</span><br><span class=\"line\">        DocumentRoot &#x2F;var&#x2F;www&#x2F;html&#x2F;qibo</span><br><span class=\"line\">        ErrorLog &#x2F;etc&#x2F;apache2&#x2F;error.log</span><br><span class=\"line\">        CustomLog &#x2F;etc&#x2F;apache2&#x2F;access.log combined</span><br><span class=\"line\">&lt;&#x2F;VirtualHost&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","categories":["Linux","web"],"tags":["apache"]},{"title":"linux 新添加的硬盘格式化并挂载到目录下","url":"/2021/05/07/Linux/linux%20%E6%96%B0%E6%B7%BB%E5%8A%A0%E7%9A%84%E7%A1%AC%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B9%B6%E6%8C%82%E8%BD%BD%E5%88%B0%E7%9B%AE%E5%BD%95%E4%B8%8B/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>需求: 新增加一块硬盘sdb，将sdb分区，只分一个区，格式化，挂载到目录/ssd下。</p>\n<h3 id=\"1、-查看现在已有的分区状态\"><a href=\"#1、-查看现在已有的分区状态\" class=\"headerlink\" title=\"1、  查看现在已有的分区状态\"></a>1、  查看现在已有的分区状态</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">df –l</span><br><span class=\"line\">df -h</span><br></pre></td></tr></table></figure>\n\n<p> <img src=\"https://upload-images.jianshu.io/upload_images/5818745-475b2c7ef78d7fd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>图中显示，没有看到sdb硬盘</p>\n<span id=\"more\"></span>\n<h3 id=\"2、-查看服务器安装的硬盘状态（包括格式化和未格式化）\"><a href=\"#2、-查看服务器安装的硬盘状态（包括格式化和未格式化）\" class=\"headerlink\" title=\"2、  查看服务器安装的硬盘状态（包括格式化和未格式化）\"></a>2、  查看服务器安装的硬盘状态（包括格式化和未格式化）</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">fdisk –l</span><br></pre></td></tr></table></figure>\n\n<p> <img src=\"https://upload-images.jianshu.io/upload_images/5818745-2a1be329f8211b73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>图中显示，有sdb硬盘，但是没有分区。</p>\n<h3 id=\"3、-添加新分区\"><a href=\"#3、-添加新分区\" class=\"headerlink\" title=\"3、  添加新分区\"></a>3、  添加新分区</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">fdisk &#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-e3a2e8e9775f03e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">按照以下红框输入</span><br><span class=\"line\"></span><br><span class=\"line\">N 回车</span><br><span class=\"line\"></span><br><span class=\"line\">P 回车</span><br><span class=\"line\"></span><br><span class=\"line\">1 回车</span><br><span class=\"line\"></span><br><span class=\"line\">两次回车</span><br><span class=\"line\"></span><br><span class=\"line\">W 回车</span><br></pre></td></tr></table></figure>\n<p> <img src=\"https://upload-images.jianshu.io/upload_images/5818745-79db184fcbe754fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>用以下命令查看分区</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">fdisk –l</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-12a6321b0fb4414d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>图中红框显示已多出了一个分区，但是还没有格式化。</p>\n<h3 id=\"4、-格式化分区\"><a href=\"#4、-格式化分区\" class=\"headerlink\" title=\"4、  格式化分区\"></a>4、  格式化分区</h3><p>centos6文件系统是ext4，因为设计较早，对于现今动辄上T的海量数据处理，性能较低。centos7文件系统是xfs，适用于海量数据。这两种文件系统都是日志文件系统。使用该文件系统的磁盘，空间包括两部分：日志空间和存储空间。写入的数据是先暂存在日志空间，然后刷入存储空间，这样有利于恢复数据。另外，xfs文件系统还支持将一块儿固态硬盘用作单独的日志空间盘，数据先写入固态硬盘，然后再刷入硬盘。对于操作系统来说，数据写入了日志空间盘，就算完成了I/O，因此这种方式提高了系统性能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># mkfs -t ext4 -c &#x2F;dev&#x2F;sdb1</span><br><span class=\"line\"># -t 制定要把磁盘格式化成什么类型</span><br><span class=\"line\"># -c 在建立文件系统之前检查坏道，可能会很费时间，新硬盘一般不需要</span><br><span class=\"line\"></span><br><span class=\"line\"># 新硬盘可直接用此命令 格式化成不同类型的硬盘</span><br><span class=\"line\">sudo mkfs.ext4 &#x2F;dev&#x2F;nvme1n1</span><br><span class=\"line\"></span><br><span class=\"line\">mkfs.xfs -f &#x2F;dev&#x2F;vdb</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看硬盘类型</span><br><span class=\"line\">df -T</span><br></pre></td></tr></table></figure>\n\n\n<p> <img src=\"https://upload-images.jianshu.io/upload_images/5818745-1ff8d2c0cdf33567.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-9de29709e668ca87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h3 id=\"5、-挂载新硬盘\"><a href=\"#5、-挂载新硬盘\" class=\"headerlink\" title=\"5、  挂载新硬盘\"></a>5、  挂载新硬盘</h3><p>在根目录下，建一个文件夹，待会将分区挂载在这个文件夹上，以后要往新硬盘存东西就存在新建文件夹下就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir &#x2F;ssd</span><br></pre></td></tr></table></figure>\n\n<p>挂载硬盘</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mount &#x2F;dev&#x2F;sdb1 &#x2F;ssd</span><br></pre></td></tr></table></figure>\n\n<p>　　<img src=\"https://upload-images.jianshu.io/upload_images/5818745-27f3271c3dd90f64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo chown ec2-user:root &#x2F;data1   用户权限</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、-让系统开机自动挂载这块硬盘\"><a href=\"#6、-让系统开机自动挂载这块硬盘\" class=\"headerlink\" title=\"6、  让系统开机自动挂载这块硬盘\"></a>6、  让系统开机自动挂载这块硬盘</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo &quot;&#x2F;dev&#x2F;sda1 &#x2F;ssd ext4 defaults 0 0&quot; &gt;&gt; &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure>\n\n<p>如果报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">先更改权限</span><br><span class=\"line\">sudo chown ec2-user:root  &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-67bf9a9fc680d289.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h2 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h2><p>挂载硬盘</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo mount  &#x2F;dev&#x2F;nvme1n1  &#x2F;data1</span><br></pre></td></tr></table></figure>\n\n<p>取消挂载</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo umount  &#x2F;dev&#x2F;nvme1n1</span><br></pre></td></tr></table></figure>\n\n<p>如果 /data1里原先有数据 他会自己保留 取消挂载后 会恢复回来</p>\n<h2 id=\"查看文件夹大小\"><a href=\"#查看文件夹大小\" class=\"headerlink\" title=\"查看文件夹大小\"></a>查看文件夹大小</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">du -h .&#x2F;scheduler&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">du -sh .&#x2F;scheduler&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">参数解释</span><br><span class=\"line\"></span><br><span class=\"line\">-a ： 列出所有的文件与目录容量，因为默认仅统计目录的容量而已</span><br><span class=\"line\"></span><br><span class=\"line\">-h: 以人们较易读的容量格式呈现(G&#x2F;M&#x2F;K)显示，自动选择显示的单位大小</span><br><span class=\"line\"></span><br><span class=\"line\">-s : 列出总量而已，而不列出每个个别的目录占用容量</span><br><span class=\"line\"></span><br><span class=\"line\">-k ： 以KB为单位进行显示</span><br><span class=\"line\"></span><br><span class=\"line\">-m : 以MB为单位进行显示常用[命令](https:&#x2F;&#x2F;www.linuxcool.com&#x2F;)参考  查看当前目录大小</span><br></pre></td></tr></table></figure>\n\n\n<p>参考文档：<br>    <a href=\"https://blog.csdn.net/Ayhan_huang/article/details/72801647\">linux下查看硬盘信息、硬盘分区、格式化、挂载、及swap分区</a><br>    <a href=\"https://www.cnblogs.com/ddbear/p/7009736.html\">linux 新添加的硬盘格式化并挂载到目录下</a></p>\n","categories":["Linux"],"tags":["硬盘挂载"]},{"title":"linux下free命令详解","url":"/2021/05/07/Linux/linux%E4%B8%8Bfree%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>free 命令显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-93402368b565b074.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>如果加上 -h 选项，输出的结果会友好很多：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-2d772074def94405.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<span id=\"more\"></span>\n\n<p>有时我们需要持续的观察内存的状况，此时可以使用 -s 选项并指定间隔的秒数， -c选项指定展示次数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ free -h -c 100 -s 3</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-c51b8170c1bd1d35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>上面的命令每隔 3 秒输出一次内存的使用情况，直到你按下 ctrl + c。</p>\n<p>由于 free 命令本身比较简单，所以本文的重点会放在如何通过 free 命令了解系统当前的内存使用状况。</p>\n<h1 id=\"输出简介\"><a href=\"#输出简介\" class=\"headerlink\" title=\"输出简介\"></a>输出简介</h1><p>下面先解释一下输出的内容：<br><strong>Mem</strong> 行(第二行)是内存的使用情况。<br><strong>Swap</strong> 行(第三行)是交换空间的使用情况。<br><strong>total</strong> 列显示系统总的可用物理内存和交换空间大小。<br><strong>used</strong> 列显示已经被使用的物理内存和交换空间。<br><strong>free</strong> 列显示还有多少物理内存和交换空间可用使用。<br><strong>shared</strong> 列显示被共享使用的物理内存大小。<br><strong>buff/cache</strong> 列显示被 buffer 和 cache 使用的物理内存大小。<br><strong>available</strong> 列显示还可以被应用程序使用的物理内存大小。</p>\n<p>我想只有在理解了一些基本概念之后，上面的输出才能帮助我们了解系统的内存状况。</p>\n<h1 id=\"buff-cache\"><a href=\"#buff-cache\" class=\"headerlink\" title=\"buff/cache\"></a>buff/cache</h1><p>先来提一个问题： buffer 和 cache 应该是两种类型的内存，但是 free 命令为什么会把它们放在一起呢？要回答这个问题需要我们做些准备工作。让我们先来搞清楚 buffer 与 cache 的含义。</p>\n<p><strong>buffer</strong> 在操作系统中指 buffer cache， 中文一般翻译为 “缓冲区”。要理解缓冲区，必须明确另外两个概念：”扇区” 和 “块”。扇区是设备的最小寻址单元，也叫 “硬扇区” 或 “设备块”。块是操作系统中文件系统的最小寻址单元，也叫 “文件块” 或 “I/O 块”。每个块包含一个或多个扇区，但大小不能超过一个页面，所以一个页可以容纳一个或多个内存中的块。当一个块被调入内存时，它要存储在一个缓冲区中。每个缓冲区与一个块对应，它相当于是磁盘块在内存中的表示(下图来自互联网)：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-613c887968f39440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>注意，buffer cache 只有块的概念而没有文件的概念，它只是把磁盘上的块直接搬到内存中而不关心块中究竟存放的是什么格式的文件。</p>\n<p><strong>cache</strong> 在操作系统中指 page cache，中文一般翻译为 “页高速缓存”。页高速缓存是内核实现的磁盘缓存。它主要用来减少对磁盘的 I/O 操作。具体地讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。页高速缓存缓存的是内存页面。<strong>缓存中的页来自对普通文件、块设备文件(这个指的就是 buffer cache 呀)和内存映射文件的读写</strong>。<br>页高速缓存对普通文件的缓存我们可以这样理解：当内核要读一个文件(比如 /etc/hosts)时，它会先检查这个文件的数据是不是已经在页高速缓存中了。如果在，就放弃访问磁盘，直接从内存中读取。这个行为称为缓存命中。如果数据不在缓存中，就是未命中缓存，此时内核就要调度块 I/O 操作从磁盘去读取数据。然后内核将读来的数据放入页高速缓存中。这种缓存的目标是文件系统可以识别的文件(比如 /etc/hosts)。<br>页高速缓存对块设备文件的缓存就是我们在前面介绍的 buffer cahce。因为独立的磁盘块通过缓冲区也被存入了页高速缓存(缓冲区最终是由页高速缓存来承载的)。</p>\n<p>到这里我们应该搞清楚了：无论是缓冲区还是页高速缓存，它们的实现方式都是一样的。缓冲区只不过是一种概念上比较特殊的页高速缓存罢了。<br>那么为什么 free 命令不直接称为 cache 而非要写成 buff/cache？ 这是因为缓冲区和页高速缓存的实现并非天生就是统一的。在 linux 内核 2.4 中才将它们统一。更早的内核中有两个独立的磁盘缓存：页高速缓存和缓冲区高速缓存。前者缓存页面，后者缓存缓冲区。当你知道了这些故事之后，输出中列的名称可能已经不再重要了。</p>\n<h1 id=\"free-与-available\"><a href=\"#free-与-available\" class=\"headerlink\" title=\"free 与 available\"></a>free 与 available</h1><p>在 free 命令的输出中，有一个 free 列，同时还有一个 available 列。这二者到底有何区别？<br>free 是真正尚未被使用的物理内存数量。至于 available 就比较有意思了，它是从应用程序的角度看到的可用内存数量。Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache。所以对于内核来说，buffer 和 cache 都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，<strong>available  = free + buffer + cache</strong>。请注意，这只是一个很理想的计算方式，实际中的数据往往有较大的误差。</p>\n<h1 id=\"交换空间-swap-space\"><a href=\"#交换空间-swap-space\" class=\"headerlink\" title=\"交换空间(swap space)\"></a>交换空间(swap space)</h1><p>swap space 是磁盘上的一块区域，可以是一个分区，也可以是一个文件。所以具体的实现可以是 swap 分区也可以是 swap 文件。当系统物理内存吃紧时，Linux 会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中，这就是常说的换出和换入。交换空间可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。</p>\n<p>现在的机器一般都不太缺内存，如果系统默认还是使用了 swap 是不是会拖累系统的性能？理论上是的，但实际上可能性并不是很大。并且内核提供了一个叫做 swappiness 的参数，用于配置需要将内存中不常用的数据移到 swap 中去的紧迫程度。这个参数的取值范围是 0～100，0 告诉内核尽可能的不要将内存数据移到 swap 中，也即只有在迫不得已的情况下才这么做，而 100 告诉内核只要有可能，尽量的将内存中不常访问的数据移到 swap 中。在 ubuntu 系统中，swappiness 的默认值是 60。如果我们觉着内存充足，可以在 /etc/sysctl.conf 文件中设置 swappiness：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vm.swappiness&#x3D;10</span><br></pre></td></tr></table></figure>\n<p>如果系统的内存不足，则需要根据物理内存的大小来设置交换空间的大小。具体的策略网上有很丰富的资料，这里笔者不再赘述。</p>\n<h1 id=\"proc-meminfo-文件\"><a href=\"#proc-meminfo-文件\" class=\"headerlink\" title=\"/proc/meminfo 文件\"></a>/proc/meminfo 文件</h1><p>其实 free 命令中的信息都来自于 /proc/meminfo 文件。/proc/meminfo 文件包含了更多更原始的信息，只是看起来不太直观：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat &#x2F;proc&#x2F;meminfo</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-9a7e9ce89b48a95e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>有兴趣的同学可以直接查看这个文件。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>free 命令是一个既简单又复杂的命令。简单是因为这个命令的参数少，输出结果清晰。说它复杂则是因为它背后是比较晦涩的操作系统中的概念，如果不清楚这些概念，即便看了 free 命令的输出也 get 不到多少有价值的信息。</p>\n<h4 id=\"原文：linux下free命令详解\"><a href=\"#原文：linux下free命令详解\" class=\"headerlink\" title=\"原文：linux下free命令详解\"></a><a href=\"https://www.cnblogs.com/ultranms/p/9254160.html\">原文：linux下free命令详解</a></h4>","categories":["Linux","命令"],"tags":["free"]},{"title":"netstat 参数 及常用命令","url":"/2021/05/07/Linux/netstat%20%E5%8F%82%E6%95%B0%20%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>###netstat 中参数选项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-a或--all：显示所有连线中的Socket；</span><br><span class=\"line\">-A&lt;网络类型&gt;或--&lt;网络类型&gt;：列出该网络类型连线中的相关地址；</span><br><span class=\"line\">-c或--continuous：持续列出网络状态；</span><br><span class=\"line\">-C或--cache：显示路由器配置的快取信息；</span><br><span class=\"line\">-e或--extend：显示网络其他相关信息；</span><br><span class=\"line\">-F或--fib：显示FIB；</span><br><span class=\"line\">-g或--groups：显示多重广播功能群组组员名单；</span><br><span class=\"line\">-h或--help：在线帮助；</span><br><span class=\"line\">-i或--interfaces：显示网络界面信息表单；</span><br><span class=\"line\">-l或--listening：显示监控中的服务器的Socket；</span><br><span class=\"line\">-M或--masquerade：显示伪装的网络连线；</span><br><span class=\"line\">-n或--numeric：直接使用ip地址，而不通过域名服务器；</span><br><span class=\"line\">-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称；</span><br><span class=\"line\">-o或--timers：显示计时器；</span><br><span class=\"line\">-p或--programs：显示正在使用Socket的程序识别码和程序名称；</span><br><span class=\"line\">-r或--route：显示Routing Table；</span><br><span class=\"line\">-s或--statistice：显示网络工作信息统计表；</span><br><span class=\"line\">-t或--tcp：显示TCP传输协议的连线状况；</span><br><span class=\"line\">-u或--udp：显示UDP传输协议的连线状况；</span><br><span class=\"line\">-v或--verbose：显示指令执行过程；</span><br><span class=\"line\">-V或--version：显示版本信息；</span><br><span class=\"line\">-w或--raw：显示RAW传输协议的连线状况；</span><br><span class=\"line\">-x或--unix：此参数的效果和指定&quot;-A unix&quot;参数相同；</span><br><span class=\"line\">--ip或--inet：此参数的效果和指定&quot;-A inet&quot;参数相同。</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><p>###查看linux的连接数，输出每个ip的连接数，以及总的各个状态的连接数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;n&#x3D;split($(NF-1),array,&quot;:&quot;);if(n&lt;&#x3D;2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N&#125; END &#123;for(a in S)&#123;printf(&quot;%-20s %s\\n&quot;, a, S[a]);++I&#125;printf(&quot;%-20s %s\\n&quot;,&quot;TOTAL_IP&quot;,I);for(a in s) printf(&quot;%-20s %s\\n&quot;,a, s[a]);printf(&quot;%-20s %s\\n&quot;,&quot;TOTAL_LINK&quot;,N);&#125;&#39;</span><br></pre></td></tr></table></figure>\n<p>###查看日志中不同端口对应的连接数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &#x2F;home&#x2F;ubuntu&#x2F;log&#x2F;gears-proxy-error.log |  egrep &#39;:922[6-9]&#39; | awk -F &quot;upstream\\&quot;: &quot; &#39;&#123;print $2&#125;&#39; | awk -F, &#39;&#123;print $1&#125;&#39; |sort | uniq -c | sort -rn</span><br></pre></td></tr></table></figure>\n<p>###查看某些端口 有哪些ip链接  并且连接数有多少</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -ntu |  egrep &#39;:922[6-9]&#39; | awk &#39;&#123;print $5&#125;&#39; | cut -d: -f1 | awk &#39;&#123;++ip[$1]&#125; END &#123;for(i in ip) print ip[i],&quot;\\t&quot;,i&#125;&#39; | sort -nr</span><br></pre></td></tr></table></figure>\n<p>###如果发现某个端口被占用后，可以用命令查看，该端口到底是被哪个进程所占用。命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -pan | grep 5623</span><br></pre></td></tr></table></figure>\n<p>###查看进程程序名称</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ps -aux | grep pid</span><br></pre></td></tr></table></figure>\n<p>###查看tcp连接数量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -anptl | wc -l</span><br></pre></td></tr></table></figure>\n<p>###查看每个ip跟服务器建立的连接数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -nat|awk &#39;&#123;print$5&#125;&#39;|awk -F : &#39;&#123;print$1&#125;&#39;|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://blog.csdn.net/bluetjs/article/details/80965967\">netstat监控大量ESTABLISHED连接数和TIME_WAIT连接数题解决</a><br>###查看每个ip跟服务器建立的连接数<br>–（PS：正则解析：显示第5列，-F : 以：分割，显示列，sort 排序，uniq -c统计排序过程中的重复行，sort -rn 按纯数字进行逆序排序）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -nat|awk &#39;&#123;print$5&#125;&#39;|awk -F : &#39;&#123;print$1&#125;&#39;|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure>\n<p>###查看每个ip建立的ESTABLISHED/TIME_OUT状态的连接数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -nat|grep ESTABLISHED|awk &#39;&#123;print$5&#125;&#39;|awk -F : &#39;&#123;print$1&#125;&#39;|sort|uniq -c|sort -rn</span><br></pre></td></tr></table></figure>\n<p>###查看不同状态的连接数数量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -an | awk &#39;&#x2F;^tcp&#x2F; &#123;++y[$NF]&#125; END &#123;for(w in y) print w, y[w]&#125;&#39;</span><br></pre></td></tr></table></figure>\n","categories":["Linux","命令"],"tags":["netstat"]},{"title":"nginx 只配置了一个域名，结果另一个域名也能访问","url":"/2021/05/07/Linux/nginx%20%E5%8F%AA%E9%85%8D%E7%BD%AE%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%E4%B9%9F%E8%83%BD%E8%AE%BF%E9%97%AE/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>今天自己在部署业务的时候， 一个同事说他用另一个域名访问到了我这个域名下的网页, 看来我自己的Nginx的配置，感觉没什么问题！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">           listen 80;</span><br><span class=\"line\">           server_name www.hehe.com;</span><br><span class=\"line\">           root &#x2F;data1&#x2F;htdocs&#x2F;kaixuan.hehe.com&#x2F;;</span><br><span class=\"line\">           location ~ \\.php$ &#123;</span><br><span class=\"line\">                fastcgi_pass   127.0.0.1:9000;</span><br><span class=\"line\">                fastcgi_index  index.php;</span><br><span class=\"line\">                fastcgi_param  SCRIPT_FILENAME  $document_root&#x2F;$fastcgi_script_name;</span><br><span class=\"line\">                include        fastcgi_params;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           location &#x2F; &#123;</span><br><span class=\"line\">                 index index.html;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后来网上查了一下，发现如果当所有server的规则都不匹配时，nginx会采用第一条server配置，所以一般第一条server会使用阻止页面。这样的话，就需要在server上边再加一条server，加一条默认的阻挡。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen  80 default;</span><br><span class=\"line\">    listen  [::]:80 default;</span><br><span class=\"line\">    server_name  _;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 403;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">           listen 80;</span><br><span class=\"line\">           server_name www.hehe.com;</span><br><span class=\"line\">           root &#x2F;data1&#x2F;htdocs&#x2F;kaixuan.hehe.com&#x2F;;</span><br><span class=\"line\">           location ~ \\.php$ &#123;</span><br><span class=\"line\">                fastcgi_pass   127.0.0.1:9000;</span><br><span class=\"line\">                fastcgi_index  index.php;</span><br><span class=\"line\">                fastcgi_param  SCRIPT_FILENAME  $document_root&#x2F;$fastcgi_script_name;</span><br><span class=\"line\">                include        fastcgi_params;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           location &#x2F; &#123;</span><br><span class=\"line\">                 index index.html;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Linux","web"],"tags":["nginx"]},{"title":"supervisor安装、配置及常用命令","url":"/2021/05/07/Linux/supervisor%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h1><p>在 web 应用部署到线上后，需要保证应用一直处于运行状态，在遇到程序异常、报错等情况，导致 web 应用终止时，需要保证程序可以立刻重启，继续提供服务。</p>\n<p>而Supervisor 就是解决这种问题的工具，可以提供程序崩溃后，重新把程序启动起来等功能。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><strong>简介</strong></h1><p>Supervisor 是一个用 Python 写的进程管理工具，可以很方便的用来在 UNIX-like 系统（不支持 Windows）下启动、重启（自动重启程序）、关闭进程（不仅仅是 Python 进程）。</p>\n<blockquote>\n<p>Supervisor is a client/server system that allows its users to control a number of processes on UNIX-like operating systems.</p>\n</blockquote>\n<hr>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a><strong>安装</strong></h1><p>1、redhat/centos系统</p>\n<p>安装命令：yum install supervisor，通过这种方式安装后，自动设置为开机启动</p>\n<p>2、Ubuntu系统：</p>\n<p>安装命令：apt-get install supervisor，通过这种方式安装后，自动设置为开机启动</p>\n<p>3、pip命令（不推荐）</p>\n<p>通过 pip install supervisor 进行安装，但是需要手动启动，然后设置为开机启动。</p>\n<hr>\n<h1 id=\"Supervisor-配置\"><a href=\"#Supervisor-配置\" class=\"headerlink\" title=\"Supervisor 配置\"></a><strong>Supervisor 配置</strong></h1><p>Supervisor 是一个 C/S 模型的程序，supervisord 是 server 端，supervisorctl 是 client 端。</p>\n<p><strong>supervisord</strong></p>\n<p>下面介绍 supervisord 配置方法。supervisord 的配置文件默认位于 /etc/supervisord.conf，内容如下（;后面为注释）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[unix_http_server]</span><br><span class=\"line\">file&#x3D;&#x2F;tmp&#x2F;supervisor.sock ;UNIX socket 文件，supervisorctl 会使用</span><br><span class=\"line\">;chmod&#x3D;0700 ;socket文件的mode，默认是0700</span><br><span class=\"line\">;chown&#x3D;nobody:nogroup ;socket文件的owner，格式：uid:gid</span><br><span class=\"line\">;[inet_http_server] ;HTTP服务器，提供web管理界面</span><br><span class=\"line\">;port&#x3D;127.0.0.1:9001 ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class=\"line\">;username&#x3D;user ;登录管理后台的用户名</span><br><span class=\"line\">;password&#x3D;123 ;登录管理后台的密码</span><br><span class=\"line\">[supervisord]</span><br><span class=\"line\">logfile&#x3D;&#x2F;tmp&#x2F;supervisord.log ;日志文件，默认是 $CWD&#x2F;supervisord.log</span><br><span class=\"line\">logfile_maxbytes&#x3D;50MB ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class=\"line\">logfile_backups&#x3D;10 ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class=\"line\">loglevel&#x3D;info ;日志级别，默认info，其它: debug,warn,trace</span><br><span class=\"line\">pidfile&#x3D;&#x2F;tmp&#x2F;supervisord.pid ;pid 文件</span><br><span class=\"line\">nodaemon&#x3D;false ;是否在前台启动，默认是false，即以 daemon 的方式启动</span><br><span class=\"line\">minfds&#x3D;1024 ;可以打开的文件描述符的最小值，默认 1024</span><br><span class=\"line\">minprocs&#x3D;200 ;可以打开的进程数的最小值，默认 200</span><br><span class=\"line\">[supervisorctl]</span><br><span class=\"line\">serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;tmp&#x2F;supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span><br><span class=\"line\">;serverurl&#x3D;http:&#x2F;&#x2F;127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span><br><span class=\"line\">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class=\"line\">[program:xx]</span><br><span class=\"line\">command&#x3D;&#x2F;opt&#x2F;apache-tomcat-8.0.35&#x2F;bin&#x2F;catalina.sh run ; 程序启动命令</span><br><span class=\"line\">autostart&#x3D;true ; 在supervisord启动的时候也自动启动</span><br><span class=\"line\">startsecs&#x3D;10 ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br><span class=\"line\">autorestart&#x3D;true ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class=\"line\">startretries&#x3D;3 ; 启动失败自动重试次数，默认是3</span><br><span class=\"line\">user&#x3D;tomcat ; 用哪个用户启动进程，默认是root</span><br><span class=\"line\">priority&#x3D;999 ; 进程启动优先级，默认999，值小的优先启动</span><br><span class=\"line\">redirect_stderr&#x3D;true ; 把stderr重定向到stdout，默认false</span><br><span class=\"line\">stdout_logfile_maxbytes&#x3D;20MB ; stdout 日志文件大小，默认50MB</span><br><span class=\"line\">stdout_logfile_backups &#x3D; 20 ; stdout 日志文件备份数，默认是10</span><br><span class=\"line\">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class=\"line\">stdout_logfile&#x3D;&#x2F;opt&#x2F;apache-tomcat-8.0.35&#x2F;logs&#x2F;catalina.out</span><br><span class=\"line\">stopasgroup&#x3D;false ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class=\"line\">killasgroup&#x3D;false ;默认为false，向进程组发送kill信号，包括子进程</span><br><span class=\"line\">;包含其它配置文件</span><br><span class=\"line\">[include]</span><br><span class=\"line\">files &#x3D; relative&#x2F;directory&#x2F;*.ini ;可以指定一个或多个以.ini结束的配置文件</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"配置管理进程\"><a href=\"#配置管理进程\" class=\"headerlink\" title=\"配置管理进程\"></a><strong>配置管理进程</strong></h1><p>进程管理配置参数，不建议全都写在supervisord.conf文件中，应该每个进程写一个配置文件放在include指定的目录下包含进supervisord.conf文件中。</p>\n<p>1&gt; 创建/etc/supervisor/config.d目录，用于存放进程管理的配置文件</p>\n<p>2&gt; 修改/etc/supervisor/supervisord.conf中的include参数，将/etc/supervisor/conf.d目录添加到include</p>\n<p>下面是配置Tomcat进程的一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[program:tomcat]</span><br><span class=\"line\">command&#x3D;&#x2F;opt&#x2F;apache-tomcat-8.0.35&#x2F;bin&#x2F;catalina.sh run</span><br><span class=\"line\">stdout_logfile&#x3D;&#x2F;opt&#x2F;apache-tomcat-8.0.35&#x2F;logs&#x2F;catalina.out</span><br><span class=\"line\">autostart&#x3D;true</span><br><span class=\"line\">autorestart&#x3D;true</span><br><span class=\"line\">startsecs&#x3D;5</span><br><span class=\"line\">priority&#x3D;1</span><br><span class=\"line\">stopasgroup&#x3D;true</span><br><span class=\"line\">killasgroup&#x3D;true</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"启动Supervisor服务\"><a href=\"#启动Supervisor服务\" class=\"headerlink\" title=\"启动Supervisor服务\"></a><strong>启动Supervisor服务</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">supervisord -c &#x2F;etc&#x2F;supervisor&#x2F;supervisord.conf</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"Web管理界面\"><a href=\"#Web管理界面\" class=\"headerlink\" title=\"Web管理界面\"></a>Web管理界面</h1><p>出于安全考虑，默认配置是没有开启web管理界面，需要修改supervisord.conf配置文件打开http访权限，将下面的配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">;[inet_http_server] ; inet (TCP) server disabled by default</span><br><span class=\"line\">;port&#x3D;127.0.0.1:9001 ; (ip_address:port specifier, *:port for all iface)</span><br><span class=\"line\">;username&#x3D;user ; (default is no username (open server))</span><br><span class=\"line\">;password&#x3D;123 ; (default is no password (open server))</span><br></pre></td></tr></table></figure>\n\n<p>修改成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[inet_http_server] ; inet (TCP) server disabled by default</span><br><span class=\"line\">port&#x3D;0.0.0.0:9001 ; (ip_address:port specifier, *:port for all iface)</span><br><span class=\"line\">username&#x3D;user ; (default is no username (open server))</span><br><span class=\"line\">password&#x3D;123 ; (default is no password (open server))</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"注意：一定要重启supervisord服务配置才会生效\"><a href=\"#注意：一定要重启supervisord服务配置才会生效\" class=\"headerlink\" title=\"注意：一定要重启supervisord服务配置才会生效\"></a>注意：一定要重启supervisord服务配置才会生效</h1><p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-79a759b44b4b6f07?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>重启后访问 ip:9001 (账号密码为user/123)</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-f3b97fb119e6cb71?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-85c00796b6835c4d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<hr>\n<h1 id=\"supervisorctl-操作\"><a href=\"#supervisorctl-操作\" class=\"headerlink\" title=\"supervisorctl 操作\"></a><strong>supervisorctl 操作</strong></h1><p>supervisorctl 是 supervisord 的命令行客户端工具，使用的配置和 supervisord 一样，这里就不再说了。下面，主要介绍 supervisorctl 操作的常用命令：</p>\n<p>输入命令 supervisorctl 进入 supervisorctl 的 shell 交互界面（还是纯命令行），就可以在下面输入命令了。：</p>\n<ul>\n<li>help # 查看帮助</li>\n<li>status # 查看程序状态</li>\n<li>stop program_name # 关闭 指定的程序</li>\n<li>start program_name # 启动 指定的程序</li>\n<li>restart program_name # 重启 指定的程序</li>\n<li>tail -f program_name # 查看 该程序的日志</li>\n<li>update # 重启配置文件修改过的程序（修改了配置，通过这个命令加载新的配置)</li>\n</ul>\n<p>也可以直接通过 shell 命令操作：</p>\n<ul>\n<li>supervisorctl status</li>\n<li>supervisorctl update</li>\n<li>…..</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-811d613ded43921c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h1 id=\"配置详情\"><a href=\"#配置详情\" class=\"headerlink\" title=\"配置详情\"></a>配置详情</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[unix_http_server]</span><br><span class=\"line\">file&#x3D;&#x2F;tmp&#x2F;supervisor.sock   ; socket文件的路径，supervisorctl用XML_RPC和supervisord通信就是通过它进行</span><br><span class=\"line\">                              的。如果不设置的话，supervisorctl也就不能用了</span><br><span class=\"line\">                              不设置的话，默认为none。 非必须设置</span><br><span class=\"line\">;chmod&#x3D;0700                 ; 这个简单，就是修改上面的那个socket文件的权限为0700</span><br><span class=\"line\">                              不设置的话，默认为0700。 非必须设置</span><br><span class=\"line\">;chown&#x3D;nobody:nogroup       ; 这个一样，修改上面的那个socket文件的属组为user.group</span><br><span class=\"line\">                              不设置的话，默认为启动supervisord进程的用户及属组。非必须设置</span><br><span class=\"line\">;username&#x3D;user              ; 使用supervisorctl连接的时候，认证的用户</span><br><span class=\"line\">                               不设置的话，默认为不需要用户。 非必须设置</span><br><span class=\"line\">;password&#x3D;123               ; 和上面的用户名对应的密码，可以直接使用明码，也可以使用SHA加密</span><br><span class=\"line\">                              如：&#123;SHA&#125;82ab876d1387bfafe46cc1c8a2ef074eae50cb1d</span><br><span class=\"line\">                              默认不设置。。。非必须设置</span><br><span class=\"line\"></span><br><span class=\"line\">;[inet_http_server]         ; 侦听在TCP上的socket，Web Server和远程的supervisorctl都要用到他</span><br><span class=\"line\">                              不设置的话，默认为不开启。非必须设置</span><br><span class=\"line\">;port&#x3D;127.0.0.1:9001        ; 这个是侦听的IP和端口，侦听所有IP用 :9001或*:9001。</span><br><span class=\"line\">                              这个必须设置，只要上面的[inet_http_server]开启了，就必须设置它</span><br><span class=\"line\">;username&#x3D;user              ; 这个和上面的uinx_http_server一个样。非必须设置</span><br><span class=\"line\">;password&#x3D;123               ; 这个也一个样。非必须设置</span><br><span class=\"line\"></span><br><span class=\"line\">[supervisord]                ;这个主要是定义supervisord这个服务端进程的一些参数的</span><br><span class=\"line\">                              这个必须设置，不设置，supervisor就不用干活了</span><br><span class=\"line\">logfile&#x3D;&#x2F;tmp&#x2F;supervisord.log ; 这个是supervisord这个主进程的日志路径，注意和子进程的日志不搭嘎。</span><br><span class=\"line\">                               默认路径$CWD&#x2F;supervisord.log，$CWD是当前目录。。非必须设置</span><br><span class=\"line\">logfile_maxbytes&#x3D;50MB        ; 这个是上面那个日志文件的最大的大小，当超过50M的时候，会生成一个新的日</span><br><span class=\"line\">                               志文件。当设置为0时，表示不限制文件大小</span><br><span class=\"line\">                               默认值是50M，非必须设置。</span><br><span class=\"line\">logfile_backups&#x3D;10           ; 日志文件保持的数量，supervisor在启动程序时，会自动创建10个buckup文件，用于log rotate</span><br><span class=\"line\">                               当设置为0时，表示不限制文件的数量。</span><br><span class=\"line\">                               默认情况下为10。。。非必须设置</span><br><span class=\"line\">loglevel&#x3D;info                ; 日志级别，有critical, error, warn, info, debug, trace, or blather等</span><br><span class=\"line\">                               默认为info。。。非必须设置项</span><br><span class=\"line\">pidfile&#x3D;&#x2F;tmp&#x2F;supervisord.pid ; supervisord的pid文件路径。</span><br><span class=\"line\">                               默认为$CWD&#x2F;supervisord.pid。。。非必须设置</span><br><span class=\"line\">nodaemon&#x3D;false               ; 如果是true，supervisord进程将在前台运行</span><br><span class=\"line\">                               默认为false，也就是后台以守护进程运行。。。非必须设置</span><br><span class=\"line\">minfds&#x3D;1024                  ; 这个是最少系统空闲的文件描述符，低于这个值supervisor将不会启动。</span><br><span class=\"line\">                               系统的文件描述符在这里设置cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</span><br><span class=\"line\">                               默认情况下为1024。。。非必须设置</span><br><span class=\"line\">minprocs&#x3D;200                 ; 最小可用的进程描述符，低于这个值supervisor也将不会正常启动。</span><br><span class=\"line\">                              ulimit  -u这个命令，可以查看linux下面用户的最大进程数</span><br><span class=\"line\">                              默认为200。。。非必须设置</span><br><span class=\"line\">;umask&#x3D;022                   ; 进程创建文件的掩码</span><br><span class=\"line\">                               默认为022。。非必须设置项</span><br><span class=\"line\">;user&#x3D;chrism                 ; 这个参数可以设置一个非root用户，当我们以root用户启动supervisord之后。</span><br><span class=\"line\">                               我这里面设置的这个用户，也可以对supervisord进行管理</span><br><span class=\"line\">                               默认情况是不设置。。。非必须设置项</span><br><span class=\"line\">;identifier&#x3D;supervisor       ; 这个参数是supervisord的标识符，主要是给XML_RPC用的。当你有多个</span><br><span class=\"line\">                               supervisor的时候，而且想调用XML_RPC统一管理，就需要为每个</span><br><span class=\"line\">                               supervisor设置不同的标识符了</span><br><span class=\"line\">                               默认是supervisord。。。非必需设置</span><br><span class=\"line\">;directory&#x3D;&#x2F;tmp              ; 这个参数是当supervisord作为守护进程运行的时候，设置这个参数的话，启动</span><br><span class=\"line\">                               supervisord进程之前，会先切换到这个目录</span><br><span class=\"line\">                               默认不设置。。。非必须设置</span><br><span class=\"line\">;nocleanup&#x3D;true              ; 这个参数当为false的时候，会在supervisord进程启动的时候，把以前子进程</span><br><span class=\"line\">                               产生的日志文件(路径为AUTO的情况下)清除掉。有时候咱们想要看历史日志，当</span><br><span class=\"line\">                               然不想日志被清除了。所以可以设置为true</span><br><span class=\"line\">                               默认是false，有调试需求的同学可以设置为true。。。非必须设置</span><br><span class=\"line\">;childlogdir&#x3D;&#x2F;tmp            ; 当子进程日志路径为AUTO的时候，子进程日志文件的存放路径。</span><br><span class=\"line\">                               默认路径是这个东西，执行下面的这个命令看看就OK了，处理的东西就默认路径</span><br><span class=\"line\">                               python -c &quot;import tempfile;print tempfile.gettempdir()&quot;</span><br><span class=\"line\">                               非必须设置</span><br><span class=\"line\">;environment&#x3D;KEY&#x3D;&quot;value&quot;     ; 这个是用来设置环境变量的，supervisord在linux中启动默认继承了linux的</span><br><span class=\"line\">                               环境变量，在这里可以设置supervisord进程特有的其他环境变量。</span><br><span class=\"line\">                               supervisord启动子进程时，子进程会拷贝父进程的内存空间内容。 所以设置的</span><br><span class=\"line\">                               这些环境变量也会被子进程继承。</span><br><span class=\"line\">                               小例子：environment&#x3D;name&#x3D;&quot;haha&quot;,age&#x3D;&quot;hehe&quot;</span><br><span class=\"line\">                               默认为不设置。。。非必须设置</span><br><span class=\"line\">;strip_ansi&#x3D;false            ; 这个选项如果设置为true，会清除子进程日志中的所有ANSI 序列。什么是ANSI</span><br><span class=\"line\">                               序列呢？就是我们的\\n,\\t这些东西。</span><br><span class=\"line\">                               默认为false。。。非必须设置</span><br><span class=\"line\"></span><br><span class=\"line\">; the below section must remain in the config file for RPC</span><br><span class=\"line\">; (supervisorctl&#x2F;web interface) to work, additional interfaces may be</span><br><span class=\"line\">; added by defining them in separate rpcinterface: sections</span><br><span class=\"line\">[rpcinterface:supervisor]    ;这个选项是给XML_RPC用的，当然你如果想使用supervisord或者web server 这</span><br><span class=\"line\">                              个选项必须要开启的</span><br><span class=\"line\">supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface</span><br><span class=\"line\"></span><br><span class=\"line\">[supervisorctl]              ;这个主要是针对supervisorctl的一些配置</span><br><span class=\"line\">serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;tmp&#x2F;supervisor.sock ; 这个是supervisorctl本地连接supervisord的时候，本地UNIX socket</span><br><span class=\"line\">                                        路径，注意这个是和前面的[unix_http_server]对应的</span><br><span class=\"line\">                                        默认值就是unix:&#x2F;&#x2F;&#x2F;tmp&#x2F;supervisor.sock。。非必须设置</span><br><span class=\"line\">;serverurl&#x3D;http:&#x2F;&#x2F;127.0.0.1:9001 ; 这个是supervisorctl远程连接supervisord的时候，用到的TCP socket路径</span><br><span class=\"line\">                                   注意这个和前面的[inet_http_server]对应</span><br><span class=\"line\">                                   默认就是http:&#x2F;&#x2F;127.0.0.1:9001。。。非必须项</span><br><span class=\"line\"></span><br><span class=\"line\">;username&#x3D;chris              ; 用户名</span><br><span class=\"line\">                               默认空。。非必须设置</span><br><span class=\"line\">;password&#x3D;123                ; 密码</span><br><span class=\"line\">                              默认空。。非必须设置</span><br><span class=\"line\">;prompt&#x3D;mysupervisor         ; 输入用户名密码时候的提示符</span><br><span class=\"line\">                               默认supervisor。。非必须设置</span><br><span class=\"line\">;history_file&#x3D;~&#x2F;.sc_history  ; 这个参数和shell中的history类似，我们可以用上下键来查找前面执行过的命令</span><br><span class=\"line\">                               默认是no file的。。所以我们想要有这种功能，必须指定一个文件。。。非</span><br><span class=\"line\">                               必须设置</span><br><span class=\"line\"></span><br><span class=\"line\">; The below sample program section shows all possible program subsection values,</span><br><span class=\"line\">; create one or more &#39;real&#39; program: sections to be able to control them under</span><br><span class=\"line\">; supervisor.</span><br><span class=\"line\"></span><br><span class=\"line\">;[program:theprogramname]      ;这个就是咱们要管理的子进程了，&quot;:&quot;后面的是名字，最好别乱写和实际进程</span><br><span class=\"line\">                                有点关联最好。这样的program我们可以设置一个或多个，一个program就是</span><br><span class=\"line\">                                要被管理的一个进程</span><br><span class=\"line\">;command&#x3D;&#x2F;bin&#x2F;cat              ; 这个就是我们的要启动进程的命令路径了，可以带参数</span><br><span class=\"line\">                                例子：&#x2F;home&#x2F;test.py -a &#39;hehe&#39;</span><br><span class=\"line\">                                有一点需要注意的是，我们的command只能是那种在终端运行的进程，不能是</span><br><span class=\"line\">                                守护进程。这个想想也知道了，比如说command&#x3D;service httpd start。</span><br><span class=\"line\">                                httpd这个进程被linux的service管理了，我们的supervisor再去启动这个命令</span><br><span class=\"line\">                                这已经不是严格意义的子进程了。</span><br><span class=\"line\">                                这个是个必须设置的项</span><br><span class=\"line\">;process_name&#x3D;%(program_name)s ; 这个是进程名，如果我们下面的numprocs参数为1的话，就不用管这个参数</span><br><span class=\"line\">                                 了，它默认值%(program_name)s也就是上面的那个program冒号后面的名字，</span><br><span class=\"line\">                                 但是如果numprocs为多个的话，那就不能这么干了。想想也知道，不可能每个</span><br><span class=\"line\">                                 进程都用同一个进程名吧。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">;numprocs&#x3D;1                    ; 启动进程的数目。当不为1时，就是进程池的概念，注意process_name的设置</span><br><span class=\"line\">                                 默认为1    。。非必须设置</span><br><span class=\"line\">;directory&#x3D;&#x2F;tmp                ; 进程运行前，会前切换到这个目录</span><br><span class=\"line\">                                 默认不设置。。。非必须设置</span><br><span class=\"line\">;umask&#x3D;022                     ; 进程掩码，默认none，非必须</span><br><span class=\"line\">;priority&#x3D;999                  ; 子进程启动关闭优先级，优先级低的，最先启动，关闭的时候最后关闭</span><br><span class=\"line\">                                 默认值为999 。。非必须设置</span><br><span class=\"line\">;autostart&#x3D;true                ; 如果是true的话，子进程将在supervisord启动后被自动启动</span><br><span class=\"line\">                                 默认就是true   。。非必须设置</span><br><span class=\"line\">;autorestart&#x3D;unexpected        ; 这个是设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected</span><br><span class=\"line\">                                 和true。如果为false的时候，无论什么情况下，都不会被重新启动，</span><br><span class=\"line\">                                 如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的退</span><br><span class=\"line\">                                 出码的时候，才会被自动重启。当为true的时候，只要子进程挂掉，将会被无</span><br><span class=\"line\">                                 条件的重启</span><br><span class=\"line\">;startsecs&#x3D;1                   ; 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启</span><br><span class=\"line\">                                 动成功了</span><br><span class=\"line\">                                 默认值为1 。。非必须设置</span><br><span class=\"line\">;startretries&#x3D;3                ; 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把</span><br><span class=\"line\">                                 此进程的状态置为FAIL</span><br><span class=\"line\">                                 默认值为3 。。非必须设置</span><br><span class=\"line\">;exitcodes&#x3D;0,2                 ; 注意和上面的的autorestart&#x3D;unexpected对应。。exitcodes里面的定义的</span><br><span class=\"line\">                                 退出码是expected的。</span><br><span class=\"line\">;stopsignal&#x3D;QUIT               ; 进程停止信号，可以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2等信号</span><br><span class=\"line\">                                  默认为TERM 。。当用设定的信号去干掉进程，退出码会被认为是expected</span><br><span class=\"line\">                                  非必须设置</span><br><span class=\"line\">;stopwaitsecs&#x3D;10               ; 这个是当我们向子进程发送stopsignal信号后，到系统返回信息</span><br><span class=\"line\">                                 给supervisord，所等待的最大时间。 超过这个时间，supervisord会向该</span><br><span class=\"line\">                                 子进程发送一个强制kill的信号。</span><br><span class=\"line\">                                 默认为10秒。。非必须设置</span><br><span class=\"line\">;stopasgroup&#x3D;false             ; 这个东西主要用于，supervisord管理的子进程，这个子进程本身还有</span><br><span class=\"line\">                                 子进程。那么我们如果仅仅干掉supervisord的子进程的话，子进程的子进程</span><br><span class=\"line\">                                 有可能会变成孤儿进程。所以咱们可以设置可个选项，把整个该子进程的</span><br><span class=\"line\">                                 整个进程组都干掉。 设置为true的话，一般killasgroup也会被设置为true。</span><br><span class=\"line\">                                 需要注意的是，该选项发送的是stop信号</span><br><span class=\"line\">                                 默认为false。。非必须设置。。</span><br><span class=\"line\">;killasgroup&#x3D;false             ; 这个和上面的stopasgroup类似，不过发送的是kill信号</span><br><span class=\"line\">;user&#x3D;chrism                   ; 如果supervisord是root启动，我们在这里设置这个非root用户，可以用来</span><br><span class=\"line\">                                 管理该program</span><br><span class=\"line\">                                 默认不设置。。。非必须设置项</span><br><span class=\"line\">;redirect_stderr&#x3D;true          ; 如果为true，则stderr的日志会被写入stdout日志文件中</span><br><span class=\"line\">                                 默认为false，非必须设置</span><br><span class=\"line\">;stdout_logfile&#x3D;&#x2F;a&#x2F;path        ; 子进程的stdout的日志路径，可以指定路径，AUTO，none等三个选项。</span><br><span class=\"line\">                                 设置为none的话，将没有日志产生。设置为AUTO的话，将随机找一个地方</span><br><span class=\"line\">                                 生成日志文件，而且当supervisord重新启动的时候，以前的日志文件会被</span><br><span class=\"line\">                                 清空。当 redirect_stderr&#x3D;true的时候，sterr也会写进这个日志文件</span><br><span class=\"line\">;stdout_logfile_maxbytes&#x3D;1MB   ; 日志文件最大大小，和[supervisord]中定义的一样。默认为50</span><br><span class=\"line\">;stdout_logfile_backups&#x3D;10     ; 和[supervisord]定义的一样。默认10</span><br><span class=\"line\">;stdout_capture_maxbytes&#x3D;1MB   ; 这个东西是设定capture管道的大小，当值不为0的时候，子进程可以从stdout</span><br><span class=\"line\">                                 发送信息，而supervisor可以根据信息，发送相应的event。</span><br><span class=\"line\">                                 默认为0，为0的时候表达关闭管道。。。非必须项</span><br><span class=\"line\">;stdout_events_enabled&#x3D;false   ; 当设置为ture的时候，当子进程由stdout向文件描述符中写日志的时候，将</span><br><span class=\"line\">                                 触发supervisord发送PROCESS_LOG_STDOUT类型的event</span><br><span class=\"line\">                                 默认为false。。。非必须设置</span><br><span class=\"line\">;stderr_logfile&#x3D;&#x2F;a&#x2F;path        ; 这个东西是设置stderr写的日志路径，当redirect_stderr&#x3D;true。这个就不用</span><br><span class=\"line\">                                 设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中</span><br><span class=\"line\">                                 默认为AUTO，也就是随便找个地存，supervisord重启被清空。。非必须设置</span><br><span class=\"line\">;stderr_logfile_maxbytes&#x3D;1MB   ; 这个出现好几次了，就不重复了</span><br><span class=\"line\">;stderr_logfile_backups&#x3D;10     ; 这个也是</span><br><span class=\"line\">;stderr_capture_maxbytes&#x3D;1MB   ; 这个一样，和stdout_capture一样。 默认为0，关闭状态</span><br><span class=\"line\">;stderr_events_enabled&#x3D;false   ; 这个也是一样，默认为false</span><br><span class=\"line\">;environment&#x3D;A&#x3D;&quot;1&quot;,B&#x3D;&quot;2&quot;       ; 这个是该子进程的环境变量，和别的子进程是不共享的</span><br><span class=\"line\">;serverurl&#x3D;AUTO                ;</span><br><span class=\"line\"></span><br><span class=\"line\">; The below sample eventlistener section shows all possible</span><br><span class=\"line\">; eventlistener subsection values, create one or more &#39;real&#39;</span><br><span class=\"line\">; eventlistener: sections to be able to handle event notifications</span><br><span class=\"line\">; sent by supervisor.</span><br><span class=\"line\"></span><br><span class=\"line\">;[eventlistener:theeventlistenername] ;这个东西其实和program的地位是一样的，也是suopervisor启动的子进</span><br><span class=\"line\">                                       程，不过它干的活是订阅supervisord发送的event。他的名字就叫</span><br><span class=\"line\">                                       listener了。我们可以在listener里面做一系列处理，比如报警等等</span><br><span class=\"line\">                                       楼主这两天干的活，就是弄的这玩意</span><br><span class=\"line\">;command&#x3D;&#x2F;bin&#x2F;eventlistener    ; 这个和上面的program一样，表示listener的可执行文件的路径</span><br><span class=\"line\">;process_name&#x3D;%(program_name)s ; 这个也一样，进程名，当下面的numprocs为多个的时候，才需要。否则默认就</span><br><span class=\"line\">                                 OK了</span><br><span class=\"line\">;numprocs&#x3D;1                    ; 相同的listener启动的个数</span><br><span class=\"line\">;events&#x3D;EVENT                  ; event事件的类型，也就是说，只有写在这个地方的事件类型。才会被发送</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">;buffer_size&#x3D;10                ; 这个是event队列缓存大小，单位不太清楚，楼主猜测应该是个吧。当buffer</span><br><span class=\"line\">                                 超过10的时候，最旧的event将会被清除，并把新的event放进去。</span><br><span class=\"line\">                                 默认值为10。。非必须选项</span><br><span class=\"line\">;directory&#x3D;&#x2F;tmp                ; 进程执行前，会切换到这个目录下执行</span><br><span class=\"line\">                                 默认为不切换。。。非必须</span><br><span class=\"line\">;umask&#x3D;022                     ; 淹没，默认为none，不说了</span><br><span class=\"line\">;priority&#x3D;-1                   ; 启动优先级，默认-1，也不扯了</span><br><span class=\"line\">;autostart&#x3D;true                ; 是否随supervisord启动一起启动，默认true</span><br><span class=\"line\">;autorestart&#x3D;unexpected        ; 是否自动重启，和program一个样，分true,false,unexpected等，注意</span><br><span class=\"line\">                                  unexpected和exitcodes的关系</span><br><span class=\"line\">;startsecs&#x3D;1                   ; 也是一样，进程启动后跑了几秒钟，才被认定为成功启动，默认1</span><br><span class=\"line\">;startretries&#x3D;3                ; 失败最大尝试次数，默认3</span><br><span class=\"line\">;exitcodes&#x3D;0,2                 ; 期望或者说预料中的进程退出码，</span><br><span class=\"line\">;stopsignal&#x3D;QUIT               ; 干掉进程的信号，默认为TERM，比如设置为QUIT，那么如果QUIT来干这个进程</span><br><span class=\"line\">                                 那么会被认为是正常维护，退出码也被认为是expected中的</span><br><span class=\"line\">;stopwaitsecs&#x3D;10               ; max num secs to wait b4 SIGKILL (default 10)</span><br><span class=\"line\">;stopasgroup&#x3D;false             ; send stop signal to the UNIX process group (default false)</span><br><span class=\"line\">;killasgroup&#x3D;false             ; SIGKILL the UNIX process group (def false)</span><br><span class=\"line\">;user&#x3D;chrism                   ;设置普通用户，可以用来管理该listener进程。</span><br><span class=\"line\">                                默认为空。。非必须设置</span><br><span class=\"line\">;redirect_stderr&#x3D;true          ; 为true的话，stderr的log会并入stdout的log里面</span><br><span class=\"line\">                                默认为false。。。非必须设置</span><br><span class=\"line\">;stdout_logfile&#x3D;&#x2F;a&#x2F;path        ; 这个不说了，好几遍了</span><br><span class=\"line\">;stdout_logfile_maxbytes&#x3D;1MB   ; 这个也是</span><br><span class=\"line\">;stdout_logfile_backups&#x3D;10     ; 这个也是</span><br><span class=\"line\">;stdout_events_enabled&#x3D;false   ; 这个其实是错的，listener是不能发送event</span><br><span class=\"line\">;stderr_logfile&#x3D;&#x2F;a&#x2F;path        ; 这个也是</span><br><span class=\"line\">;stderr_logfile_maxbytes&#x3D;1MB   ; 这个也是</span><br><span class=\"line\">;stderr_logfile_backups        ; 这个不说了</span><br><span class=\"line\">;stderr_events_enabled&#x3D;false   ; 这个也是错的，listener不能发送event</span><br><span class=\"line\">;environment&#x3D;A&#x3D;&quot;1&quot;,B&#x3D;&quot;2&quot;       ; 这个是该子进程的环境变量</span><br><span class=\"line\">                                 默认为空。。。非必须设置</span><br><span class=\"line\">;serverurl&#x3D;AUTO                ; override serverurl computation (childutils)</span><br><span class=\"line\"></span><br><span class=\"line\">; The below sample group section shows all possible group values,</span><br><span class=\"line\">; create one or more &#39;real&#39; group: sections to create &quot;heterogeneous&quot;</span><br><span class=\"line\">; process groups.</span><br><span class=\"line\"></span><br><span class=\"line\">;[group:thegroupname]  ;这个东西就是给programs分组，划分到组里面的program。我们就不用一个一个去操作了</span><br><span class=\"line\">                         我们可以对组名进行统一的操作。 注意：program被划分到组里面之后，就相当于原来</span><br><span class=\"line\">                         的配置从supervisor的配置文件里消失了。。。supervisor只会对组进行管理，而不再</span><br><span class=\"line\">                         会对组里面的单个program进行管理了</span><br><span class=\"line\">;programs&#x3D;progname1,progname2  ; 组成员，用逗号分开</span><br><span class=\"line\">                                 这个是个必须的设置项</span><br><span class=\"line\">;priority&#x3D;999                  ; 优先级，相对于组和组之间说的</span><br><span class=\"line\">                                 默认999。。非必须选项</span><br><span class=\"line\"></span><br><span class=\"line\">; The [include] section can just contain the &quot;files&quot; setting.  This</span><br><span class=\"line\">; setting can list multiple files (separated by whitespace or</span><br><span class=\"line\">; newlines).  It can also contain wildcards.  The filenames are</span><br><span class=\"line\">; interpreted as relative to this file.  Included files *cannot*</span><br><span class=\"line\">; include files themselves.</span><br><span class=\"line\"></span><br><span class=\"line\">;[include]                         ;这个东西挺有用的，当我们要管理的进程很多的时候，写在一个文件里面</span><br><span class=\"line\">                                    就有点大了。我们可以把配置信息写到多个文件中，然后include过来</span><br><span class=\"line\">;files &#x3D; relative&#x2F;directory&#x2F;*.ini</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">OK,上面提到的非必须设置项，一般来说，都是有默认值的，可以根据自己的需要去设置。。。如果不设置的，supervisor也能用起来</span><br><span class=\"line\"></span><br><span class=\"line\">这一篇先总结到这里了，下一篇搞搞event和xml_rpc</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.toutiao.com/a6714650171180843524/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1563958876&app=news_article&utm_source=weixin&utm_medium=toutiao_android&req_id=201907241701150100230730859727DA2&group_id=6714650171180843524\">原文链接</a></p>\n","categories":["Linux","web"],"tags":["supervisor"]},{"title":"nohup详解 Python不挂断运行后台程序","url":"/2021/05/07/Linux/nohup%20%E8%AF%A6%E8%A7%A3%20Python%E4%B8%8D%E6%8C%82%E6%96%AD%E8%BF%90%E8%A1%8C%E5%90%8E%E5%8F%B0%E7%A8%8B%E5%BA%8F/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 id=\"nohup-详解\"><a href=\"#nohup-详解\" class=\"headerlink\" title=\"nohup 详解\"></a>nohup 详解</h1><h2 id=\"nohup\"><a href=\"#nohup\" class=\"headerlink\" title=\"nohup\"></a>nohup</h2><p>nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。</p>\n<p>nohup 是 no hang up 的缩写，就是不挂断的意思。</p>\n<p>nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。</p>\n<p>在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h2><p>1. nohup command &gt; myout.file 2&gt;&amp;1 &amp;   </p>\n<p>在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ；</p>\n<p>2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。</p>\n<p>2. 0 22 * * * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py &gt; /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2&gt;&amp;1</p>\n<p>这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中</p>\n<h2 id=\"nohup和-amp-的区别\"><a href=\"#nohup和-amp-的区别\" class=\"headerlink\" title=\"nohup和&amp;的区别\"></a>nohup和&amp;的区别</h2><p>&amp; ： 指在后台运行</p>\n<p>nohup ： 不挂断的运行，注意并没有后台运行的功能，，就是指，用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；&amp;才是后台运行</p>\n<hr>\n<p>&amp;是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出</p>\n<p>那么，我们可以巧妙的吧他们结合起来用就是<br>nohup COMMAND &amp;<br>这样就能使命令永久的在后台执行</p>\n<p>例如：</p>\n<p>1. sh test.sh &amp;  <br>将sh test.sh任务放到后台 ，即使关闭xshell退出当前session依然继续运行，但<strong>标准输出和标准错误信息会丢失（缺少的日志的输出）</strong></p>\n<p>将sh test.sh任务放到后台 ，关闭xshell，对应的任务也跟着停止。<br>2. nohup sh test.sh  <br>将sh test.sh任务放到后台，关闭标准输入，<strong>终端不再能够接收任何输入（标准输入）</strong>，重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。<br>3. nohup sh test.sh  &amp; <br>将sh test.sh任务放到后台，但是依然可以使用标准输入，<strong>终端能够接收任何输入</strong>，重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://blog.csdn.net/u011095110/article/details/78666833\">https://blog.csdn.net/u011095110/article/details/78666833</a></p>\n<p><a href=\"https://baike.baidu.com/item/nohup/5683841\">https://baike.baidu.com/item/nohup/5683841</a></p>\n<p><a href=\"https://www.cnblogs.com/jinxiao-pu/p/9131057.html\">原文链接</a></p>\n","categories":["Linux","命令"],"tags":["nohup"]},{"title":"ubuntu 16.04 忘记root密码","url":"/2021/05/07/Linux/ubuntu%2016.04%20%E5%BF%98%E8%AE%B0root%E5%AF%86%E7%A0%81/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><strong>阅读目录</strong></p>\n<p>虚拟机中安装的ubuntu 16.04。</p>\n<h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><p>如果用户具有sudo权限，那么直接可以运行如下命令： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo su root</span><br><span class=\"line\">#输入当前用户的密码</span><br><span class=\"line\">passwd</span><br><span class=\"line\">#输入密码</span><br><span class=\"line\">#再次输入密码</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-5861cfa5048c516e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<span id=\"more\"></span>\n\n<h2 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h2><p>如果用户不具备sudo权限，则方法一不能用，并需进入GRUB修改kernel镜像启动参数。 </p>\n<p>1、重启，按住shift键，出现如下界面，选中如下选项</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-9c9453cd285c1cb7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>2、按回车键进入如下界面，然后选中有recovery mode的选项</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-845dafb6e779edc8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>3、按e进入如下界面，找到图中红色框的recovery nomodeset并将其删掉，再在这一行的后面输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">quiet splash rw init&#x3D;&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-d537e09295a2d8bb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-fe262b4985b784e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>4、接着按F10或者Ctrl+x 后出现如下界面，在命令行内输入passwd后进行修改密码即可</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-29372058261e09ea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>修改完之后重启系统。</p>\n<hr>\n<p>#修改某个用户目录下的sudo密码：</p>\n<p>1、进入root目录下<br>2：输入命令 passwd david，(david是系统中已有的username)<br><img src=\"https://upload-images.jianshu.io/upload_images/5818745-3a1e7d6f9bd378c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>3、重新定义密码即可</p>\n<h4 id=\"原文链接-ubuntu-16-04-忘记root密码\"><a href=\"#原文链接-ubuntu-16-04-忘记root密码\" class=\"headerlink\" title=\"原文链接:  ubuntu 16.04 忘记root密码\"></a><a href=\"https://www.cnblogs.com/xiaojianliu/p/8520313.html\">原文链接:  ubuntu 16.04 忘记root密码</a></h4>","categories":["Linux","命令"],"tags":["root","密码"]},{"title":"批量关闭linux进程","url":"/2021/05/07/Linux/%E6%89%B9%E9%87%8F%E5%85%B3%E9%97%ADlinux%E8%BF%9B%E7%A8%8B/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 id=\"批量关闭linux进程\"><a href=\"#批量关闭linux进程\" class=\"headerlink\" title=\"批量关闭linux进程\"></a>批量关闭linux进程</h1><p>你是否经常遇到需要批量杀死很多进程的情况？而你是否还在一个一个的<code>kill</code>。</p>\n<p>接下来我教你一个小秘诀吧。</p>\n<p>1、首先我们查看当前的进程列表。</p>\n<p>我们以查看<code>nginx</code>进程为例，通过<code>ps -ef</code>显示当前机器运行的所有进程，再通过<code>grep nginx</code>过滤出包含<code>nginx</code>字符串的进程。完成命令为<code>ps -ef|grep nginx</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/5818745-6df491a2ab00280c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<span id=\"more\"></span>\n<p>2、获取进程ID<br>采用<code>awk</code>工具提取进程ID。<code>awk</code>是一种很棒的语言，适合文本处理和报表生成。在这里我们通过<code>awk</code>处理第一步中得到的进程列表，提取进程ID。完成命令为<code>ps -ef|grep nginx|awk &#39;&#123;print $2&#125;&#39;</code><br><img src=\"https://upload-images.jianshu.io/upload_images/5818745-a20c9d17c2f36edb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>3、批量kill<br><code>xargs</code> 是一条 Unix 和类 Unix 操作系统的常用命令；它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。接下来将使用<code>xargs</code>把第二步中得到的进程ID列表传递给<code>kill</code>命令。完成命令为<code>ps -ef|grep nginx|awk &#39;&#123;print $2&#125;&#39;|xargs kill -9</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/5818745-4762958db8b46786.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>OK。大功告成，现在可以批量\b<code>kill</code>进程了。</p>\n","categories":["Linux","web"],"tags":["进程"]},{"title":"服务器挂载大于2T的硬盘","url":"/2021/05/07/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8C%82%E8%BD%BD%E5%A4%A7%E4%BA%8E2T%E7%9A%84%E7%A1%AC%E7%9B%98/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景:\"></a>背景:</h3><ul>\n<li>服务器购买的时候带了一个5T硬盘，当使用fdisk进行格式化挂载到文件夹下，发现只有2T！！！后来网上查询发现fdisk只能处理2T以下的硬盘,需要使用parted处理大于2T  以上的硬盘!!<br><img src=\"https://upload-images.jianshu.io/upload_images/5818745-280b76b859b40a65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><img src=\"https://upload-images.jianshu.io/upload_images/5818745-fb584f985db52283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></li>\n</ul>\n<span id=\"more\"></span>\n\n<h3 id=\"命令说明\"><a href=\"#命令说明\" class=\"headerlink\" title=\"命令说明:\"></a>命令说明:</h3><ul>\n<li>磁盘分区的命令有fdisk和parted，但fdisk只能处理2T以下的硬盘，parted能处理大于2T以上的硬盘，由于服务的硬盘是5T，所以我们采用parted作为磁盘分区。</li>\n</ul>\n<h3 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h3><ul>\n<li>一块硬盘要想被使用，要经过分区——&gt;格式化——&gt;挂载。这三个步骤<h4 id=\"1、查看硬盘情况\"><a href=\"#1、查看硬盘情况\" class=\"headerlink\" title=\"1、查看硬盘情况\"></a>1、查看硬盘情况</h4>  fdisk -l<br><img src=\"https://upload-images.jianshu.io/upload_images/5818745-280b76b859b40a65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></li>\n</ul>\n<h4 id=\"2、挂载2T以上的硬盘需要GPT格式，使用parted命令，细节如下\"><a href=\"#2、挂载2T以上的硬盘需要GPT格式，使用parted命令，细节如下\" class=\"headerlink\" title=\"2、挂载2T以上的硬盘需要GPT格式，使用parted命令，细节如下:\"></a>2、挂载2T以上的硬盘需要GPT格式，使用parted命令，细节如下:</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> parted &#x2F;dev&#x2F;vdc</span><br><span class=\"line\">挂载2T以上的硬盘需要GPT格式，使用parted命令，细节如下</span><br><span class=\"line\">（1）parted &#x2F;dev&#x2F;vdc （视具体情况盘符编号）</span><br><span class=\"line\">（2）print （查看当前分区情况）</span><br><span class=\"line\">（3）mklabel gpt （设置分区类型为gpt）</span><br><span class=\"line\">（4）mkpart extended 0% 100% （扩展分区extended ,主分区primary ,并使用整个硬盘）</span><br><span class=\"line\">（5）print （查看一下）</span><br><span class=\"line\">（6）quit</span><br><span class=\"line\">（7）mkfs.ext4 &#x2F;dev&#x2F;vdc（格式化新硬盘，格式化需要比较长的时间，具体根据磁盘读写速度和大小来确定。下面有节点数完成对应的数量即可）</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-51b4146829d5eed4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-a2f0ff76d8ad8397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h4 id=\"3、挂载目录\"><a href=\"#3、挂载目录\" class=\"headerlink\" title=\"3、挂载目录\"></a>3、挂载目录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir  &#x2F;data2 (在根目录下，建一个文件夹，待会将分区挂载在这个文件夹上，以后要往新硬盘存东西就存在新建文件夹下就可以了。)</span><br><span class=\"line\">mount &#x2F;dev&#x2F;vdc &#x2F;data2 （挂载，之后即可使用了，第二个参数是挂载到哪个目录）</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5818745-2a5030fcd54f9e4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h4 id=\"3、自动挂载\"><a href=\"#3、自动挂载\" class=\"headerlink\" title=\"3、自动挂载\"></a>3、自动挂载</h4><p>还没有完事，这样挂载的重启整个服务器后不会自动挂载<br>需要修改/etc/fstab文件，在文件最后追加<br>/dev/vdc /data ext4 defaults 0 0</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo echo &quot;&#x2F;dev&#x2F;vdc &#x2F;data2 ext4 defaults 0 1&quot; &gt;&gt; &#x2F;etc&#x2F;fstab       让系统开机自动挂载这块硬盘</span><br></pre></td></tr></table></figure>\n<p>这样在重启后会自动挂载<br><img src=\"https://upload-images.jianshu.io/upload_images/5818745-5332d2f5122f4654.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h2 id=\"参考目录：\"><a href=\"#参考目录：\" class=\"headerlink\" title=\"参考目录：\"></a>参考目录：</h2><p><a href=\"https://blog.51cto.com/devin223/2175078\">https://blog.51cto.com/devin223/2175078</a><br><a href=\"https://blog.csdn.net/glongljl/article/details/80104569\">https://blog.csdn.net/glongljl/article/details/80104569</a><br><a href=\"https://blog.csdn.net/reliveIT/article/details/44602959\">fdisk和parted磁盘分区工具命令</a><br><a href=\"https://blog.csdn.net/xianjuke008/article/details/88354466\">磁盘挂载问题：Fdisk最大只能创建2T分区的盘，超过2T使用parted</a><br><a href=\"https://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_linux_039_fdisk_gdisk_parted.html\">linux下（fdisk,gdisk,parted）三种分区工具比较</a></p>\n"},{"title":"Django的Model中不创建表格，并设为基类方法","url":"/2021/05/07/django/Django%E7%9A%84Model%E4%B8%AD%E4%B8%8D%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%A0%BC%EF%BC%8C%E5%B9%B6%E8%AE%BE%E4%B8%BA%E5%9F%BA%E7%B1%BB%E6%96%B9%E6%B3%95/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class UserInfo(models.Model):</span><br><span class=\"line\">    &quot;&quot;&quot;用户表&quot;&quot;&quot;</span><br><span class=\"line\">    name &#x3D; models.CharField(verbose_name&#x3D;&#39;用户名&#39;, max_length&#x3D;32)</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    class Meta:</span><br><span class=\"line\">        # 此类可以当做父类，被其他model继承。字段自动过度给，继承的model</span><br><span class=\"line\">        abstract &#x3D; True  # 【django以后做数据库迁移时， 不再为UserInfo类创建相关的表以及表结构了】</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># app01&#x2F;models.py</span><br><span class=\"line\">class UserInfo(RbacUserInfo):  # 继承上面那个userinfo</span><br><span class=\"line\">    &quot;&quot;&quot;用户表&quot;&quot;&quot;</span><br><span class=\"line\">    phone &#x3D; models.CharField(verbose_name&#x3D;&#39;联系方式&#39;, max_length&#x3D;32)</span><br><span class=\"line\">    depart &#x3D; models.ForeignKey(verbose_name&#x3D;&#39;部门&#39;, to&#x3D;&#39;Department&#39;, on_delete&#x3D;models.CASCADE)</span><br></pre></td></tr></table></figure>\n<p>首先介绍下django的模型有哪些属性：先看例子：</p>\n<p>Django 模型类的Meta是一个内部类，它用于定义一些Django模型类的行为特性。以下对此作一总结：</p>\n<p>abstract<br> 这个属性是定义当前的模型类是不是一个抽象类。所谓抽象类是不会对应数据库表的。一般我们用它来归纳一些公共属性字段，然后继承它的子类可以继承这些字段。比如下面的代码中Human是一个抽象类，Employee是一个继承了Human的子类，那么在运行syncdb命令时，不会生成Human表，但是会生成一个Employee表，它包含了Human中继承来的字段，以后如果再添加一个Customer模型类，它可以同样继承Human的公共属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Human(models.Model):</span><br><span class=\"line\">    name&#x3D;models.CharField(max_length&#x3D;100)</span><br><span class=\"line\">    GENDER_CHOICE&#x3D;((u&#39;M&#39;,u&#39;Male&#39;),(u&#39;F&#39;,u&#39;Female&#39;),)</span><br><span class=\"line\">    gender&#x3D;models.CharField(max_length&#x3D;2,choices&#x3D;GENDER_CHOICE,null&#x3D;True)</span><br><span class=\"line\">    class Meta:</span><br><span class=\"line\">        abstract&#x3D;True</span><br><span class=\"line\">class Employee(Human):</span><br><span class=\"line\">    joint_date&#x3D;models.DateField()</span><br><span class=\"line\">class Customer(Human):</span><br><span class=\"line\">    first_name&#x3D;models.CharField(max_length&#x3D;100)</span><br><span class=\"line\">    birth_day&#x3D;models.DateField()</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码，执行python manage.py syncdb 后的输出结果入下，可以看出Human表并没有被创建:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python manage.py syncdb</span><br><span class=\"line\">Creating tables ...</span><br><span class=\"line\">Creating table myapp_employee</span><br><span class=\"line\">Creating table myapp_customer</span><br><span class=\"line\">Installing custom SQL ...</span><br><span class=\"line\">Installing indexes ...</span><br><span class=\"line\">No fixtures found.</span><br><span class=\"line\">•app_label</span><br></pre></td></tr></table></figure>\n\n<p>app_label这个选项只在一种情况下使用，就是你的模型类不在默认的应用程序包下的models.py文件中，这时候你需要指定你这个模型类是那个应用程序的。比如你在其他地方写了一个模型类，而这个模型类是属于myapp的，那么你这是需要指定为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">app_label&#x3D;&#39;myapp&#39;</span><br><span class=\"line\">•db_table</span><br></pre></td></tr></table></figure>\n<p>db_table是用于指定自定义数据库表名的。Django有一套默认的按照一定规则生成数据模型对应的数据库表名，如果你想使用自定义的表名，就通过这个属性指定，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">table_name&#x3D;&#39;my_owner_table&#39;</span><br><span class=\"line\">•db_tablespace</span><br></pre></td></tr></table></figure>\n<p>有些数据库有数据库表空间，比如Oracle。你可以通过db_tablespace来指定这个模型对应的数据库表放在哪个数据库表空间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">•get_latest_by</span><br></pre></td></tr></table></figure>\n<p>由于Django的管理方法中有个lastest()方法，就是得到最近一行记录。如果你的数据模型中有 DateField 或 DateTimeField 类型的字段，你可以通过这个选项来指定lastest()是按照哪个字段进行选取的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">•managed</span><br></pre></td></tr></table></figure>\n<p>由于Django会自动根据模型类生成映射的数据库表，如果你不希望Django这么做，可以把managed的值设置为False。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">•order_with_respect_to</span><br></pre></td></tr></table></figure>\n<p>这个选项一般用于多对多的关系中，它指向一个关联对象。就是说关联对象找到这个对象后它是经过排序的。指定这个属性后你会得到一个get_XXX_order()和set_XXX_order（）的方法,通过它们你可以设置或者回去排序的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">•ordering</span><br></pre></td></tr></table></figure>\n<p>这个字段是告诉Django模型对象返回的记录结果集是按照哪个字段排序的。比如下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ordering&#x3D;[&#39;order_date&#39;] # 按订单升序排列</span><br><span class=\"line\">ordering&#x3D;[&#39;-order_date&#39;] # 按订单降序排列，-表示降序</span><br><span class=\"line\">ordering&#x3D;[&#39;?order_date&#39;] # 随机排序，？表示随机</span><br><span class=\"line\">•permissions</span><br><span class=\"line\">permissions主要是为了在Django Admin管理模块下使用的，如果你设置了这个属性可以让指定的方法权限描述更清晰可读。</span><br><span class=\"line\">•proxy</span><br><span class=\"line\">这是为了实现代理模型使用的，这里先不讲随后的文章介绍。</span><br><span class=\"line\">•unique_together</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">unique_together这个选项用于：当你需要通过两个字段保持唯一性时使用。比如假设你希望，一个Person的FirstName和LastName两者的组合必须是唯一的，那么需要这样设置：</span><br><span class=\"line\">unique_together &#x3D; ((&quot;first_name&quot;, &quot;last_name&quot;),)</span><br><span class=\"line\">•verbose_name</span><br><span class=\"line\">verbose_name的意思很简单，就是给你的模型类起一个更可读的名字：</span><br><span class=\"line\">verbose_name &#x3D; &quot;pizza&quot;</span><br><span class=\"line\">•verbose_name_plural</span><br><span class=\"line\">这个选项是指定，模型的复数形式是什么，比如：</span><br><span class=\"line\">verbose_name_plural &#x3D; &quot;stories&quot;</span><br><span class=\"line\">如果不指定Django会自动在模型名称后加一个’s’</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.class Register(models.Model):</span><br><span class=\"line\">2.    id &#x3D; models.IntegerField(primary_key &#x3D; True, db_column&#x3D;&quot;ID&quot;)</span><br><span class=\"line\">3.    mid &#x3D; models.IntegerField(db_column &#x3D; &quot;MID&quot;)</span><br><span class=\"line\">4.    name &#x3D; models.CharField(max_length &#x3D; 10 , db_column &#x3D; &quot;NAME&quot;)</span><br><span class=\"line\">5.    nickName &#x3D; models.CharField(max_length &#x3D; 100 ,db_column &#x3D; &quot;NICK_NAME&quot;)</span><br><span class=\"line\">6.    slo &#x3D; models.CharField(max_length &#x3D; 50, db_column &#x3D; &quot;SLOGAN&quot;)</span><br><span class=\"line\">7.    status &#x3D; models.SmallIntegerField(db_column &#x3D; &quot;STATUS&quot;)</span><br><span class=\"line\">8.    cnt &#x3D; models.IntegerField(db_column &#x3D; &quot;CNT&quot;)</span><br><span class=\"line\">9.    createdDate &#x3D; models.DateTimeField(db_column &#x3D; &quot;CREATED_DATE&quot;)</span><br><span class=\"line\">10.</span><br><span class=\"line\">11.    class Meta:</span><br><span class=\"line\">12.        db_table &#x3D; &quot;A111208FACTIONVOTETOP10_REGISTER&quot;</span><br><span class=\"line\">13.        managed &#x3D; False</span><br></pre></td></tr></table></figure>\n\n\n<p>原文：<a href=\"https://www.cnblogs.com/xuchunlin/p/5920545.html\">django模型中的抽象类（abstract）</a></p>\n","categories":["django"],"tags":["抽象类","abstract"]},{"title":"在 Mac 下面安装 cryptography 依赖包，始终报错，出现 'openssl/opensslv.h' file not found 的错误。","url":"/2021/05/07/mac/%E5%9C%A8%20Mac%E4%B8%8B%E9%9D%A2%E5%AE%89%E8%A3%85%20cryptography%20%E4%BE%9D%E8%B5%96%E5%8C%85%E5%A7%8B%E7%BB%88%E6%8A%A5%E9%94%99/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>在 Mac 下面安装 cryptography 依赖包，始终报错，出现 ‘openssl/opensslv.h’ file not found 的错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ pip install cryptography</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">building &#39;_openssl&#39; extension</span><br><span class=\"line\">cc -fno-strict-aliasing -fno-common -dynamic -arch i386 -arch x86_64 -g -Os -pipe -fno-common -fno-strict-aliasing -fwrapv -DENABLE_DTRACE -DMACOSX -DNDEBUG -Wall -Wstrict-prototypes -Wshorten-64-to-32 -DNDEBUG -g -fwrapv -Os -Wall -Wstrict-prototypes -DENABLE_DTRACE -arch i386 -arch x86_64 -pipe -I&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;2.7&#x2F;include&#x2F;python2.7 -c build&#x2F;temp.macosx-10.12-intel-2.7&#x2F;_openssl.c -o build&#x2F;temp.macosx-10.12-intel-2.7&#x2F;build&#x2F;temp.macosx-10.12-intel-2.7&#x2F;_openssl.o</span><br><span class=\"line\">build&#x2F;temp.macosx-10.12-intel-2.7&#x2F;_openssl.c:434:10: fatal error: &#39;openssl&#x2F;opensslv.h&#39; file not found</span><br><span class=\"line\">#include &lt;openssl&#x2F;opensslv.h&gt;</span><br><span class=\"line\">         ^</span><br><span class=\"line\">1 error generated.</span><br><span class=\"line\">error: command &#39;cc&#39; failed with exit status 1</span><br></pre></td></tr></table></figure>\n<p>这是因为找不到 openssl 的头文件，可以使用 brew 命令进行安装:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ brew install openssl</span><br></pre></td></tr></table></figure>\n<p>如果安装完成以后还是会出现上面的错误的话，就是环境变量的问题了，需要重新指定 openssl 的路径安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ env LDFLAGS&#x3D;&quot;-L$(brew --prefix openssl)&#x2F;lib&quot; CFLAGS&#x3D;&quot;-I$(brew --prefix openssl)&#x2F;include&quot; pip install cryptography</span><br></pre></td></tr></table></figure>\n<p>这样就可以搞定了~~~</p>\n","categories":["mac"],"tags":["macOS","cryptography"]},{"title":"linux服务器搭建 shadowsocks","url":"/2021/05/07/proxy/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%20shadowsocks/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update    # 更新软件源列表</span><br><span class=\"line\">sudo apt-get -y install python-gevent python-pip  # 安装所需服务</span><br><span class=\"line\">sudo apt-get -y install python-m2crypto</span><br><span class=\"line\">sudo pip install shadowsocks   # 安装影梭</span><br></pre></td></tr></table></figure>\n\n<p>shadowsocks安装完毕后，可以查看使用ssserver命令进行查看。如下：<br>ssserver -h</p>\n<p>在 /etc/shadowsocks/ 下写入以 .json结尾的配置文件 如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class=\"line\">    &quot;server_port&quot;:443,  #普通用户目录下 采用大于1024的端口 root目录下可以使用443</span><br><span class=\"line\">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class=\"line\">    &quot;local_port&quot;:1080,</span><br><span class=\"line\">    &quot;password&quot;:&quot;你的密码&quot;,</span><br><span class=\"line\">    &quot;timeout&quot;:300,</span><br><span class=\"line\">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class=\"line\">    &quot;fast_open&quot;:false,</span><br><span class=\"line\">    &quot;workers&quot;: 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>常用命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 启动</span><br><span class=\"line\">ssserver -c &#x2F;etc&#x2F;shadowsocks&#x2F;ss.json -d start</span><br><span class=\"line\"># 停止</span><br><span class=\"line\">ssserver -c &#x2F;etc&#x2F;shadowsocks&#x2F;ss.json -d stop</span><br><span class=\"line\"># 重启</span><br><span class=\"line\">ssserver -c &#x2F;etc&#x2F;shadowsocks&#x2F;ss.json -d restart</span><br><span class=\"line\">-d  后台启动  及日志记录</span><br><span class=\"line\">ssserver -c &#x2F;etc&#x2F;shadowsocks&#x2F;config.json -d start  --log-file .&#x2F;ss.log --pid-file .&#x2F;ss.pid</span><br><span class=\"line\"></span><br><span class=\"line\">netstat -tunlp 查看服务是否启动</span><br><span class=\"line\"></span><br><span class=\"line\">vi &#x2F;etc&#x2F;rc.local</span><br><span class=\"line\">按i键进入编辑模式，然后在最后一行加入</span><br><span class=\"line\">ssserver -c &#x2F;etc&#x2F;shadowsocks&#x2F;config.json -d start  --log-file &#x2F;etc&#x2F;shadowsocks&#x2F;ss.log --pid-file &#x2F;etc&#x2F;shadowsocks&#x2F;ss.pid</span><br></pre></td></tr></table></figure>\n","categories":["proxy"],"tags":["代理"]},{"title":"Python3 利用string模块生成密码","url":"/2021/05/04/python/Python3%20%E5%88%A9%E7%94%A8string%E6%A8%A1%E5%9D%97%E7%94%9F%E6%88%90%E5%AF%86%E7%A0%81/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>string模块中定义了一些常用的属性，包含所有数字、字母、可打印的所有ascii码等</p>\n<p>实例</p>\n<ol>\n<li>ascii_letters 生成所有大小写字母（a-z A-Z）<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import string</span><br><span class=\"line\"></span><br><span class=\"line\">letters &#x3D; string.ascii_letters</span><br><span class=\"line\">print(letters)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br></pre></td></tr></table></figure></li>\n</ol>\n<span id=\"more\"></span>\n\n<ol start=\"2\">\n<li><p>ascii_lowercase 生成所有小写字母（a-z）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import string</span><br><span class=\"line\"></span><br><span class=\"line\">lowercase &#x3D; string.asscii_lowercase</span><br><span class=\"line\">print(lowercase)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; abcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure></li>\n<li><p>ascii_uppercase 生成所有大写字母（A-Z）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import string</span><br><span class=\"line\"></span><br><span class=\"line\">uppercase &#x3D; string.ascii_uppercase</span><br><span class=\"line\">print(uppercase)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br></pre></td></tr></table></figure></li>\n<li><p>digits 生成所有数字（0-9）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import string</span><br><span class=\"line\"></span><br><span class=\"line\">digits &#x3D; string.digits</span><br><span class=\"line\">print(digits)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; 0123456789</span><br></pre></td></tr></table></figure></li>\n<li><p>punctuation 生成所有标点符号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import string</span><br><span class=\"line\"></span><br><span class=\"line\">punctuation &#x3D; string.punctuation</span><br><span class=\"line\">print(punctuotion)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; !&quot;#$%&amp;&#39;()*+,-.&#x2F;:;&lt;&#x3D;&gt;?@[\\]^_&#96;&#123;|&#125;~</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>#密码生成器<br> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def main():</span><br><span class=\"line\">    &quot;&quot;&quot;密码生成器&quot;&quot;&quot;</span><br><span class=\"line\">    a &#x3D; string.ascii_letters + string.digits + string.punctuation</span><br><span class=\"line\">    key &#x3D; random.sample(a, 16)</span><br><span class=\"line\">    keys &#x3D; &quot;&quot;.join(key)</span><br><span class=\"line\">    print(keys)</span><br></pre></td></tr></table></figure></p>\n","categories":["python"],"tags":["密码","gen-secret"]},{"title":"Python中tuple+=赋值的四个问题","url":"/2021/05/04/python/Python%E4%B8%ADtuple+=%E8%B5%8B%E5%80%BC%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%97%AE%E9%A2%98/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>首先看第一个问题, 如下面的代码段:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t &#x3D; (1,2, [30,40])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t[2] +&#x3D; [50,60]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>会产生什么结果呢？ 给出了四个选项:<br>1. <code>t</code> 变成 <code>[1,2, [30,40,50,60]</code> <br>2. <code>TypeError is raised with the message &#39;tuple&#39; object does not support item assignment</code> <br>3. Neither 1 nor 2<br>4. Both 1 and 2</p>\n<p>按照之前的理解, <code>tuple</code>里面的元素是不能被修改的，因此会选<code>2</code>. 如果真是这样的话，这篇笔记就没必要了，Fluent Python中也就不会拿出一节来讲了。 正确答案是<code>4</code></p>\n<span id=\"more\"></span>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t &#x3D; (1,2,[30,40])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t[2] +&#x3D; [50,60]</span><br><span class=\"line\"></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\"></span><br><span class=\"line\">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">TypeError: &#39;tuple&#39; object does not support item assignment</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t</span><br><span class=\"line\"></span><br><span class=\"line\">(1, 2, [30, 40, 50, 60])</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>问题来了，为什么异常都出来了， <code>t</code>还是变了? 再看第二种情况，稍微变化一下,将<code>+=</code>变为<code>=</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; t &#x3D; (1,2, [30,40])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t[2] &#x3D; [50,60]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>结果就成酱紫了:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; t &#x3D; (1,2, [30,40])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t[2] &#x3D; [50,60]</span><br><span class=\"line\"></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\"></span><br><span class=\"line\">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">TypeError: &#39;tuple&#39; object does not support item assignment</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t</span><br><span class=\"line\"></span><br><span class=\"line\">(1, 2, [30, 40])</span><br></pre></td></tr></table></figure>\n\n<p>再看第三种情况,只把<code>+=</code>换为<code>extend</code>或者<code>append</code>,:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; t &#x3D; (1, 2, [30,40])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t[2].extend([50,60])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t</span><br><span class=\"line\"></span><br><span class=\"line\">(1, 2, [30, 40, 50, 60])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t[2].append(70)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t</span><br><span class=\"line\"></span><br><span class=\"line\">(1, 2, [30, 40, 50, 60, 70])</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>又正常了,没抛出异常?</p>\n<p>最后第四种情况, 用变量的形式:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; a &#x3D; [30,40]</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t &#x3D; (1, 2, a)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; a+&#x3D;[50,60]</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; a</span><br><span class=\"line\"></span><br><span class=\"line\">[30, 40, 50, 60]</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t</span><br><span class=\"line\"></span><br><span class=\"line\">(1, 2, [30, 40, 50, 60])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t[2] +&#x3D; [70,80]</span><br><span class=\"line\"></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\"></span><br><span class=\"line\">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">TypeError: &#39;tuple&#39; object does not support item assignment</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; t</span><br><span class=\"line\"></span><br><span class=\"line\">(1, 2, [30, 40, 50, 60, 70, 80])</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>又是一种情况, 下面就探究一下其中的原因.</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>首先需要重温<code>+=</code>这个运算符,如<code>a+=b</code>:</p>\n<ul>\n<li>  对于可变对象(mutable object)如<code>list</code>, <code>+=</code>操作的结果会直接在<code>a</code>对应的变量进行修改，而<code>a</code>对应的地址不变.</li>\n<li>  对于不可变对象(imutable object)如<code>tuple</code>, <code>+=</code>则是等价于<code>a = a+b</code> 会产生新的变量，然后绑定到<code>a</code>上而已.</li>\n</ul>\n<p>如下代码段, 可以看出来:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; a &#x3D; [1,2,3]</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; id(a)</span><br><span class=\"line\"></span><br><span class=\"line\">53430752</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; a+&#x3D;[4,5]</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; a</span><br><span class=\"line\"></span><br><span class=\"line\">[1, 2, 3, 4, 5]</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; id(a)</span><br><span class=\"line\"></span><br><span class=\"line\">53430752 # 地址没有变化</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; b &#x3D; (1,2,3)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; id(b)</span><br><span class=\"line\"></span><br><span class=\"line\">49134888</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; b +&#x3D; (4,5)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; b</span><br><span class=\"line\"></span><br><span class=\"line\">(1, 2, 3, 4, 5)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; id(b)</span><br><span class=\"line\"></span><br><span class=\"line\">48560912 # 地址变化了</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>此外还需要注意的是, python中的<code>tuple</code>作为不可变对象, 也就是我们平时说的元素不能改变, 实际上从报错信息<code>TypeError: &#39;tuple&#39; object does not support item assignment</code>来看, 更准确的说法是指其中的元素不支持赋值操作<code>=</code>(<strong>assignment</strong>).</p>\n<p>先看最简单的第二种情况, 它的结果是符合我们的预期, 因为<code>=</code>产生了<code>assign</code>的操作.(在<a href=\"http://shomy.top/2016/03/01/python-namespace-1/\">由一个例子到python的名字空间</a> 中指出了赋值操作<code>=</code>就是创建新的变量), 因此<code>s[2]=[50,60]</code>就会抛出异常.</p>\n<p>再看第三种情况,包含<code>extend/append</code>的, 结果tuple中的列表值发生了变化,但是没有异常抛出. 这个其实也相对容易理解. 因为我们知道<code>tuple</code>中存储的其实是元素所对应的地址(id), 因此如果没有赋值操作且tuple中的元素的<code>id</code>不变,即可,而<code>list.extend/append</code>只是修改了列表的元素,而列表本身id并没有变化,看看下面的例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; a&#x3D;(1,2,[30,40])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; id(a[2])</span><br><span class=\"line\"></span><br><span class=\"line\">140628739513736</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; a[2].extend([50,60])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; a</span><br><span class=\"line\"></span><br><span class=\"line\">(1, 2, [30, 40, 50, 60])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; id(a[2])</span><br><span class=\"line\"></span><br><span class=\"line\">140628739513736</span><br></pre></td></tr></table></figure>\n<p>目前解决了第二个和第三个问题, 先梳理一下, 其实就是两点:</p>\n<ul>\n<li>  tuple内部的元素不支持赋值操作</li>\n<li>  在第一条的基础上, 如果元素的<code>id</code>没有变化, 元素其实是可以改变的.</li>\n</ul>\n<p>现在再来看最初的第一个问题: <code>t[2] += [50,60]</code> 按照上面的结论, 不应该抛异常啊,因为在我们看来<code>+=</code> 对于可变对象<code>t[2]</code>来说, 属于<code>in-place</code>操作,也就是直接修改自身的内容, <code>id</code>并不变, 确认下id并没有变化:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; a&#x3D;(1,2,[30,40])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; id(a[2])</span><br><span class=\"line\"></span><br><span class=\"line\">140628739587392</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; a[2]+&#x3D;[50,60]</span><br><span class=\"line\"></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\"></span><br><span class=\"line\">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">TypeError: &#39;tuple&#39; object does not support item assignment</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; a</span><br><span class=\"line\"></span><br><span class=\"line\">(1, 2, [30, 40, 50, 60])</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; id(a[2]) # ID 并没有发生改变</span><br><span class=\"line\"></span><br><span class=\"line\">140628739587392</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>跟第三个问题仅仅从<code>t[2].extend</code>改成了<code>t[2]+=</code>, 就抛出异常了,所以问题应该是出在<code>+=</code>上了. 下面用<code>dis</code>模块看看它俩执行的步骤: 对下面的代码块执行<code>dis</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">t &#x3D; (1,2, [30,40])</span><br><span class=\"line\"></span><br><span class=\"line\">t[2] +&#x3D; [50,60]</span><br><span class=\"line\"></span><br><span class=\"line\">t[2].extend([70, 80])</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>执行<code>python -m dis test.py</code>,结果如下，下面只保留第2,3行代码的执行过程，以及关键步骤的注释如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">2          21 LOAD_NAME                0 (t)</span><br><span class=\"line\"></span><br><span class=\"line\">           24 LOAD_CONST               1 (2)</span><br><span class=\"line\"></span><br><span class=\"line\">           27 DUP_TOPX                 2</span><br><span class=\"line\"></span><br><span class=\"line\">           30 BINARY_SUBSCR</span><br><span class=\"line\"></span><br><span class=\"line\">           31 LOAD_CONST               4 (50)</span><br><span class=\"line\"></span><br><span class=\"line\">           34 LOAD_CONST               5 (60)</span><br><span class=\"line\"></span><br><span class=\"line\">           37 BUILD_LIST               2</span><br><span class=\"line\"></span><br><span class=\"line\">           40 INPLACE_ADD</span><br><span class=\"line\"></span><br><span class=\"line\">           41 ROT_THREE</span><br><span class=\"line\"></span><br><span class=\"line\">           42 STORE_SUBSCR</span><br><span class=\"line\"></span><br><span class=\"line\">3          43 LOAD_NAME                0 (t)</span><br><span class=\"line\"></span><br><span class=\"line\">           46 LOAD_CONST               1 (2)</span><br><span class=\"line\"></span><br><span class=\"line\">           49 BINARY_SUBSCR</span><br><span class=\"line\"></span><br><span class=\"line\">           50 LOAD_ATTR                1 (extend)</span><br><span class=\"line\"></span><br><span class=\"line\">           53 LOAD_CONST               6 (70)</span><br><span class=\"line\"></span><br><span class=\"line\">           56 LOAD_CONST               7 (80)</span><br><span class=\"line\"></span><br><span class=\"line\">           59 BUILD_LIST               2</span><br><span class=\"line\"></span><br><span class=\"line\">           62 CALL_FUNCTION            1</span><br><span class=\"line\"></span><br><span class=\"line\">           65 POP_TOP</span><br><span class=\"line\"></span><br><span class=\"line\">           66 LOAD_CONST               8 (None)</span><br><span class=\"line\"></span><br><span class=\"line\">           69 RETURN_VALUE</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>解释一下关键的语句:</p>\n<ul>\n<li>  <code>30 BINARY_SUBSCR</code>: 表示将<code>t[2]</code>的值放在TOS(Top of Stack)，这里是指<code>[30, 40]</code>这个列表</li>\n<li>  <code>40 INPLACE_ADD</code>: 表示<code>TOS += [50,60]</code> 执行这一步是可以成功的，修改了TOS的列表为<code>[30,40,50,60]</code></li>\n<li>  <code>42 STORE_SUBSCR</code>: 表示<code>s[2] = TOS</code> 问题就出在这里了，这里产生了一个<strong>赋值操作</strong>，因此会抛异常！但是上述对列表的修改已经完成, 这也就解释了开篇的第一个问题。</li>\n</ul>\n<p>再看<code>extend</code>的过程，前面都一样，只有这一行:</p>\n<ul>\n<li>  <code>62 CALL_FUNCTION</code>: 这个直接调用内置extend函数完成了对原列表的修改，其中并没有<code>assign</code>操作，因此可以正常执行。</li>\n</ul>\n<p>现在逐渐清晰了， 换句话说，<code>+=</code><strong>并不是原子操作</strong>，相当于下面的两步:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">t[2].extend([50,60])</span><br><span class=\"line\"></span><br><span class=\"line\">t[2] &#x3D; t[2]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>第一步可以正确执行，但是第二步有了<code>=</code>，肯定会抛异常的。 同样这也可以解释在使用<code>+=</code>的时候，为何<code>t[2]</code>的<code>id</code>明明没有变化，但是仍然抛出异常了。</p>\n<p>现在用一句话总结下:</p>\n<blockquote>\n<p>tuple中元素不支持<code>assign</code>操作，但是对于那些是可变对象的元素如列表，字典等，在没有<code>assign</code>操作的基础上，比如一些<code>in-place</code>操作，是可以修改内容的</p>\n</blockquote>\n<p>可以用第四个问题来简单验证一下，使用一个指向<code>[30,40]</code>的名称<code>a</code>来作为元素的值，然后对<code>a</code>做<code>in-place</code>的修改，其中并没有涉及到对tuple的<code>assign</code>操作，那肯定是正常执行的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这个问题其实以前也就遇到过，但是没想过具体的原理，后来翻书的时候又看到了， 于是花了点时间把这一个系列查了部分资料以及结合自己的理解都整理了出来, 算是饭后茶点吧, 不严谨的地方烦请指出.</p>\n<p>部分参考如下:</p>\n<ul>\n<li>  <a href=\"http://bugs.python.org/issue11562\">python bugs</a></li>\n<li>  <a href=\"https://docs.python.org/2/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works\">python faq</a></li>\n<li>  <a href=\"https://stackoverflow.com/questions/10397121/why-does-of-a-list-within-a-python-tuple-raise-typeerror-but-modify-the-list\">stackoverflow</a></li>\n<li>  Fluent Python</li>\n</ul>\n<p>本文链接: <a href=\"http://shomy.top/2017/08/17/python-tuple-assign/\">http://shomy.top/2017/08/17/python-tuple-assign/</a></p>\n","categories":["python"],"tags":["tuple"]},{"title":"Python中字典的键为什么要是不可变类型","url":"/2021/05/04/python/Python%E4%B8%AD%E5%AD%97%E5%85%B8%E7%9A%84%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>很多python初学者经常会有这样的疑问，为什么Python有tuple（元组）和list（列表）两种类型？为什么tuple可以作为字典的key，list不可以？要理解这个问题，首先要明白python的字典工作原理。</p>\n<span id=\"more\"></span>\n\n<p>Python的字典是如何工作的</p>\n<p>在Python中，字典也就是一个个的“映射”，将key映射到value：</p>\n<p>对一个特定的key可以得到一个value value = d[key]</p>\n<p>为了实现这个功能，Python必须能够做到，给出一个key，找到哪一个value与这个key对应。先来考虑一种比较简单的实现，将所有的key-value键值对存放到一个list中，每当需要的时候，就去遍历这个list，用key去和键值对的key匹配，如果相等，就拿到value。但是这种实现在数据量很大的时候就变得很低效。它的算法复杂度是O(n)，n是存放键值对的数量。</p>\n<p>为此，Python使用了hash（哈希）的方法来实现，要求每一个存放到字典中的对象都要实现hash函数，这个函数可以产生一个int值，叫做hash value（哈希值），通过这个int值，就可以快速确定对象在字典中的位置。</p>\n<p>这个查询的大致过程如下：</p>\n<p>def lookup(d, key): ‘’’字典的查询过程概括为下面3步: 1. 通过hash函数将key计算为哈希值. 2. 通过hash值确定一个位置，这个位置是一个存放着 可能存在冲突的元素的数组（很多地方叫做“桶”，bucket）， 每一个元素都是一个键值对，理想情况下，这个数组里只有1个元素. 3. 遍历这个数组，找到目标key，返回对应的value. ‘’’ h = hash(key)# step 1 cl = d.data[h]# step 2 for pairin cl:# step 3 if key == pair[0]: return pair[1] else: raise KeyError, “Key %s not found.” % key</p>\n<p>要使这个查找过程正常工作，hash函数必须满足条件： 如果两个key产生了不同的hash value，那么这两个key对象是不想等的。 即</p>\n<p>for alli1, i2, if hash(i1) != hash(i2), then i1 != i2</p>\n<p>否则的话，hash value不同，对象却相同，那么相同的对象产生不同的hash value，查找的时候就会进错桶（step 2），在错误的桶里永远也找不到你要找的value。</p>\n<p>另外，要让字典保持高查找效率，还要保证： 当两个key产生相同的hash value，那么他们是相等的。</p>\n<p>for alli1, i2, if hash(i1) == hash(i2), then i1 == i2</p>\n<p>这样做的目的是，尽量满足每个hash桶只有一个元素。为什么要这样呢？ 考虑下面这个hash函数。</p>\n<p>def hash(obj): return 1</p>\n<p>这个hash函数是满足上面我们谈的第一个条件的：如果两个key的hash value不同，那么两个key对象不相同。因为所有的对象产生的hash value都是1，所以不存在能产生不同hash value的key，也就不存在不满足的情况。但是这样做的坏处是，因为所有的hash value都相同，所以就把所有的对象分到了同一个地方。查找的时候，进行到第三步，遍历的效率就变成了O(n).</p>\n<p>Hash函数应该保证所有的元素平均的分配到每一个桶中，理想的情况是，每一个位置只有一个元素。</p>\n<p>字典Key要满足的要求</p>\n<p>经过上面的讨论，我们应该明白Python为什么对字典的key有这样的要求了：</p>\n<p>要作为字典的key，对象必须要支持hash函数（即__hash__），相等比较(__eq__或__cmp__），并且满足上面我们讨论过的条件。</p>\n<p>List为什么不能作为key</p>\n<p>至于这个问题，最直接的答案就是：list没有支持__hash__方法，那么为什么呢？</p>\n<p>对于list的hash函数，我们可能有下面两种实现的方式：</p>\n<p>第一种，基于id。这满足条件，“如果hash值不同，那么他们的id当然不同”。但考虑到list一般是作为容器，基于id来hash可能会导致下面两种情况：</p>\n<p>用相同的list作为key去字典中找某个元素可能会得到不同的结果，因为是基于id hash的，所以即使他们的内容相同，字典依然将他们作为不同的元素对待。 创建一个一模一样的list用字典查找永远会得到一个KeyError。</p>\n<p>第二种，基于内容。tuple就是这样做的，但是要注意一点，list是可以修改的。当list修改之后，你就永远别想再从字典中拿回来了。见下面的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; l &#x3D; [1, 2]</span><br><span class=\"line\">&gt;&gt;&gt; d &#x3D; &#123;&#125;</span><br><span class=\"line\">&gt;&gt;&gt; d[l] &#x3D; 42</span><br><span class=\"line\">&gt;&gt;&gt; l.append(3)</span><br><span class=\"line\">&gt;&gt;&gt; d[l]</span><br><span class=\"line\"># 原来的hash值是基于[1, 2]hash的，</span><br><span class=\"line\"># 现在是基于[1, 2, 3]，所以找不到 Traceback (mostrecentcalllast): File &quot;&quot;, line 1, in ? KeyError: [1, 2, 3]</span><br><span class=\"line\">&gt;&gt;&gt; d[[1, 2]] # 基于hash [1, 2]</span><br><span class=\"line\"># 但是遍历的时候找不到key相等的键值对</span><br><span class=\"line\">#（因为字典里的key变成了[1, 2, 3] Traceback (mostrecentcalllast): File &quot;&quot;, line 1, in ? KeyError: [1, 2]</span><br></pre></td></tr></table></figure>\n<p>鉴于两种实现的方式都存在一定的副作用，所以Python规定：</p>\n<p>内置的list不能作为字典的key.</p>\n<p>但tuple是不可变，所以tuple可以作为字典的key。</p>\n<p>自定义的类型作为字典的Key</p>\n<p>用户自定义的类型就可以作为key了，默认的 hash(object) 是 id(object) , 默认的 cmp(object1,object2) 是 cmp(id(object1),id(object2))， 同样是可以修改的对象，为什么这里就没有上面说的问题呢？</p>\n<p>一般来说，在映射中比较常见的需求是用一个object替换掉原来的，所以id比内容更重要，就可以基于id来hash 如果内容重要的话，自定义的类型可以通过覆盖__hash__函数和__cmp__函数或__eq__函数来实现</p>\n<p>值得注意的是：将对象和一个value关联起来，更好的做法是将value设置为对象的一个属性。</p>\n","categories":["python"],"tags":["不可变类型","字典"]},{"title":"paramiko 远程执行命令","url":"/2021/05/04/python/paramiko%20%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 id=\"Python学习总结-06-paramiko-远程执行命令\"><a href=\"#Python学习总结-06-paramiko-远程执行命令\" class=\"headerlink\" title=\"Python学习总结 06 paramiko 远程执行命令\"></a><a href=\"https://www.cnblogs.com/wangshuo1/p/6265360.html\">Python学习总结 06 paramiko 远程执行命令</a></h1><p>  有时会需要在远程的机器上执行一个命令，并获得其返回结果。对于这种情况，python 可以很容易的实现。</p>\n<h1 id=\"1-工具\"><a href=\"#1-工具\" class=\"headerlink\" title=\"1 工具\"></a>1 工具</h1><p>Python paramiko</p>\n<ol>\n<li>Paramiko模块安装</li>\n</ol>\n<p>　　在Linux的Terminal中，直接输入pip install paramiko 命令安装。</p>\n<p>2）确定paramiko安装成功</p>\n<p>　　在python命令行输入import paramiko，确认是否安装成功，没报错就没问题。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"2-步骤\"><a href=\"#2-步骤\" class=\"headerlink\" title=\"2 步骤\"></a>2 步骤</h1><p>1 导入 paramiko 模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class=\"line\">import paramiko</span><br></pre></td></tr></table></figure>\n\n<p>2 创建 ssh 连接函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def ssh_connect( _host, _username, _password ):</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        _ssh_fd &#x3D; paramiko.SSHClient()</span><br><span class=\"line\">        _ssh_fd.set_missing_host_key_policy( paramiko.AutoAddPolicy() )</span><br><span class=\"line\">        _ssh_fd.connect( _host, username &#x3D; _username, password &#x3D; _password )</span><br><span class=\"line\">    except Exception, e:</span><br><span class=\"line\">        print( &#39;ssh %s@%s: %s&#39; % (_username, _host, e) )</span><br><span class=\"line\">        exit()</span><br><span class=\"line\">    return _ssh_fd</span><br></pre></td></tr></table></figure>\n\n<p>3 创建命令执行函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def ssh_exec_cmd( _ssh_fd, _cmd ):</span><br><span class=\"line\">    return _ssh_fd.exec_command( _cmd )</span><br></pre></td></tr></table></figure>\n<p>4 创建关闭 ssh 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def ssh_close( _ssh_fd ):</span><br><span class=\"line\">    _ssh_fd.close()</span><br></pre></td></tr></table></figure>\n\n<p>5 使用示例</p>\n<figure class=\"highlight plain\"><figcaption><span>main():</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">    hostname &#x3D; &#39;192.168.55.243&#39;</span><br><span class=\"line\">    port &#x3D; 22</span><br><span class=\"line\">    username &#x3D; &#39;root&#39;</span><br><span class=\"line\">    password &#x3D; &#39;P@ssw0rd&#39;</span><br><span class=\"line\">    cmd &#x3D; &quot;ps -ef|grep java&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    sshd &#x3D; ssh_connect( hostname , username , password )</span><br><span class=\"line\">    stdin, stdout, stderr &#x3D; ssh_exec_cmd( sshd, cmd )</span><br><span class=\"line\">    err_list &#x3D; stderr.readlines()</span><br><span class=\"line\"></span><br><span class=\"line\">    if len( err_list ) &gt; 0:</span><br><span class=\"line\">        print &#39;ERROR:&#39; + err_list[0]</span><br><span class=\"line\">        exit()</span><br><span class=\"line\"></span><br><span class=\"line\">    for item in stdout.readlines():</span><br><span class=\"line\">        print item,</span><br><span class=\"line\">    ssh_close( sshd )</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n\n<p>　　如果执行脚本成功，会成功返回以下结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">root      2540  2536  2 14:13 pts&#x2F;4    00:01:21 java -Ddefault.client.encoding&#x3D;UTF-8 -Dfile.encoding&#x3D;UTF-8 -Duser.language&#x3D;Zh -Duser.region&#x3D;CN -Duser.timezone&#x3D;GMT+08 cn.com.ctsi.csdp.resource.App</span><br><span class=\"line\">root      3442  3387  0  2016 ?        01:09:00 java -Ddefault.client.encoding&#x3D;UTF-8 -Dfile.encoding&#x3D;UTF-8 -Duser.language&#x3D;Zh -Duser.region&#x3D;CN -Duser.timezone&#x3D;GMT+08 cn.com.ctsi.csdp.product.App</span><br><span class=\"line\">root      3451  3390  0  2016 ?        01:04:54 java -Ddefault.client.encoding&#x3D;UTF-8 -Dfile.encoding&#x3D;UTF-8 -Duser.language&#x3D;Zh -Duser.region&#x3D;CN -Duser.timezone&#x3D;GMT+08 cn.com.ctsi.csdp.report.App</span><br><span class=\"line\">root      3452  3388  0  2016 ?        00:51:00 java -Ddefault.client.encoding&#x3D;UTF-8 -Dfile.encoding&#x3D;UTF-8 -Duser.language&#x3D;Zh -Duser.region&#x3D;CN -Duser.timezone&#x3D;GMT+08 cn.com.ctsi.csdp.workflow.launcher.App</span><br><span class=\"line\">root      3892  3886  0  2016 ?        00:29:59 java -Ddefault.client.encoding&#x3D;UTF-8 -Dfile.encoding&#x3D;UTF-8 -Duser.language&#x3D;Zh -Duser.region&#x3D;CN -Duser.timezone&#x3D;GMT+08 cn.com.ctsi.csdp.charge.App</span><br><span class=\"line\">root      4509  4507  0 15:09 ?        00:00:00 bash -c ps -ef|grep java</span><br><span class=\"line\">root      4519  4509  0 15:09 ?        00:00:00 grep java</span><br><span class=\"line\">root     12861 12857  0 Jan06 ?        00:09:06 java -Ddefault.client.encoding&#x3D;UTF-8 -Dfile.encoding&#x3D;UTF-8 -Duser.language&#x3D;Zh -Duser.region&#x3D;CN -Duser.timezone&#x3D;GMT+08 cn.com.ctsi.csdp.workorder.App</span><br><span class=\"line\">root     16484 16480  0  2016 ?        00:45:27 java -Ddefault.client.encoding&#x3D;UTF-8 -Dfile.encoding&#x3D;UTF-8 -Duser.language&#x3D;Zh -Duser.region&#x3D;CN -Duser.timezone&#x3D;GMT+08 cn.com.ctsi.csdp.billing.App</span><br><span class=\"line\">root     18699 18694  0 Jan06 ?        00:09:30 java -Ddefault.client.encoding&#x3D;UTF-8 -Dfile.encoding&#x3D;UTF-8 -Duser.language&#x3D;Zh -Duser.region&#x3D;CN -Duser.timezone&#x3D;GMT+08 cn.com.ctsi.csdp.order.App</span><br><span class=\"line\">root     21902 21898  0 Jan05 ?        00:18:46 java -Ddefault.client.encoding&#x3D;UTF-8 -Dfile.encoding&#x3D;UTF-8 -Duser.language&#x3D;Zh -Duser.region&#x3D;CN -Duser.timezone&#x3D;GMT+08 cn.com.ctsi.csdp.user.launcher.App</span><br></pre></td></tr></table></figure>\n\n<p> 　　在实际的开发中，每次更新模块的jar包时，都需要使用 ps -ef | grep java, 查看模块的进程号，然后使用使用命令 kill -9 进程号，处理掉进程，然后重新启动 模块。</p>\n<p>下面尝试使用python脚本来代替手工输入代码。</p>\n<h1 id=\"3-实例\"><a href=\"#3-实例\" class=\"headerlink\" title=\"3 实例\"></a>3 实例</h1><p>1） 启动模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\"></span><br><span class=\"line\">import paramiko</span><br><span class=\"line\">ssh &#x3D; paramiko.SSHClient()</span><br><span class=\"line\">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class=\"line\">ssh.connect(&#39;192.168.55.243&#39;, username &#x3D; &#39;root&#39;, password &#x3D; &#39;P@ssw0rd&#39;, timeout &#x3D; 5)</span><br><span class=\"line\">cmd &#x3D; &#39;nohup &#x2F;csdp&#x2F;charge_launcher-1.0-release&#x2F;bin&#x2F;run.sh &gt; &#x2F;csdp&#x2F;charge_launcher-1.0-release&#x2F;bin&#x2F;nohup.out 2&gt;&amp;1 &amp; \\r\\n&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">password&#x3D; &#39;P@ssw0rd&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">stdin, stdout, stderr &#x3D; ssh.exec_command( cmd )</span><br><span class=\"line\">##stdin, stdout, stderr &#x3D; ssh.exec_command(&#39;sudo -S %s\\n&#39; % cmd )</span><br><span class=\"line\">##stdin.write(&#39;%s\\r\\n&#39; % password)</span><br><span class=\"line\">##stdin.flush()</span><br><span class=\"line\">print &quot;------------------------&quot;</span><br><span class=\"line\">##print stdout.readlines()</span><br><span class=\"line\">##print stderr.read()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print &quot;------------------------&quot;</span><br><span class=\"line\">cmd &#x3D; &#39;pwd&#39;</span><br><span class=\"line\">stdin, stdout, stderr &#x3D; ssh.exec_command(cmd )</span><br><span class=\"line\">print stdout.readlines()</span><br><span class=\"line\"></span><br><span class=\"line\">ssh.close()</span><br></pre></td></tr></table></figure>\n<p>2） 远程上传文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\">import paramiko</span><br><span class=\"line\"></span><br><span class=\"line\">serverIp &#x3D; &#39;192.168.55.243&#39;</span><br><span class=\"line\">serverUser &#x3D; &#39;root&#39;</span><br><span class=\"line\">serverPwd &#x3D; &#39;P@ssw0rd&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">localFile &#x3D; &#39;user-1.0-release.jar&#39;</span><br><span class=\"line\">localpath &#x3D; r&#39;D:\\workspace\\csdp201512041\\csdp-ningxia\\csdp_user\\user\\target&#39; + os.sep + localFile</span><br><span class=\"line\"></span><br><span class=\"line\">remotepath &#x3D; &#39;&#x2F;csdp&#x2F;user_launcher-1.0-dev&#x2F;lib&#x2F;&#39; + localFile</span><br><span class=\"line\"></span><br><span class=\"line\">def ftpModuleFile():</span><br><span class=\"line\">    t &#x3D; paramiko.Transport(( serverIp ,22))</span><br><span class=\"line\">    t.connect(username &#x3D; serverUser , password &#x3D; serverPwd)</span><br><span class=\"line\">    sftp &#x3D; paramiko.SFTPClient.from_transport(t)</span><br><span class=\"line\">   # remotepath&#x3D;&#39;&#x2F;csdp&#x2F;user_launcher-1.0-dev&#x2F;user-1.0-release.jar&#39;</span><br><span class=\"line\">   # localpath&#x3D; r&#39;D:\\workspace\\csdp201512041\\csdp-ningxia\\csdp_user\\user\\target\\user-1.0-release.jar&#39;</span><br><span class=\"line\">    sftp.put(localpath,remotepath)</span><br><span class=\"line\">    t.close()</span><br><span class=\"line\">    print(&quot;：） 成功上传%s文件。&quot; % remotepath)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\">   ftpModuleFile()</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>执行远程linux命令</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\">import paramiko</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class=\"line\">    hostname &#x3D; &#39;192.168.55.243&#39;</span><br><span class=\"line\">    port &#x3D; 22</span><br><span class=\"line\">    username &#x3D; &#39;root&#39;</span><br><span class=\"line\">    password &#x3D; &#39;P@ssw0rd&#39;</span><br><span class=\"line\">    cmd &#x3D; &quot;ps -ef|grep java&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    ssh &#x3D; paramiko.SSHClient()</span><br><span class=\"line\">    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class=\"line\">    #ssh.connect( hostname ,22, username , password )</span><br><span class=\"line\">    ssh.connect(hostname,username&#x3D;username,password&#x3D;password,allow_agent&#x3D;False,look_for_keys&#x3D;False)</span><br><span class=\"line\">    stdin, stdout, stderr &#x3D; ssh.exec_command(cmd )</span><br><span class=\"line\">    list &#x3D; stdout.readlines()</span><br><span class=\"line\">    print( list )</span><br><span class=\"line\"></span><br><span class=\"line\">    ssh.close()</span><br></pre></td></tr></table></figure>\n","categories":["python"],"tags":["paramiko"]},{"title":"python 列表加法\"+\"和\"extend\"的区别","url":"/2021/05/04/python/python%20%E5%88%97%E8%A1%A8%E5%8A%A0%E6%B3%95%22+%22%E5%92%8C%22extend%22%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点:\"></a>相同点:</h3><ul>\n<li> “+”和”extend”都能将两个列表成员拼接到到一起</li>\n</ul>\n<h3 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点:\"></a>不同点:</h3><ul>\n<li><p> + : 生成的是一个新列表(id改变)</p>\n</li>\n<li><p>extend : 是将一个列表的成员一个个取出添加到原列表中 , 改变的是原列表的值 , id不变</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<p><img src=\"https://user-images.githubusercontent.com/28568478/117003180-21ed8780-ad17-11eb-97fc-fedcf041db5d.png\" alt=\"image\"></p>\n","categories":["python"],"tags":["list"]},{"title":"python 生成器和迭代器","url":"/2021/05/04/python/python%20%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>本节主要记录一下列表生成式，生成器和迭代器的知识点</p>\n<h3 id=\"列表生成器\"><a href=\"#列表生成器\" class=\"headerlink\" title=\"列表生成器\"></a><strong>列表生成器</strong></h3><p><strong>首先举个例子</strong></p>\n<p>现在有个需求，看列表 [0，1，2，3，4，5，6，7，8，9]，要求你把列表里面的每个值加1，你怎么实现呢？</p>\n<p>方法一（简单）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">info &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">b &#x3D; []</span><br><span class=\"line\"># for index,i in enumerate(info):</span><br><span class=\"line\">#     print(i+1)</span><br><span class=\"line\">#     b.append(i+1)</span><br><span class=\"line\"># print(b)</span><br><span class=\"line\">for index,i in enumerate(info):</span><br><span class=\"line\">    info[index] +&#x3D;1</span><br><span class=\"line\">print(info)</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n\n<p>方法二（一般）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">info &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">a &#x3D; map(lambda x:x+1,info)</span><br><span class=\"line\">print(a)</span><br><span class=\"line\">for i in a:</span><br><span class=\"line\">    print(i)</span><br></pre></td></tr></table></figure>\n\n<p>方法三（高级）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">info &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">a &#x3D; [i+1 for i in range(10)]</span><br><span class=\"line\">print(a)</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><h4 id=\"什么是生成器？\"><a href=\"#什么是生成器？\" class=\"headerlink\" title=\"什么是生成器？\"></a>什么是生成器？</h4><p>　　通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>\n<p>　　所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，<strong>在Python中，这种一边循环一边计算的机制，称为生成器：generator</strong></p>\n<p>　　生成器是一个特殊的程序，可以被用作控制循环的迭代行为，<strong>python中生成器是迭代器的一种</strong>，使用yield返回值函数，每次调用yield会暂停，而可以使用next()函数和send()函数恢复生成器。</p>\n<p>　　生成器类似于返回值为数组的一个函数，这个函数可以接受参数，可以被调用，但是，不同于一般的函数会一次性返回包括了所有数值的数组，生成器一次只能产生一个值，这样消耗的内存数量将大大减小，而且允许调用函数可以很快的处理前几个返回值，因此生成器看起来像是一个函数，但是表现得却像是迭代器</p>\n<h4 id=\"python中的生成器\"><a href=\"#python中的生成器\" class=\"headerlink\" title=\"python中的生成器\"></a>python中的生成器</h4><p>　　要创建一个generator，有很多种方法，第一种方法很简单，<strong>只有把一个列表生成式的[]中括号改为（）小括号，就创建一个generator</strong></p>\n<p>举例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#列表生成式</span><br><span class=\"line\">lis &#x3D; [x*x for x in range(10)]</span><br><span class=\"line\">print(lis)</span><br><span class=\"line\">#生成器</span><br><span class=\"line\">generator_ex &#x3D; (x*x for x in range(10))</span><br><span class=\"line\">print(generator_ex)</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class=\"line\">&lt;generator object &lt;genexpr&gt; at 0x000002A4CBF9EBA0&gt;</span><br></pre></td></tr></table></figure>\n<p>　　那么创建list和generator_ex，的区别是什么呢？从表面看就是[  ]和（）,但是结果却不一样，一个打印出来是列表（因为是列表生成式），而第二个打印出来却是&lt;generator object <genexpr> at 0x000002A4CBF9EBA0&gt;，那么如何打印出来generator_ex的每一个元素呢？</p>\n<p>　　如果要一个个打印出来，可以通过next（）函数获得generator的下一个返回值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#生成器</span><br><span class=\"line\">generator_ex &#x3D; (x*x for x in range(10))</span><br><span class=\"line\">print(next(generator_ex))</span><br><span class=\"line\">print(next(generator_ex))</span><br><span class=\"line\">print(next(generator_ex))</span><br><span class=\"line\">print(next(generator_ex))</span><br><span class=\"line\">print(next(generator_ex))</span><br><span class=\"line\">print(next(generator_ex))</span><br><span class=\"line\">print(next(generator_ex))</span><br><span class=\"line\">print(next(generator_ex))</span><br><span class=\"line\">print(next(generator_ex))</span><br><span class=\"line\">print(next(generator_ex))</span><br><span class=\"line\">print(next(generator_ex))</span><br><span class=\"line\">结果：</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">4</span><br><span class=\"line\">9</span><br><span class=\"line\">16</span><br><span class=\"line\">25</span><br><span class=\"line\">36</span><br><span class=\"line\">49</span><br><span class=\"line\">64</span><br><span class=\"line\">81</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\"></span><br><span class=\"line\">  File &quot;列表生成式.py&quot;, line 42, in &lt;module&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    print(next(generator_ex))</span><br><span class=\"line\"></span><br><span class=\"line\">StopIteration</span><br></pre></td></tr></table></figure>\n<p>　　大家可以看到，generator保存的是算法，每次调用next(generaotr_ex)就计算出他的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出StopIteration的错误，而且上面这样不断调用是一个不好的习惯，正确的方法是使用for循环，因为generator也是可迭代对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#生成器</span><br><span class=\"line\">generator_ex &#x3D; (x*x for x in range(10))</span><br><span class=\"line\">for i in generator_ex:</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">4</span><br><span class=\"line\">9</span><br><span class=\"line\">16</span><br><span class=\"line\">25</span><br><span class=\"line\">36</span><br><span class=\"line\">49</span><br><span class=\"line\">64</span><br><span class=\"line\">81</span><br></pre></td></tr></table></figure>\n<p>　　所以我们创建一个generator后，基本上永远不会调用next()，而是通过for循环来迭代，并且不需要关心StopIteration的错误，generator非常强大，如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。</p>\n<p>比如著名的斐波那契数列，除第一个和第二个数外，任何一个数都可以由前两个相加得到：</p>\n<p>1，1，2，3，5，8，12，21，34…..</p>\n<p>斐波那契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#fibonacci数列</span><br><span class=\"line\">def fib(max):</span><br><span class=\"line\">    n,a,b &#x3D;0,0,1</span><br><span class=\"line\">    while n &lt; max:</span><br><span class=\"line\">        a,b &#x3D;b,a+b</span><br><span class=\"line\">        n &#x3D; n+1</span><br><span class=\"line\">        print(a)</span><br><span class=\"line\">    return &#39;done&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">a &#x3D; fib(10)</span><br><span class=\"line\">print(fib(10))</span><br></pre></td></tr></table></figure>\n\n<p>　　a,b = b ,a+b  其实相当于 t =a+b ,a =b ,b =t  ，所以不必写显示写出临时变量t，就可以输出斐波那契数列的前N个数字。上面输出的结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">5</span><br><span class=\"line\">8</span><br><span class=\"line\">13</span><br><span class=\"line\">21</span><br><span class=\"line\">34</span><br><span class=\"line\">55</span><br><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">5</span><br><span class=\"line\">8</span><br><span class=\"line\">13</span><br><span class=\"line\">21</span><br><span class=\"line\">34</span><br><span class=\"line\">55</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>　　仔细观察，可以看出，<code>fib</code>函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。</p>\n<p>　　也就是说上面的函数也可以用generator来实现，上面我们发现，print(b)每次函数运行都要打印，占内存，所以为了不占内存，我们也可以使用生成器，这里叫yield。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def fib(max):</span><br><span class=\"line\">    n,a,b &#x3D;0,0,1</span><br><span class=\"line\">    while n &lt; max:</span><br><span class=\"line\">        yield b</span><br><span class=\"line\">        a,b &#x3D;b,a+b</span><br><span class=\"line\">        n &#x3D; n+1</span><br><span class=\"line\">    return &#39;done&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">a &#x3D; fib(10)</span><br><span class=\"line\">print(fib(10))</span><br></pre></td></tr></table></figure>\n<p>　　但是返回的不再是一个值，而是一个生成器，和上面的例子一样，大家可以看一下结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;generator object fib at 0x000001C03AC34FC0&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>　　那么这样就不占内存了，这里说一下generator和函数的执行流程，函数是顺序执行的，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次被next（）调用时候从上次的返回yield语句处急需执行，也就是用多少，取多少，不占内存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def fib(max):</span><br><span class=\"line\">    n,a,b &#x3D;0,0,1</span><br><span class=\"line\">    while n &lt; max:</span><br><span class=\"line\">        yield b</span><br><span class=\"line\">        a,b &#x3D;b,a+b</span><br><span class=\"line\">        n &#x3D; n+1</span><br><span class=\"line\">    return &#39;done&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">a &#x3D; fib(10)</span><br><span class=\"line\">print(fib(10))</span><br><span class=\"line\">print(a.__next__())</span><br><span class=\"line\">print(a.__next__())</span><br><span class=\"line\">print(a.__next__())</span><br><span class=\"line\">print(&quot;可以顺便干其他事情&quot;)</span><br><span class=\"line\">print(a.__next__())</span><br><span class=\"line\">print(a.__next__())</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">&lt;generator object fib at 0x0000023A21A34FC0&gt;</span><br><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">可以顺便干其他事情</span><br><span class=\"line\">3</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n<p>　　在上面fib的例子，我们在循环过程中不断调用<code>yield</code>，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。同样的，把函数改成generator后，我们基本上从来不会用<code>next()</code>来获取下一个返回值，而是直接使用<code>for</code>循环来迭代：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def fib(max):</span><br><span class=\"line\">    n,a,b &#x3D;0,0,1</span><br><span class=\"line\">    while n &lt; max:</span><br><span class=\"line\">        yield b</span><br><span class=\"line\">        a,b &#x3D;b,a+b</span><br><span class=\"line\">        n &#x3D; n+1</span><br><span class=\"line\">    return &#39;done&#39;</span><br><span class=\"line\">for i in fib(6):</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">5</span><br><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n<p>　　但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果拿不到返回值，那么就会报错，所以为了不让报错，就要进行异常处理，拿到返回值，如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def fib(max):</span><br><span class=\"line\">    n,a,b &#x3D;0,0,1</span><br><span class=\"line\">    while n &lt; max:</span><br><span class=\"line\">        yield b</span><br><span class=\"line\">        a,b &#x3D;b,a+b</span><br><span class=\"line\">        n &#x3D; n+1</span><br><span class=\"line\">    return &#39;done&#39;</span><br><span class=\"line\">g &#x3D; fib(6)</span><br><span class=\"line\">while True:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        x &#x3D; next(g)</span><br><span class=\"line\">        print(&#39;generator: &#39;,x)</span><br><span class=\"line\">    except StopIteration as e:</span><br><span class=\"line\">        print(&quot;生成器返回值：&quot;,e.value)</span><br><span class=\"line\">        break</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">generator:  1</span><br><span class=\"line\">generator:  1</span><br><span class=\"line\">generator:  2</span><br><span class=\"line\">generator:  3</span><br><span class=\"line\">generator:  5</span><br><span class=\"line\">generator:  8</span><br><span class=\"line\">生成器返回值： done</span><br></pre></td></tr></table></figure>\n<p><strong>还可以通过yield实现在单线程的情况下实现并发运算的效果</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import time</span><br><span class=\"line\">def consumer(name):</span><br><span class=\"line\">    print(&quot;%s 准备学习啦!&quot; %name)</span><br><span class=\"line\">    while True:</span><br><span class=\"line\">       lesson &#x3D; yield</span><br><span class=\"line\"></span><br><span class=\"line\">       print(&quot;开始[%s]了,[%s]老师来讲课了!&quot; %(lesson,name))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def producer(name):</span><br><span class=\"line\">    c &#x3D; consumer(&#39;A&#39;)</span><br><span class=\"line\">    c2 &#x3D; consumer(&#39;B&#39;)</span><br><span class=\"line\">    c.__next__()</span><br><span class=\"line\">    c2.__next__()</span><br><span class=\"line\">    print(&quot;同学们开始上课 了!&quot;)</span><br><span class=\"line\">    for i in range(10):</span><br><span class=\"line\">        time.sleep(1)</span><br><span class=\"line\">        print(&quot;到了两个同学!&quot;)</span><br><span class=\"line\">        c.send(i)</span><br><span class=\"line\">        c2.send(i)</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">A 准备学习啦!</span><br><span class=\"line\">B 准备学习啦!</span><br><span class=\"line\">同学们开始上课 了!</span><br><span class=\"line\">到了两个同学!</span><br><span class=\"line\">开始[0]了,[A]老师来讲课了!</span><br><span class=\"line\">开始[0]了,[B]老师来讲课了!</span><br><span class=\"line\">到了两个同学!</span><br><span class=\"line\">开始[1]了,[A]老师来讲课了!</span><br><span class=\"line\">开始[1]了,[B]老师来讲课了!</span><br><span class=\"line\">到了两个同学!</span><br><span class=\"line\">开始[2]了,[A]老师来讲课了!</span><br><span class=\"line\">开始[2]了,[B]老师来讲课了!</span><br><span class=\"line\">到了两个同学!</span><br><span class=\"line\">开始[3]了,[A]老师来讲课了!</span><br><span class=\"line\">开始[3]了,[B]老师来讲课了!</span><br><span class=\"line\">到了两个同学!</span><br><span class=\"line\">开始[4]了,[A]老师来讲课了!</span><br><span class=\"line\">开始[4]了,[B]老师来讲课了!</span><br><span class=\"line\">到了两个同学!</span><br><span class=\"line\">开始[5]了,[A]老师来讲课了!</span><br><span class=\"line\">开始[5]了,[B]老师来讲课了!</span><br><span class=\"line\">到了两个同学!</span><br><span class=\"line\">开始[6]了,[A]老师来讲课了!</span><br><span class=\"line\">开始[6]了,[B]老师来讲课了!</span><br><span class=\"line\">到了两个同学!</span><br></pre></td></tr></table></figure>\n<p>　　由上面的例子我么可以发现，python提供了两种基本的方式</p>\n<p><strong>生成器函数：也是用def定义的，利用关键字yield一次性返回一个结果，阻塞，重新开始</strong></p>\n<p><strong>生成器表达式：返回一个对象，这个对象只有在需要的时候才产生结果</strong></p>\n<h4 id=\"——生成器函数\"><a href=\"#——生成器函数\" class=\"headerlink\" title=\"——生成器函数\"></a>——生成器函数</h4><p>为什么叫生成器函数？因为它随着时间的推移生成了一个数值队列。一般的函数在执行完毕之后会返回一个值然后退出，但是生成器函数会自动挂起，然后重新拾起急需执行，他会利用yield关键字关起函数，给调用者返回一个值，同时保留了当前的足够多的状态，可以使函数继续执行，生成器和迭代协议是密切相关的，<strong>迭代器都有一个__next__()__成员方法，</strong>这个方法要么返回迭代的下一项，要买引起异常结束迭代。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 函数有了yield之后，函数名+（）就变成了生成器</span><br><span class=\"line\"># return在生成器中代表生成器的中止，直接报错</span><br><span class=\"line\"># next的作用是唤醒并继续执行</span><br><span class=\"line\"># send的作用是唤醒并继续执行，发送一个信息到生成器内部</span><br><span class=\"line\">&#39;&#39;&#39;生成器&#39;&#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">def create_counter(n):</span><br><span class=\"line\">    print(&quot;create_counter&quot;)</span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        yield n</span><br><span class=\"line\">        print(&quot;increment n&quot;)</span><br><span class=\"line\">        n +&#x3D;1</span><br><span class=\"line\"></span><br><span class=\"line\">gen &#x3D; create_counter(2)</span><br><span class=\"line\">print(gen)</span><br><span class=\"line\">print(next(gen))</span><br><span class=\"line\">print(next(gen))</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">&lt;generator object create_counter at 0x0000023A1694A938&gt;</span><br><span class=\"line\">create_counter</span><br><span class=\"line\">2</span><br><span class=\"line\">increment n</span><br><span class=\"line\">3</span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"——生成器表达式\"><a href=\"#——生成器表达式\" class=\"headerlink\" title=\"——生成器表达式\"></a>——生成器表达式</h4><p>生成器表达式来源于迭代和列表解析的组合，生成器和列表解析类似，但是它使用尖括号而不是方括号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; # 列表解析生成列表</span><br><span class=\"line\">&gt;&gt;&gt; [ x ** 3 for x in range(5)]</span><br><span class=\"line\">[0, 1, 8, 27, 64]</span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\">&gt;&gt;&gt; # 生成器表达式</span><br><span class=\"line\">&gt;&gt;&gt; (x ** 3 for x in range(5))</span><br><span class=\"line\">&lt;generator object &lt;genexpr&gt; at 0x000000000315F678&gt;</span><br><span class=\"line\">&gt;&gt;&gt; # 两者之间转换</span><br><span class=\"line\">&gt;&gt;&gt; list(x ** 3 for x in range(5))</span><br><span class=\"line\">[0, 1, 8, 27, 64]</span><br></pre></td></tr></table></figure>\n\n<p>　　<strong>一个迭代既可以被写成生成器函数，也可以被协程生成器表达式，均支持自动和手动迭代。而且这些生成器只支持一个active迭代，也就是说生成器的迭代器就是生成器本身。</strong></p>\n<h3 id=\"迭代器（迭代就是循环）\"><a href=\"#迭代器（迭代就是循环）\" class=\"headerlink\" title=\"迭代器（迭代就是循环）\"></a>迭代器（迭代就是循环）</h3><p>**　　迭代器包含有next方法的实现，在正确的范围内返回期待的数据以及超出范围后能够抛出StopIteration的错误停止迭代。**</p>\n<p>　　我们已经知道，可以直接作用于for循环的数据类型有以下几种：</p>\n<p>一类是集合数据类型，如list,tuple,dict,set,str等</p>\n<p>一类是generator，包括生成器和带yield的generator function</p>\n<p>这些可以直接作用于for 循环的对象统称为可迭代对象：Iterable</p>\n<p>可以使用isinstance()判断一个对象是否为可<strong>Iterable</strong>对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from collections import Iterable</span><br><span class=\"line\">&gt;&gt;&gt; isinstance([], Iterable)</span><br><span class=\"line\">True</span><br><span class=\"line\">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)</span><br><span class=\"line\">True</span><br><span class=\"line\">&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable)</span><br><span class=\"line\">True</span><br><span class=\"line\">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)</span><br><span class=\"line\">True</span><br><span class=\"line\">&gt;&gt;&gt; isinstance(100, Iterable)</span><br><span class=\"line\">False</span><br></pre></td></tr></table></figure>\n<p>　　而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</p>\n<p>所以这里讲一下迭代器</p>\n<p><strong>一个实现了iter方法的对象时可迭代的，一个实现next方法的对象是迭代器</strong></p>\n<p><strong>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。</strong></p>\n<p>可以使用isinstance()判断一个对象是否是<strong>Iterator</strong>对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from collections import Iterator</span><br><span class=\"line\">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)</span><br><span class=\"line\">True</span><br><span class=\"line\">&gt;&gt;&gt; isinstance([], Iterator)</span><br><span class=\"line\">False</span><br><span class=\"line\">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)</span><br><span class=\"line\">False</span><br><span class=\"line\">&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterator)</span><br><span class=\"line\">False</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable（可迭代对象）</code>，却不是<code>Iterator（迭代器）</code>。</p>\n<p><strong>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code><strong>可以使用<code>iter()</code>函数</strong>：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; isinstance(iter([]), Iterator)</span><br><span class=\"line\">True</span><br><span class=\"line\">&gt;&gt;&gt; isinstance(iter(&#39;abc&#39;), Iterator)</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n<p>你可能会问，为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？</p>\n<p>这是因为Python的<code>Iterator</code>对象表示的是一个<strong>数据流</strong>，Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>\n<p><code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>\n<p><strong>判断下列数据类型是可迭代对象or迭代器</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">s&#x3D;&#39;hello&#39;</span><br><span class=\"line\">l&#x3D;[1,2,3,4]</span><br><span class=\"line\">t&#x3D;(1,2,3)</span><br><span class=\"line\">d&#x3D;&#123;&#39;a&#39;:1&#125;</span><br><span class=\"line\">set&#x3D;&#123;1,2,3&#125;</span><br><span class=\"line\">f&#x3D;open(&#39;a.txt&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">s&#x3D;&#39;hello&#39;     #字符串是可迭代对象，但不是迭代器</span><br><span class=\"line\">l&#x3D;[1,2,3,4]     #列表是可迭代对象，但不是迭代器</span><br><span class=\"line\">t&#x3D;(1,2,3)       #元组是可迭代对象，但不是迭代器</span><br><span class=\"line\">d&#x3D;&#123;&#39;a&#39;:1&#125;        #字典是可迭代对象，但不是迭代器</span><br><span class=\"line\">set&#x3D;&#123;1,2,3&#125;     #集合是可迭代对象，但不是迭代器</span><br><span class=\"line\"># *************************************</span><br><span class=\"line\">f&#x3D;open(&#39;test.txt&#39;) #文件是可迭代对象，是迭代器</span><br><span class=\"line\"></span><br><span class=\"line\">#如何判断是可迭代对象，只有__iter__方法，执行该方法得到的迭代器对象。</span><br><span class=\"line\"># 及可迭代对象通过__iter__转成迭代器对象</span><br><span class=\"line\">from collections import Iterator  #迭代器</span><br><span class=\"line\">from collections import Iterable  #可迭代对象</span><br><span class=\"line\"></span><br><span class=\"line\">print(isinstance(s,Iterator))     #判断是不是迭代器</span><br><span class=\"line\">print(isinstance(s,Iterable))       #判断是不是可迭代对象</span><br><span class=\"line\"></span><br><span class=\"line\">#把可迭代对象转换为迭代器</span><br><span class=\"line\">print(isinstance(iter(s),Iterator))</span><br></pre></td></tr></table></figure>\n<p>**　注意：文件的判断**</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">f &#x3D; open(&#39;housing.csv&#39;)</span><br><span class=\"line\">from collections import Iterator</span><br><span class=\"line\">from collections import Iterable</span><br><span class=\"line\"></span><br><span class=\"line\">print(isinstance(f,Iterator))</span><br><span class=\"line\">print(isinstance(f,Iterable))</span><br><span class=\"line\"></span><br><span class=\"line\">True</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n\n<p>　　<strong>结论：文件是可迭代对象，也是迭代器</strong></p>\n<p><strong>小结：</strong></p>\n<ul>\n<li>  凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</li>\n<li>  凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</li>\n<li>  集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</li>\n</ul>\n<p>Python3的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">for x in [1, 2, 3, 4, 5]:</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n\n<p>　实际上完全等价于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 首先获得Iterator对象:</span><br><span class=\"line\">it &#x3D; iter([1, 2, 3, 4, 5])</span><br><span class=\"line\"># 循环:</span><br><span class=\"line\">while True:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        # 获得下一个值:</span><br><span class=\"line\">        x &#x3D; next(it)</span><br><span class=\"line\">    except StopIteration:</span><br><span class=\"line\">        # 遇到StopIteration就退出循环</span><br><span class=\"line\">        break</span><br></pre></td></tr></table></figure>\n<h3 id=\"对yield的总结\"><a href=\"#对yield的总结\" class=\"headerlink\" title=\"对yield的总结\"></a>对yield的总结</h3><p>　　（1）通常的for..in…循环中，in后面是一个数组，这个数组就是一个可迭代对象，类似的还有链表，字符串，文件。他可以是a = [1,2,3]，也可以是a = [x*x for x in range(3)]。</p>\n<p>它的缺点也很明显，就是所有数据都在内存里面，如果有海量的数据，将会非常耗内存。</p>\n<p>　　（2）生成器是可以迭代的，但是只可以读取它一次。因为用的时候才生成，比如a = (x*x for x in range(3))。!!!!注意这里是小括号而不是方括号。</p>\n<p>　　（3）生成器（generator）能够迭代的关键是他有next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。</p>\n<p>　　（4）带有yield的函数不再是一个普通的函数，而是一个生成器generator，可用于迭代</p>\n<p>　　（5）yield是一个类似return 的关键字，迭代一次遇到yield的时候就返回yield后面或者右面的值。而且下一次迭代的时候，从上一次迭代遇到的yield后面的代码开始执行</p>\n<p>　　（6）yield就是return返回的一个值，并且记住这个返回的位置。下一次迭代就从这个位置开始。</p>\n<p>　　（7）带有yield的函数不仅仅是只用于for循环，而且可用于某个函数的参数，只要这个函数的参数也允许迭代参数。</p>\n<p>　　（8）send()和next()的区别就在于send可传递参数给yield表达式，这时候传递的参数就会作为yield表达式的值，而yield的参数是返回给调用者的值，也就是说send可以强行修改上一个yield表达式值。</p>\n<p>　　（9）send()和next()都有返回值，他们的返回值是当前迭代遇到的yield的时候，yield后面表达式的值，其实就是当前迭代yield后面的参数。</p>\n<p>　　（10）第一次调用时候必须先next（）或send（）,否则会报错，send后之所以为None是因为这时候没有上一个yield，所以也可以认为next（）等同于send(None)</p>\n<h5 id=\"原文：python-生成器和迭代器有这篇就够了\"><a href=\"#原文：python-生成器和迭代器有这篇就够了\" class=\"headerlink\" title=\"原文：python 生成器和迭代器有这篇就够了\"></a><a href=\"https://www.cnblogs.com/wj-1314/p/8490822.html\">原文：python 生成器和迭代器有这篇就够了</a></h5>","categories":["python"],"tags":["python生成器","python迭代器"]},{"title":"python内置函数-排列组合函数","url":"/2021/05/04/python/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>product 笛卡尔积　　（有放回抽样排列）</p>\n<p>permutations 排列　　（不放回抽样排列）</p>\n<p>combinations 组合,没有重复　　（不放回抽样组合）</p>\n<p>combinations_with_replacement 组合,有重复　　（有放回抽样组合）</p>\n<span id=\"more\"></span>\n\n<p>详细的参见<a href=\"https://docs.python.org/2/library/itertools.html\">官网</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; for i in itertools.product(&#39;ABCD&#39;, repeat &#x3D; 2):</span><br><span class=\"line\">...     print(i)</span><br><span class=\"line\">...</span><br><span class=\"line\">(&#39;A&#39;, &#39;A&#39;) (&#39;A&#39;, &#39;B&#39;) (&#39;A&#39;, &#39;C&#39;) (&#39;A&#39;, &#39;D&#39;) (&#39;B&#39;, &#39;A&#39;) (&#39;B&#39;, &#39;B&#39;) (&#39;B&#39;, &#39;C&#39;) (&#39;B&#39;, &#39;D&#39;) (&#39;C&#39;, &#39;A&#39;) (&#39;C&#39;, &#39;B&#39;) (&#39;C&#39;, &#39;C&#39;) (&#39;C&#39;, &#39;D&#39;) (&#39;D&#39;, &#39;A&#39;) (&#39;D&#39;, &#39;B&#39;) (&#39;D&#39;, &#39;C&#39;) (&#39;D&#39;, &#39;D&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; for i in itertools.permutations(&#39;ABCD&#39;, 2):</span><br><span class=\"line\">...     print(i)</span><br><span class=\"line\">...</span><br><span class=\"line\">(&#39;A&#39;, &#39;B&#39;) (&#39;A&#39;, &#39;C&#39;) (&#39;A&#39;, &#39;D&#39;) (&#39;B&#39;, &#39;A&#39;) (&#39;B&#39;, &#39;C&#39;) (&#39;B&#39;, &#39;D&#39;) (&#39;C&#39;, &#39;A&#39;) (&#39;C&#39;, &#39;B&#39;) (&#39;C&#39;, &#39;D&#39;) (&#39;D&#39;, &#39;A&#39;) (&#39;D&#39;, &#39;B&#39;) (&#39;D&#39;, &#39;C&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; for i in itertools.combinations(&#39;ABCD&#39;, 2):</span><br><span class=\"line\">...     print(i)</span><br><span class=\"line\">...</span><br><span class=\"line\">(&#39;A&#39;, &#39;B&#39;) (&#39;A&#39;, &#39;C&#39;) (&#39;A&#39;, &#39;D&#39;) (&#39;B&#39;, &#39;C&#39;) (&#39;B&#39;, &#39;D&#39;) (&#39;C&#39;, &#39;D&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; for i in itertools.combinations_with_replacement(&#39;ABCD&#39;, 2):</span><br><span class=\"line\">...     print(i)</span><br><span class=\"line\">...</span><br><span class=\"line\">(&#39;A&#39;, &#39;A&#39;) (&#39;A&#39;, &#39;B&#39;) (&#39;A&#39;, &#39;C&#39;) (&#39;A&#39;, &#39;D&#39;) (&#39;B&#39;, &#39;B&#39;) (&#39;B&#39;, &#39;C&#39;) (&#39;B&#39;, &#39;D&#39;) (&#39;C&#39;, &#39;C&#39;) (&#39;C&#39;, &#39;D&#39;) (&#39;D&#39;, &#39;D&#39;)&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure>\n\n<p>还有就是，combinations和permutations返回的是对象地址，原因是在python3里面，返回值已经不再是list,而是iterators（迭代器）, 所以想要使用，只用将iterator 转换成list 即可， 还有其他一些函数返回的也是一个对象，需要list转换，比如 list(map())等</p>\n","categories":["python"],"tags":["python内置函数"]},{"title":"安装Python","url":"/2021/05/04/python/%E5%AE%89%E8%A3%85Python/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"How-to-Install-Python\"><a href=\"#How-to-Install-Python\" class=\"headerlink\" title=\"How to Install Python\"></a><a href=\"https://linuxize.com/post/how-to-install-python-3-7-on-ubuntu-18-04/\">How to Install Python</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt-get install zlib1g-dev libbz2-dev libssl-dev libncurses5-dev  libsqlite3-dev libreadline-dev tk-dev libgdbm-dev libdb-dev libpcap-dev xz-utils libexpat1-dev   liblzma-dev libffi-dev  libc6-dev</span><br><span class=\"line\"></span><br><span class=\"line\">1. 下载源码包</span><br><span class=\"line\">     wget   https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.7.3&#x2F;Python-3.7.3.tgz</span><br><span class=\"line\">2. mkdir -p &#x2F;usr&#x2F;local&#x2F;python3</span><br><span class=\"line\">3. mv Python-3.7.3.tgz &#x2F;usr&#x2F;local&#x2F;python3</span><br><span class=\"line\">4. tar -zxf Python-3.7.3.tgz</span><br><span class=\"line\">5. cd python3.7.3</span><br><span class=\"line\">6. .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3 --with-ssl  --enable-optimizations</span><br><span class=\"line\">7. make</span><br><span class=\"line\">8. make install</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3 [#确认是否是需要的版本]</span><br><span class=\"line\">ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3.7 &#x2F;usr&#x2F;bin&#x2F;pip3</span><br><span class=\"line\"></span><br><span class=\"line\">安装pip3 apt-get install python3-pip</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mac-安装python\"><a href=\"#mac-安装python\" class=\"headerlink\" title=\"mac 安装python\"></a>mac 安装python</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install python</span><br><span class=\"line\">brew install python@3.9 # 安装指定版本</span><br></pre></td></tr></table></figure>\n","categories":["python"]},{"title":"浅析深拷贝浅拷贝","url":"/2021/05/04/python/%E6%B5%85%E6%9E%90%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>本文主要介绍python中的深拷贝和浅拷贝究竟从底层ID来看是怎么回事</p>\n<span id=\"more\"></span>\n<p><img src=\"https://user-images.githubusercontent.com/28568478/117002717-80663600-ad16-11eb-9151-ccd5e05a538b.png\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/28568478/117002786-94119c80-ad16-11eb-9c19-dd44d0494db8.png\" alt=\"image\"><br><img src=\"https://user-images.githubusercontent.com/28568478/117002798-996ee700-ad16-11eb-9a72-4cbcdd780596.png\" alt=\"image\"><br><img src=\"https://user-images.githubusercontent.com/28568478/117002811-9e339b00-ad16-11eb-9c55-2555f7bfc671.png\" alt=\"image\"><br><img src=\"https://user-images.githubusercontent.com/28568478/117002821-a2f84f00-ad16-11eb-8d56-7d4aa3dde512.png\" alt=\"image\"><br><img src=\"https://user-images.githubusercontent.com/28568478/117002835-a7246c80-ad16-11eb-8ce6-85764cfff7fe.png\" alt=\"image\"><br><img src=\"https://user-images.githubusercontent.com/28568478/117002847-abe92080-ad16-11eb-95f5-a8381a3042f4.png\" alt=\"image\"></p>\n","categories":["python"],"tags":["python 深拷贝浅拷贝"]},{"title":"Navicat Premium 15.0.21 强大的数据库管理工具(Big Sur 可用)","url":"/2021/05/07/tools/Navicat%20Premium%2015.0.21%20%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7(Big%20Sur%20%E5%8F%AF%E7%94%A8)/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Navicat Premium 15.0.21 强大的数据库管理工具(Big Sur 可用)<br>链接： <a href=\"https://xclient.info/s/navicat-premium.html#versions\">https://xclient.info/s/navicat-premium.html#versions</a></p>\n","categories":["工具"],"tags":["macOS","Navicat"]},{"title":"percona-toolkit工具（数据一致性监测、延迟监控）使用梳理","url":"/2021/05/07/tools/percona-toolkit%E5%B7%A5%E5%85%B7%EF%BC%88%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%9B%91%E6%B5%8B%E3%80%81%E5%BB%B6%E8%BF%9F%E7%9B%91%E6%8E%A7%EF%BC%89%E4%BD%BF%E7%94%A8%E6%A2%B3%E7%90%86/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p><a href=\"https://www.cnblogs.com/kevingrace/p/6261091.html\">原文链接: MySQL 主从同步(3)-percona-toolkit工具（数据一致性监测、延迟监控）使用梳理\n</a></p>\n","categories":["工具"],"tags":["percona-toolkit","监控","监测","一致性"]},{"title":"Linux安装MySQL","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Linux%E5%AE%89%E8%A3%85MySQL/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"一、安装\"><a href=\"#一、安装\" class=\"headerlink\" title=\"一、安装\"></a>一、安装</h2><p>sudo apt update</p>\n<p>sudo apt-get install mysql-server  # 安装MySQL服务端</p>\n<p>以上两个命令 即安装成功</p>\n<span id=\"more\"></span>\n\n<h2 id=\"二、安装后的密码问题\"><a href=\"#二、安装后的密码问题\" class=\"headerlink\" title=\"二、安装后的密码问题\"></a>二、安装后的密码问题</h2><p>sudo cat /etc/mysql/debian.cnf 查看默认的用户名和密码</p>\n<h2 id=\"三、添加自己的密码\"><a href=\"#三、添加自己的密码\" class=\"headerlink\" title=\"三、添加自己的密码\"></a>三、添加自己的密码</h2><ul>\n<li><p>1、use mysql; 然后敲回车</p>\n</li>\n<li><p>2、update user set authentication_string=password(“你的密码”) where user=”root”; 然后敲回车</p>\n</li>\n<li><p>3、flush privileges; 然后敲回车</p>\n</li>\n</ul>\n<p>用账户密码登录时发现报错</p>\n<p>ERROR 1698 (28000): Access denied for user ‘root’@’localhost’</p>\n<p>解决方法如下：</p>\n<ul>\n<li><p>step1：在ubuntu的terminal（也即终端）上输入：</p>\n<pre><code>  sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf,\n\n  进入到这个配置文件，\n\n  然后在这个配置文件中的[mysqld]这一块中加入skip-grant-tables这句话。\n\n  保存:wq，退出。输入：service mysql restart，重新启动mysql。\n</code></pre>\n</li>\n<li><p>step2：在终端上输入mysql -u root -p，遇见输入密码的提示直接回车即可,进入mysql后，分别执行下面三句话：</p>\n<pre><code>  1、use mysql; 然后敲回车\n\n  2、update user set authentication_string=password(&quot;你的密码&quot;) where user=&quot;root&quot;; 然后敲回车\n\n  3、flush privileges; 然后敲回车\n</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>step3：重新进入到mysqld.cnf文件中去把刚开始加的skip-grant-tables这条语句给注释掉。</p>\n<pre><code>      再返回终端输入mysql -u root -p，应该就可以进入数据库了。\n</code></pre>\n</li>\n<li><p>step4：如果此时还是报出错误，那么就需要返回step3中，把注释掉的那条语句重新生效（就是删除#符号），重新进入mysql中，先选择一个数据库（use mysql;）,然后输入select user,plugin from user;，看下图：</p>\n</li>\n</ul>\n<p>从图中可以看到在执行了select user,plugin from user;后，错误原因是因为plugin root的字段是auth_socket，那我们改掉它为下面的mysql_native_password就行了。输入：</p>\n<p>1、update user set authentication_string=password(“你的密码”),plugin=’mysql_native_password’ where user=’root’;</p>\n<p>最后quit退出。返回执行step3。</p>\n<p>那么这个问题就完全解决了</p>\n<p>参考链接：<a href=\"https://www.cnblogs.com/cpl9412290130/p/9583868.html\">https://www.cnblogs.com/cpl9412290130/p/9583868.html</a></p>\n","categories":["数据库"],"tags":["mysql"]},{"title":"Can't connect to local MySQL server through socket'/var/run/mysqld/mysqld.sock' (2)","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Can't%20connect%20to%20local%20MySQL%20server%20through/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>启动命令mysql时报错：</p>\n<p>ERROR2002 (HY000): Can’t connect to local MySQL server through socket’/var/run/mysqld/mysqld.sock’ (2)</p>\n<p>解决方法：</p>\n<p>找到配置文件/etc/mysql/conf.d/mysql.cnf添加</p>\n<p>[mysql]</p>\n<p>protocol=tcp</p>\n<p>参考文献：<a href=\"https://www.cnblogs.com/zhao123h/p/5207622.html\">https://www.cnblogs.com/zhao123h/p/5207622.html</a></p>\n","categories":["数据库"],"tags":["mysql"]},{"title":"Mac下MySQL-python安装及EnvironmentError mysql_config not found的解决办法","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Mac%E4%B8%8BMySQL-python%E5%AE%89%E8%A3%85%E5%8F%8AEnvironmentError:%20mysql_config%20not%20found%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>今天  pip install MySQL-python==1.2.5  报如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">EnvironmentError: mysql_config not found</span><br><span class=\"line\"></span><br><span class=\"line\">Command &quot;python setup.py egg_info&quot; failed with error code 1 in &#x2F;private&#x2F;var&#x2F;folders&#x2F;6h&#x2F;hchh3z9d6b33h11qh0wh__dh0000gn&#x2F;T&#x2F;pip-install-Rm43Qv&#x2F;MySQL-python&#x2F;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-images.githubusercontent.com/28568478/117392434-a6f9bc00-af24-11eb-836c-f51c7a67ae47.png\" alt=\"image\"></p>\n<p>解决方法如下：</p>\n<p>1）首先需要进行Python的安装</p>\n<p>（2）进行mysql的安装，多种方式，偷懒一些可以直接使用brew指令</p>\n<p>brew install mysql</p>\n<p>（3）mysql_config not found的造成原因就是因为我们默认安装的路径没有被填加进去，所以使用export命令来设置下环境变量：</p>\n<p>export PATH=$PATH:/usr/local/mysql/bin</p>\n<p>（4）进行MySQL-Python的安装：</p>\n<p>pip install MySQL-Python</p>\n<p>原文：<a href=\"https://blog.csdn.net/Megustas_JJC/article/details/78955958\">https://blog.csdn.net/Megustas_JJC/article/details/78955958</a></p>\n","categories":["数据库"],"tags":["mysql"]},{"title":"Mysql5.7使用group by查询时order by无效问题","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql5.7%E4%BD%BF%E7%94%A8group%20by%E6%9F%A5%E8%AF%A2%E6%97%B6order%20by%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>Mysql5.7使用group by查询时order by无效问题<br>第一种写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT</span><br><span class=\"line\">\t*</span><br><span class=\"line\">FROM</span><br><span class=\"line\">\tuser_paper_relation</span><br><span class=\"line\">WHERE</span><br><span class=\"line\">\tpaper_id &#x3D; &quot;&quot;</span><br><span class=\"line\">GROUP BY</span><br><span class=\"line\">\texamer_id</span><br><span class=\"line\">ORDER BY</span><br><span class=\"line\">\ttotal_score DESC</span><br></pre></td></tr></table></figure>\n<p>问题：发现先执行的group by，后执行order by，我要的结果是先排序再分组。</p>\n<p>第二种写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT</span><br><span class=\"line\">\t*</span><br><span class=\"line\">FROM</span><br><span class=\"line\">\t( SELECT * FROM user_paper_relation WHERE paper_id &#x3D; &quot;&quot;  ORDER BY consuming_time DESC ) u</span><br><span class=\"line\">GROUP BY</span><br><span class=\"line\">\tu.examer_id</span><br></pre></td></tr></table></figure>\n<p>问题：本以为将排序写成一个子查询应该会先排序后分组，执行后发现问题同第一种写法一样。</p>\n<p>第三种写法（最终解决的写法）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT</span><br><span class=\"line\">\ta.*</span><br><span class=\"line\">FROM</span><br><span class=\"line\">\t(</span><br><span class=\"line\">\tSELECT</span><br><span class=\"line\">\t\t*</span><br><span class=\"line\">\tFROM</span><br><span class=\"line\">\t\tuser_paper_relation</span><br><span class=\"line\">\tWHERE</span><br><span class=\"line\">\t\tpaper_id &#x3D; &quot;&quot;</span><br><span class=\"line\">\tORDER BY</span><br><span class=\"line\">\t\tconsuming_time</span><br><span class=\"line\">\t\tLIMIT 0,</span><br><span class=\"line\">\t\t300</span><br><span class=\"line\">\t) a</span><br><span class=\"line\">GROUP BY</span><br><span class=\"line\">\ta.examer_id</span><br></pre></td></tr></table></figure>\n<p>解决方式：在子查询中添加LIMIT 0,300则可使子查询语句即排序执行完再进行分组。</p>\n<p>问题原因</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">原因：在mysql5.7中，如果不加limit，系统会把order by优化掉。</span><br><span class=\"line\">在mysql5.7手册的8.2.2.1中有解释：</span><br><span class=\"line\">子查询的优化是使用半连接的策略完成的(The optimizer uses semi-join strategies to improve subquery execution)</span><br><span class=\"line\">使用半连接进行优化，子查询语句必须满足一些标准(In MySQL, a subquery must satisfy these criteria to be handled as a semi-join)。</span><br><span class=\"line\">其中一个标准是:必须不是一个包含了limit和order by的语句(It must not have ORDER BY with LIMIT.)</span><br></pre></td></tr></table></figure>\n<p>原文链接：<a href=\"https://blog.csdn.net/weiwoyonzhe/article/details/82888281\">https://blog.csdn.net/weiwoyonzhe/article/details/82888281</a></p>\n","categories":["数据库"],"tags":["mysql"]},{"title":"Mysql命令行查看数据库大小(数据库版本为5.7以上)","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E5%B0%8F(%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E4%B8%BA5.7%E4%BB%A5%E4%B8%8A)/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>数据库版本为5.7以上<br>1、选择数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">use mydb1;</span><br></pre></td></tr></table></figure>\n<p>2、查看指定数据库表结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from information_schema.TABLES where information_schema.TABLES.TABLE_SCHEMA&#x3D;&#39;mydb1&#39;;</span><br></pre></td></tr></table></figure>\n<p>3、查看指定数据库的大小<br>比如说 数据库mydb1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select concat(round(sum(DATA_LENGTH&#x2F;1024&#x2F;1024),2), &#39;MB&#39;) as data from information_schema.TABLES where information_schema.TABLES.TABLE_SCHEMA&#x3D;&#39;mydb1&#39;;</span><br></pre></td></tr></table></figure>\n<p>4、查看指定数据库的表的大小<br>比如说 数据库mydb1中b1表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select concat(round(sum(DATA_LENGTH&#x2F;1024&#x2F;1024),2), &#39;MB&#39;) as data from information_schema.TABLES where information_schema.TABLES.TABLE_SCHEMA&#x3D;&#39;mydb1&#39; and TABLE_NAME&#x3D;&#39;b1&#39;;</span><br></pre></td></tr></table></figure>\n","categories":["数据库"],"tags":["mysql"]},{"title":"SQL的模糊匹配区别---like,rlike,regexpx","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E7%9A%84%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%8C%BA%E5%88%AB---like,rlike,regexpx/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"一、主要区别\"><a href=\"#一、主要区别\" class=\"headerlink\" title=\"一、主要区别\"></a>一、主要区别</h2><ul>\n<li><p>(1) like的内容不是正则，而是通配符。像mysql中的”like”,但是建议使用高级函数”instr”效率更高。</p>\n</li>\n<li><p>(2) rlike的内容可以是正则，正则的写法与java一样。需要转义，例如’\\m’需要使用’\\m’</p>\n</li>\n<li><p>(3) regexp == rlike 同义词 not like not regexp</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"二、Like常用方法\"><a href=\"#二、Like常用方法\" class=\"headerlink\" title=\"二、Like常用方法\"></a>二、Like常用方法</h2><h3 id=\"1-like关键字\"><a href=\"#1-like关键字\" class=\"headerlink\" title=\"1.like关键字\"></a>1.like关键字</h3><p>like有两个模式：_和%</p>\n<p>_：表示单个字符，用来查询定长的数据</p>\n<p>%：表示0个或多个任意字符</p>\n<h3 id=\"2-示例\"><a href=\"#2-示例\" class=\"headerlink\" title=\"2.示例\"></a>2.示例</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）SELECT * FROM Persons  WHERE City LIKE &#39;N%&#39;     &quot;Persons&quot; 表中选取居住在以 &quot;N&quot; 开始的城市里的人</span><br><span class=\"line\">（2）SELECT * FROM Persons  WHERE City LIKE &#39;%g&#39;     &quot;Persons&quot; 表中选取居住在以 &quot;g&quot; 结尾的城市里的人</span><br><span class=\"line\">（3）SELECT * FROM Persons   WHERE City LIKE &#39;%lon%&#39;  从 &quot;Persons&quot; 表中选取居住在包含 &quot;lon&quot; 的城市里的人</span><br><span class=\"line\">（4）SELECT * FROM Persons   WHERE City NOT LIKE &#39;%lon%&#39;  从 &quot;Persons&quot; 表中选取居住在不包含 &quot;lon&quot; 的城市里的人</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、Mysql中Regexp常见用法\"><a href=\"#三、Mysql中Regexp常见用法\" class=\"headerlink\" title=\"三、Mysql中Regexp常见用法\"></a>三、Mysql中Regexp常见用法</h2><ul>\n<li><p>模糊匹配，包含特定字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">  #查找content字段中包含“车友俱乐部”的记录</span><br><span class=\"line\"> select * from club_content where content regexp &#39;车友俱乐部&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"># 此时的regexp与like的以下用法是等同的</span><br><span class=\"line\">select * from club_content where content like &#39;%车友俱乐部%&#39;</span><br></pre></td></tr></table></figure></li>\n<li><p>模糊匹配，以特定字符串开头</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查找content字段中以“车友”开头的记录</span><br><span class=\"line\">select * from club_content where content regexp &#39;^车友&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"># 此时的regexp与like的以下用法是等同的</span><br><span class=\"line\">select * from club_content where content like &#39;车友%&#39;</span><br></pre></td></tr></table></figure></li>\n<li><p>模糊匹配，以特定字符串结尾</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查找content字段中以“车友”结尾的记录</span><br><span class=\"line\">select * from club_content where content regexp &#39;车友$&#39;</span><br><span class=\"line\"></span><br><span class=\"line\"># 此时的regexp与like的以下用法是等同的</span><br><span class=\"line\">select * from club_content where content like &#39;%车友&#39;</span><br></pre></td></tr></table></figure></li>\n<li><p>模糊匹配 或关系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查找content字段中包含“心得”、“分享”或“技术贴”</span><br><span class=\"line\">select * from club_content where content  REGEXP &#39;心得|分享|技术贴&#39;</span><br></pre></td></tr></table></figure></li>\n<li><p>模糊匹配，不包含单个字符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查找content字段中不包含“车”字、“友”字的记录</span><br><span class=\"line\">select * from club_content where content  REGEXP [^车友]</span><br></pre></td></tr></table></figure>\n<p>这个结果跑出来一看大吃一惊，竟然把所有记录给跑出来，这是为什么呢？<br>因为一旦加了这个方括号”[]”，它就把里面的内容拆成单个的字符再匹配，它会逐个字符去匹配判断是不是等于“车”，或者是不是等于“友“，返回的结果是一组0、1的逻辑值。</p>\n</li>\n</ul>\n<p>如果想匹配不包含特定字符串，该怎么实现呢？</p>\n<p>模糊匹配，不包含特定字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查找content字段不包含“车友”字符串的记录</span><br><span class=\"line\">select * from club_content where content not REGEXP &#39;车友&#39;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">交集</span><br><span class=\"line\">表的字段就是</span><br><span class=\"line\">name  no</span><br><span class=\"line\">a     2,9</span><br><span class=\"line\">b     8,10</span><br><span class=\"line\">字符串是str&#x3D;&quot;0,1,2,3,4&quot;</span><br><span class=\"line\">接下来就是查 no字段里跟str里有交集的记录</span><br><span class=\"line\">查询的结果就是name&#x3D;a的,no&#x3D;2,9的</span><br><span class=\"line\">select * from table1 where concat(&#39;,&#39;,no,&#39;,&#39;) regexp concat(&#39;,0,|,1,|,2,|,3,|,4,&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">某字段中搜索</span><br><span class=\"line\">可以使用FIND_IN_SET</span><br><span class=\"line\">name  no</span><br><span class=\"line\">a     2,9</span><br><span class=\"line\">b     8,10</span><br><span class=\"line\">想查出no中包含2的记录</span><br><span class=\"line\">select * from table1 where FIND_IN_SET(&#39;2&#39;, no)</span><br><span class=\"line\"></span><br><span class=\"line\">替换某字段中的内容</span><br><span class=\"line\">UPDATE &#96;blog_iplimit&#96; SET &#96;ip&#96; &#x3D; REPLACE(&#96;ip&#96;, &#39;,&#39;, &#39;&#39;)</span><br></pre></td></tr></table></figure>\n<p>原文链接：<a href=\"https://blog.csdn.net/ZZQHELLO2018/java/article/details/92794555\">https://blog.csdn.net/ZZQHELLO2018/java/article/details/92794555</a></p>\n","categories":["数据库"],"tags":["mysql","sql"]},{"title":"Ubuntu 18.04 安装MongoDB","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Ubuntu%2018.04%20%E5%AE%89%E8%A3%85MongoDB/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"第1步-–-导入公钥\"><a href=\"#第1步-–-导入公钥\" class=\"headerlink\" title=\"第1步 – 导入公钥\"></a>第1步 – 导入公钥</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-key adv --keyserver hkp:&#x2F;&#x2F;keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6</span><br></pre></td></tr></table></figure>\n<h3 id=\"第2步-–-创建源列表文件MongoDB\"><a href=\"#第2步-–-创建源列表文件MongoDB\" class=\"headerlink\" title=\"第2步 – 创建源列表文件MongoDB\"></a>第2步 – 创建源列表文件MongoDB</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo &quot;deb [ arch&#x3D;amd64,arm64 ] http:&#x2F;&#x2F;repo.mongodb.org&#x2F;apt&#x2F;ubuntu xenial&#x2F;mongodb-org&#x2F;3.4 multiverse&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;mongodb-org-3.4.list</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h3 id=\"第3步-–-更新存储库\"><a href=\"#第3步-–-更新存储库\" class=\"headerlink\" title=\"第3步 – 更新存储库\"></a>第3步 – 更新存储库</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"第4步-–-安装MongoDB\"><a href=\"#第4步-–-安装MongoDB\" class=\"headerlink\" title=\"第4步 – 安装MongoDB\"></a>第4步 – 安装MongoDB</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install -y mongodb-org</span><br></pre></td></tr></table></figure>\n<h3 id=\"第5–-步修改配置\"><a href=\"#第5–-步修改配置\" class=\"headerlink\" title=\"第5– 步修改配置\"></a>第5– 步修改配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">net:</span><br><span class=\"line\">  port: 27017         # 端口号</span><br><span class=\"line\">  bindIp: 0.0.0.0    # 允许访问host</span><br><span class=\"line\">setParameter:</span><br><span class=\"line\">   enableLocalhostAuthBypass: false # 大意为开启授权</span><br></pre></td></tr></table></figure>\n<h3 id=\"新建目录\"><a href=\"#新建目录\" class=\"headerlink\" title=\"新建目录\"></a>新建目录</h3><p>为什么要创建这样这个文件夹呢？看其他人的说法是这个：</p>\n<p>MongoDB的数据存储在data目录的db目录下，但是这个目录在安装过程不会自动创建，所以你需要手动创建data目录，并在data目录中创建db目录。</p>\n<p>然后等待完成就可以使用MongoDB了，输入mongo进入命令行就可以操作了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p &#x2F;data&#x2F;db</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;mongod --config &#x2F;etc&#x2F;mongod.conf -dbpath &#x2F;data&#x2F;db&#x2F;</span><br></pre></td></tr></table></figure>\n","categories":["数据库"],"tags":["mongodb"]},{"title":"Ubuntu18.04 安装mysql","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Ubuntu18.04%20%E5%AE%89%E8%A3%85mysql/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"一、安装方法\"><a href=\"#一、安装方法\" class=\"headerlink\" title=\"一、安装方法\"></a>一、安装方法</h2><p><a href=\"https://www.cnblogs.com/opsprobe/p/9126864.html\">Ubuntu18.04下安装MySQL</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"二、常用命令\"><a href=\"#二、常用命令\" class=\"headerlink\" title=\"二、常用命令\"></a>二、常用命令</h2><p>　　1.启动：/etc/init.d/mysql start<br>sudo service mysql restart</p>\n<p>　　2.停止：/etc/init.d/mysql stop</p>\n<p>　　3.重启：/etc/init.d/mysql restart</p>\n<h2 id=\"三、报错\"><a href=\"#三、报错\" class=\"headerlink\" title=\"三、报错\"></a>三、报错</h2><h4 id=\"1、Can’t-connect-to-MySQL-server-on-‘‘-61\"><a href=\"#1、Can’t-connect-to-MySQL-server-on-‘‘-61\" class=\"headerlink\" title=\"1、Can’t connect to MySQL server on ‘‘ (61)\"></a>1、<a href=\"https://my.oschina.net/Laily/blog/712958\">Can’t connect to MySQL server on ‘<remote-ip>‘ (61)</a></h4><p>第一次安装可能是3306 只监听了localhost ，修改配置文件/etc/mysql/mysql.conf.d/mysqld.cnf中的bind-address为0.0.0.0即可<br><img src=\"https://upload-images.jianshu.io/upload_images/5818745-38bff8240f978f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h4 id=\"2、权限不够\"><a href=\"#2、权限不够\" class=\"headerlink\" title=\"2、权限不够\"></a>2、权限不够</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）SSH登录root管理员账户</span><br><span class=\"line\"></span><br><span class=\"line\">（2）登录MySql</span><br><span class=\"line\"></span><br><span class=\"line\">  mysql -u root -p</span><br><span class=\"line\">Enter password:</span><br><span class=\"line\">（3）执行授权命令</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; grant all privileges on *.* to root@&#39;localhost&#39; identified by &#39;密码&#39;;</span><br><span class=\"line\">mysql&gt; flush privileges;</span><br><span class=\"line\">或</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; grant all privileges on *.* to root@&#39;%&#39; identified by &#39;密码&#39;;</span><br><span class=\"line\">mysql&gt; flush privileges;</span><br><span class=\"line\">（4）退出再试</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; quit</span><br><span class=\"line\">Bye</span><br><span class=\"line\">（5）再次登录</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、-supervisor-配置-可不用配置-默认后台自启动\"><a href=\"#四、-supervisor-配置-可不用配置-默认后台自启动\" class=\"headerlink\" title=\"四、 supervisor 配置(可不用配置 默认后台自启动)\"></a>四、 supervisor 配置(可不用配置 默认后台自启动)</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[program:mysql_3306]</span><br><span class=\"line\">command&#x3D;&#x2F;usr&#x2F;sbin&#x2F;mysqld --daemonize --pid-file&#x3D;&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br><span class=\"line\">process_name&#x3D;mysql_3306</span><br><span class=\"line\">numprocs&#x3D;1</span><br><span class=\"line\">;user&#x3D;martin</span><br><span class=\"line\">autostart&#x3D;true</span><br><span class=\"line\">autorestart&#x3D;true</span><br><span class=\"line\">startsecs&#x3D;10</span><br><span class=\"line\">startretries&#x3D;7</span><br><span class=\"line\">stopsignal&#x3D;TERM</span><br><span class=\"line\">stopwaitsecs&#x3D;60</span><br><span class=\"line\">redirect_stderr&#x3D;false</span><br><span class=\"line\">stdout_logfile&#x3D;&#x2F;root&#x2F;log&#x2F;mysql&#x2F;mysql.log</span><br><span class=\"line\">stdout_logfile_maxbytes&#x3D;50MB</span><br><span class=\"line\">stdout_logfile_backups&#x3D;10</span><br><span class=\"line\">stdout_capture_maxbytes&#x3D;1MB</span><br><span class=\"line\">stderr_logfile&#x3D;&#x2F;root&#x2F;log&#x2F;mysql&#x2F;mysql_error.log</span><br><span class=\"line\">stderr_logfile_maxbytes&#x3D;50MB</span><br><span class=\"line\">stderr_logfile_backups&#x3D;10</span><br><span class=\"line\">stderr_capture_maxbytes&#x3D;1MB</span><br><span class=\"line\">;directory&#x3D;&#x2F;home&#x2F;martin&#x2F;data&#x2F;logagent</span><br><span class=\"line\">serverurl&#x3D;AUTO</span><br></pre></td></tr></table></figure>\n","categories":["数据库"],"tags":["mysql"]},{"title":"Ubuntu18.04 安装redis","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/Ubuntu18.04%20%E5%AE%89%E8%A3%85redis/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h3 id=\"一、安装\"><a href=\"#一、安装\" class=\"headerlink\" title=\"一、安装\"></a>一、安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install redis   # 安装redis</span><br><span class=\"line\"></span><br><span class=\"line\">cd &#x2F;etc&#x2F;redis&#x2F;redis.conf # 变更配置</span><br><span class=\"line\">注释bind 127.0.0.1 ::1</span><br><span class=\"line\">加 bind 0.0.0.0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、命令\"><a href=\"#二、命令\" class=\"headerlink\" title=\"二、命令\"></a>二、命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">bin&#x2F;sh &#x2F;etc&#x2F;init.d&#x2F;redis-server start&#x2F;stop&#x2F;restart</span><br><span class=\"line\">systemctl start&#x2F;stop&#x2F;restart redis-server</span><br><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;redis-server # 只是启动</span><br></pre></td></tr></table></figure>\n","categories":["数据库"],"tags":["redis"]},{"title":"linux安装redis 完整步骤","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/linux%E5%AE%89%E8%A3%85redis%20%E5%AE%8C%E6%95%B4%E6%AD%A5%E9%AA%A4/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"安装：\"><a href=\"#安装：\" class=\"headerlink\" title=\"安装：\"></a>安装：</h2><h3 id=\"1-获取redis资源\"><a href=\"#1-获取redis资源\" class=\"headerlink\" title=\"1.获取redis资源\"></a>1.获取redis资源</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">　　wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.8.tar.gz</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-解压\"><a href=\"#2-解压\" class=\"headerlink\" title=\"2.解压\"></a>2.解压</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">　　tar xzvf redis-4.0.8.tar.gz</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-安装\"><a href=\"#3-安装\" class=\"headerlink\" title=\"3.安装\"></a>3.安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">　　cd redis-4.0.8</span><br><span class=\"line\"></span><br><span class=\"line\">　　make</span><br><span class=\"line\"></span><br><span class=\"line\">　　cd src</span><br><span class=\"line\"></span><br><span class=\"line\">　　make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-移动配置文件到安装目录下\"><a href=\"#4-移动配置文件到安装目录下\" class=\"headerlink\" title=\"4.移动配置文件到安装目录下\"></a>4.移动配置文件到安装目录下</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">　　cd ..&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">　　mkdir &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc</span><br><span class=\"line\"></span><br><span class=\"line\">　　mv redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-配置redis为后台启动\"><a href=\"#5-配置redis为后台启动\" class=\"headerlink\" title=\"5.配置redis为后台启动\"></a>5.配置redis为后台启动</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis.conf &#x2F;&#x2F; 将daemonize no 改成daemonize yes</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-将redis加入到开机启动\"><a href=\"#6-将redis加入到开机启动\" class=\"headerlink\" title=\"6.将redis加入到开机启动\"></a>6.将redis加入到开机启动</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">　　vi &#x2F;etc&#x2F;rc.local &#x2F;&#x2F; 在里面添加内容：&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis.conf (意思就是开机调用这段开启redis的命令)</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-开启redis\"><a href=\"#7-开启redis\" class=\"headerlink\" title=\"7.开启redis\"></a>7.开启redis</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">　　&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis.conf</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">常用命令</span><br><span class=\"line\"></span><br><span class=\"line\">　　redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis.conf &#x2F;&#x2F;启动redis</span><br><span class=\"line\"></span><br><span class=\"line\">　　pkill redis  &#x2F;&#x2F;停止redis</span><br><span class=\"line\"></span><br><span class=\"line\">卸载redis：</span><br><span class=\"line\"></span><br><span class=\"line\">　　rm -rf &#x2F;usr&#x2F;local&#x2F;redis &#x2F;&#x2F;删除安装目录</span><br><span class=\"line\"></span><br><span class=\"line\">　　rm -rf &#x2F;usr&#x2F;bin&#x2F;redis-* &#x2F;&#x2F;删除所有redis相关命令脚本</span><br><span class=\"line\"></span><br><span class=\"line\">　　rm -rf &#x2F;root&#x2F;download&#x2F;redis-4.0.4 &#x2F;&#x2F;删除redis解压文件夹</span><br></pre></td></tr></table></figure>\n","categories":["数据库"],"tags":["redis"]},{"title":"macOS pip 安装 mysqlclient 报错","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/macOS%20pip%20%E5%AE%89%E8%A3%85%20mysqlclient%20%E6%8A%A5%E9%94%99/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ld: library not found for -lssl</span><br><span class=\"line\">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br><span class=\"line\">error: command &#39;clang&#39; failed with exit status 1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">export LIBRARY_PATH&#x3D;$LIBRARY_PATH:&#x2F;usr&#x2F;local&#x2F;opt&#x2F;openssl&#x2F;lib&#x2F;</span><br></pre></td></tr></table></figure>\n<p>然后再安装</p>\n","categories":["数据库"],"tags":["macOS","mysql","mysqlclient"]},{"title":"mac 安装redis、mysql、MongoDB","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/mac%20%E5%AE%89%E8%A3%85redis%E3%80%81mysql%E3%80%81MongoDB/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"redis-安装\"><a href=\"#redis-安装\" class=\"headerlink\" title=\"redis 安装\"></a>redis 安装</h2><ul>\n<li>brew install redis<h4 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h4></li>\n<li>brew services start redis（后台启动）</li>\n<li>redis-server /usr/local/etc/redis.conf （非后台启动）</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"mysql-安装\"><a href=\"#mysql-安装\" class=\"headerlink\" title=\"mysql 安装\"></a>mysql 安装</h2><ul>\n<li>brew install mysql<h4 id=\"启动-1\"><a href=\"#启动-1\" class=\"headerlink\" title=\"启动\"></a>启动</h4></li>\n<li>brew services start mysql（后台启动）</li>\n<li>mysql.server start（非后台启动）</li>\n<li>没有详细的配置文件，可参考其他系统下的my.cnf进行自我配置<br><img src=\"https://upload-images.jianshu.io/upload_images/5818745-94b616bdfccdc5ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>1、我们在没有root 密码的情况下安装了您的MySQL数据库。确保它运行：mysql_secure_installation<br>2、登录mysql: mysql -uroot<br>3、如果忘记密码：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;bin&#x2F;mysql&#x2F;</span><br><span class=\"line\">.&#x2F;mysqld_safe --skip-grant-tables &amp;  # 禁止mysql验证功能</span><br><span class=\"line\">.&#x2F;mysql  # 进入mysql</span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br><span class=\"line\">SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; &#x3D; &#39;你的新密码&#39;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>4、<img src=\"https://upload-images.jianshu.io/upload_images/5818745-ed8918da004fae4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br> <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ALTER USER root@localhost IDENTIFIED WITH mysql_native_password BY ‘你的密码’;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"mongodb-安装\"><a href=\"#mongodb-安装\" class=\"headerlink\" title=\"mongodb 安装\"></a>mongodb 安装</h2><ul>\n<li>brew install mongodb</li>\n</ul>\n<h4 id=\"启动-2\"><a href=\"#启动-2\" class=\"headerlink\" title=\"启动\"></a>启动</h4><ul>\n<li>brew services start mongodb （后台启动）</li>\n<li>mongod –config /usr/local/etc/mongod.conf （非后台启动）</li>\n</ul>\n","categories":["数据库"],"tags":["macOS","mysql","mongodb","redis"]},{"title":"mysql  show slave status 状态详解","url":"/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%20%20show%20slave%20status%20%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>MySQL同步功能由3个线程(master上1个，slave上2个)来实现。执行 DE&gt;START SLAVEDE&gt; 语句后，slave就创建一个I/O线程。I/O线程连接到master上，并请求master发送二进制日志中的语句。master创建一个线程来把日志的内容发送到slave上。这个线程在master上执行 DE&gt;SHOW PROCESSLISTDE&gt; 语句后的结果中的 DE&gt;Binlog DumpDE&gt; 线程便是。slave上的I/O线程读取master的 DE&gt;Binlog DumpDE&gt; 线程发送的语句，并且把它们拷贝到其数据目录下的中继日志(relay logs)中。第三个是SQL线程，salve用它来读取中继日志，然后执行它们来更新数据。</p>\n<p>如上所述，每个master/slave上都有3个线程。每个master上有多个线程，它为每个slave连接都创建一个线程，每个slave只有I/O和SQL线程。</p>\n<p>show slave master 用于提供有关从属服务器线程的关键参数的信息:</p>\n<span id=\"more\"></span>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; show slave status \\G;</span><br><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">               Slave_IO_State: Waiting for master to send event</span><br><span class=\"line\">                Master_Host: 172.17.2.40</span><br><span class=\"line\">                Master_User: photorepl</span><br><span class=\"line\">                Master_Port: 4331</span><br><span class=\"line\">               Connect_Retry: 60</span><br><span class=\"line\">               Master_Log_File: mysql-bin.005502</span><br><span class=\"line\">                Read_Master_Log_Pos: 64401238</span><br><span class=\"line\">               Relay_Log_File: mysqld-relay-bin.015418</span><br><span class=\"line\">               Relay_Log_Pos: 13456757</span><br><span class=\"line\">               Relay_Master_Log_File: mysql-bin.005152</span><br><span class=\"line\">               Slave_IO_Running: Yes</span><br><span class=\"line\">              Slave_SQL_Running: Yes</span><br><span class=\"line\">               Replicate_Do_DB:</span><br><span class=\"line\">               Replicate_Ignore_DB: mysql</span><br><span class=\"line\">               Replicate_Do_Table:</span><br><span class=\"line\">               Replicate_Ignore_Table:</span><br><span class=\"line\">               Replicate_Wild_Do_Table: photo.%</span><br><span class=\"line\">               Replicate_Wild_Ignore_Table: mysql.%</span><br><span class=\"line\">                 Last_Errno: 0</span><br><span class=\"line\">                 Last_Error:</span><br><span class=\"line\">               Skip_Counter: 0</span><br><span class=\"line\">               Exec_Master_Log_Pos: 13456620</span><br><span class=\"line\">              Relay_Log_Space: 36764898503</span><br><span class=\"line\">               Until_Condition: None</span><br><span class=\"line\">              Until_Log_File:</span><br><span class=\"line\">              Until_Log_Pos: 0</span><br><span class=\"line\">              Master_SSL_Allowed: No</span><br><span class=\"line\">             Master_SSL_CA_File:</span><br><span class=\"line\">             Master_SSL_CA_Path:</span><br><span class=\"line\">              Master_SSL_Cert:</span><br><span class=\"line\">              Master_SSL_Cipher:</span><br><span class=\"line\">             Master_SSL_Key:</span><br><span class=\"line\">            Seconds_Behind_Master: 249904</span><br><span class=\"line\">××××××××××××××××××××××××××××××××××××××××××××××××××××××××××</span><br></pre></td></tr></table></figure>\n\n<p>SHOW SLAVE STATUS会返回以下字段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> Slave_IO_State</span><br><span class=\"line\"></span><br><span class=\"line\">SHOW PROCESSLIST输出的State字段的拷贝。SHOW PROCESSLIST用于从属I&#x2F;O线程。如果线程正在试图连接到主服务器，正在等待来自主服务器的时间或正在连接到主服务器等，本语句会通知您</span><br><span class=\"line\"></span><br><span class=\"line\"> Master_User</span><br><span class=\"line\"></span><br><span class=\"line\">被用于连接主服务器的当前用户。</span><br><span class=\"line\"></span><br><span class=\"line\">Master_Port</span><br><span class=\"line\"></span><br><span class=\"line\">当前的主服务器接口。</span><br><span class=\"line\"></span><br><span class=\"line\">Connect_Retry</span><br><span class=\"line\"></span><br><span class=\"line\">--master-connect-retry选项的当前值</span><br><span class=\"line\"></span><br><span class=\"line\">Master_Log_File</span><br><span class=\"line\"></span><br><span class=\"line\">I&#x2F;O线程当前正在读取的主服务器二进制日志文件的名称。</span><br><span class=\"line\"></span><br><span class=\"line\">Read_Master_Log_Pos</span><br><span class=\"line\"></span><br><span class=\"line\">在当前的主服务器二进制日志中，I&#x2F;O线程已经读取的位置。</span><br><span class=\"line\"></span><br><span class=\"line\">Relay_Log_File</span><br><span class=\"line\"></span><br><span class=\"line\">SQL线程当前正在读取和执行的中继日志文件的名称。</span><br><span class=\"line\"></span><br><span class=\"line\">Relay_Log_Pos</span><br><span class=\"line\"></span><br><span class=\"line\">在当前的中继日志中，SQL线程已读取和执行的位置。</span><br><span class=\"line\"></span><br><span class=\"line\">Relay_Master_Log_File</span><br><span class=\"line\"></span><br><span class=\"line\">由SQL线程执行的包含多数近期事件的主服务器二进制日志文件的名称。</span><br><span class=\"line\"></span><br><span class=\"line\">Slave_IO_Running</span><br><span class=\"line\"></span><br><span class=\"line\">I&#x2F;O线程是否被启动并成功地连接到主服务器上。</span><br><span class=\"line\"></span><br><span class=\"line\">Slave_SQL_Running</span><br><span class=\"line\"></span><br><span class=\"line\">SQL线程是否被启动。</span><br><span class=\"line\"></span><br><span class=\"line\">Replicate_Do_DB,Replicate_Ignore_DB</span><br><span class=\"line\"></span><br><span class=\"line\">使用--replicate-do-db和--replicate-ignore-db选项指定的数据库清单。</span><br><span class=\"line\"></span><br><span class=\"line\">Replicate_Do_Table,Replicate_Ignore_Table,Replicate_Wild_Do_Table,Replicate_Wild_Ignore_Table</span><br><span class=\"line\"></span><br><span class=\"line\">使用--replicate-do-table,--replicate-ignore-table,--replicate-wild-do-table和--replicate-wild-ignore_table选项指定的表清单。</span><br><span class=\"line\"></span><br><span class=\"line\">Last_Errno,Last_Error</span><br><span class=\"line\"></span><br><span class=\"line\">被多数最近被执行的查询返回的错误数量和错误消息。错误数量为0并且消息为空字符串意味着“没有错误”。如果Last_Error值不是空值，它也会在从属服务器的错误日志中作为消息显示。</span><br><span class=\"line\"></span><br><span class=\"line\">举例说明：</span><br><span class=\"line\"></span><br><span class=\"line\">Last_Errno: 1051</span><br><span class=\"line\"></span><br><span class=\"line\">Last_Error: error &#39;Unknown table &#39;z&#39;&#39; on query &#39;drop table z&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">该消息指示，表z曾经存在于在主服务器中并已被取消了，但是它没有在从属服务器中存在过，因此对于从属服务器，DROP TABLE失败。（举例说明，在设置复制时，如果您忘记了把此表拷贝到从属服务器中，则这有可能发生。）</span><br><span class=\"line\"></span><br><span class=\"line\">Skip_Counter</span><br><span class=\"line\"></span><br><span class=\"line\">最近被使用的用于SQL_SLAVE_SKIP_COUNTER的值。</span><br><span class=\"line\"></span><br><span class=\"line\">Exec_Master_Log_Pos</span><br><span class=\"line\"></span><br><span class=\"line\">来自主服务器的二进制日志的由SQL线程执行的上一个时间的位置（Relay_Master_Log_File）。在主服务器的二进制日志中的(Relay_Master_Log_File,Exec_Master_Log_Pos)对应于在中继日志中的(Relay_Log_File,Relay_Log_Pos)。</span><br><span class=\"line\"></span><br><span class=\"line\">Relay_Log_Space</span><br><span class=\"line\"></span><br><span class=\"line\">所有原有的中继日志结合起来的总大小。</span><br><span class=\"line\"></span><br><span class=\"line\">Until_Condition,Until_Log_File,Until_Log_Pos</span><br><span class=\"line\"></span><br><span class=\"line\">在START SLAVE语句的UNTIL子句中指定的值。</span><br><span class=\"line\"></span><br><span class=\"line\">Until_Condition具有以下值：</span><br><span class=\"line\"></span><br><span class=\"line\">如果没有指定UNTIL子句，则没有值</span><br><span class=\"line\"></span><br><span class=\"line\">如果从属服务器正在读取，直到达到主服务器的二进制日志的给定位置为止，则值为Master</span><br><span class=\"line\"></span><br><span class=\"line\">如果从属服务器正在读取，直到达到其中继日志的给定位置为止，则值为Relay</span><br><span class=\"line\"></span><br><span class=\"line\">Until_Log_File和Until_Log_Pos用于指示日志文件名和位置值。日志文件名和位置值定义了SQL线程在哪个点中止执行。</span><br><span class=\"line\"></span><br><span class=\"line\">Master_SSL_Allowed,Master_SSL_CA_File,Master_SSL_CA_Path,Master_SSL_Cert,Master_SSL_Cipher,Master_SSL_Key</span><br><span class=\"line\"></span><br><span class=\"line\">这些字段显示了被从属服务器使用的参数。这些参数用于连接主服务器。</span><br><span class=\"line\"></span><br><span class=\"line\">Master_SSL_Allowed具有以下值：</span><br><span class=\"line\"></span><br><span class=\"line\">如果允许对主服务器进行SSL连接，则值为Yes</span><br><span class=\"line\"></span><br><span class=\"line\">如果不允许对主服务器进行SSL连接，则值为No</span><br><span class=\"line\"></span><br><span class=\"line\">如果允许SSL连接，但是从属服务器没有让SSL支持被启用，则值为Ignored。</span><br><span class=\"line\"></span><br><span class=\"line\">与SSL有关的字段的值对应于--master-ca,--master-capath,--master-cert,--master-cipher和--master-key选项的值。</span><br><span class=\"line\"></span><br><span class=\"line\">Seconds_Behind_Master</span><br><span class=\"line\"></span><br><span class=\"line\">本字段是从属服务器“落后”多少的一个指示。当从属SQL线程正在运行时（处理更新），本字段为在主服务器上由此线程执行的最近的一个事件的时间标记开始，已经过的秒数。当此线程被从属服务器I&#x2F;O线程赶上，并进入闲置状态，等待来自I&#x2F;O线程的更多的事件时，本字段为零。总之，本字段测量从属服务器SQL线程和从属服务器I&#x2F;O线程之间的时间差距，单位以秒计。</span><br><span class=\"line\"></span><br><span class=\"line\">如果主服务器和从属服务器之间的网络连接较快，则从属服务器I&#x2F;O线程会非常接近主服务器，所以本字段能够十分近似地指示，从属服务器SQL线程比主服务器落后多少。如果网络较慢，则这种指示不准确；从属SQL线程经常会赶上读取速度较慢地从属服务器I&#x2F;O线程，因此，Seconds_Behind_Master经常显示值为0。即使I&#x2F;O线程落后于主服务器时，也是如此。换句话说，本列只对速度快的网络有用。</span><br><span class=\"line\"></span><br><span class=\"line\">即使主服务器和从属服务器不具有相同的时钟，时间差计算也会起作用（当从属服务器I&#x2F;O线程启动时，计算时间差。并假定从此时以后，时间差保持不变）。如果从属SQL线程不运行，或者如果从属服务器I&#x2F;O线程不运行或未与主服务器连接，则Seconds_Behind_Master为NULL（意义为“未知”）。举例说明，如果在重新连接之前，从属服务器I&#x2F;O线程休眠了master-connect-retry秒，则显示NULL，因为从属服务器不知道主服务器正在做什么，也不能有把握地说落后多少。</span><br></pre></td></tr></table></figure>\n","categories":["数据库"],"tags":["mysql"]},{"title":"Vue.js - Day1","url":"/2021/05/02/vue/vue2.0%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/day1/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 id=\"Vue-js-Day1\"><a href=\"#Vue-js-Day1\" class=\"headerlink\" title=\"Vue.js - Day1\"></a>Vue.js - Day1</h1><h2 id=\"课程介绍\"><a href=\"#课程介绍\" class=\"headerlink\" title=\"课程介绍\"></a>课程介绍</h2><p>前5天： 都在学习Vue基本的语法和概念；打包工具 Webpack , Gulp<br>后5天： 以项目驱动教学；</p>\n<h3 id=\"什么是Vue-js\"><a href=\"#什么是Vue-js\" class=\"headerlink\" title=\"什么是Vue.js\"></a>什么是Vue.js</h3><ul>\n<li><p>Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）</p>\n</li>\n<li><p>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并成为前端三大主流框架！</p>\n</li>\n<li><p>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</p>\n</li>\n<li><p>前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；</p>\n</li>\n</ul>\n<h2 id=\"为什么要学习流行框架\"><a href=\"#为什么要学习流行框架\" class=\"headerlink\" title=\"为什么要学习流行框架\"></a>为什么要学习流行框架</h2><ul>\n<li>企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；</li>\n</ul>\n<ul>\n<li>企业中，使用框架，能够提高开发的效率；</li>\n</ul>\n<ul>\n<li>提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】）</li>\n<li>在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑；</li>\n</ul>\n<ul>\n<li>增强自己就业时候的竞争力</li>\n</ul>\n<ul>\n<li>人无我有，人有我优</li>\n<li>你平时不忙的时候，都在干嘛？</li>\n</ul>\n<h2 id=\"框架和库的区别\"><a href=\"#框架和库的区别\" class=\"headerlink\" title=\"框架和库的区别\"></a>框架和库的区别</h2><ul>\n<li>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。</li>\n</ul>\n<ul>\n<li>node 中的 express；</li>\n</ul>\n<ul>\n<li>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。</li>\n</ul>\n<ul>\n<li><ol>\n<li>从Jquery 切换到 Zepto</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>从 EJS 切换到 art-template</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别\"><a href=\"#Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别\" class=\"headerlink\" title=\"Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别\"></a>Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别</h2><ul>\n<li><p>MVC 是后端的分层开发概念；</p>\n</li>\n<li><p>MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel</p>\n</li>\n<li><p>为什么有了MVC还要有MVVM</p>\n</li>\n</ul>\n<h2 id=\"Vue-js-基本代码-和-MVVM-之间的对应关系\"><a href=\"#Vue-js-基本代码-和-MVVM-之间的对应关系\" class=\"headerlink\" title=\"Vue.js 基本代码 和 MVVM 之间的对应关系\"></a>Vue.js 基本代码 和 MVVM 之间的对应关系</h2><p><img src=\"https://user-images.githubusercontent.com/28568478/116802575-5b22cd80-ab46-11eb-8f55-8b75473b6d4a.png\" alt=\"01 MVC和MVVM的关系图解\"></p>\n<h2 id=\"Vue之-基本的代码结构和插值表达式、v-cloak\"><a href=\"#Vue之-基本的代码结构和插值表达式、v-cloak\" class=\"headerlink\" title=\"Vue之 - 基本的代码结构和插值表达式、v-cloak\"></a>Vue之 - <code>基本的代码结构</code>和<code>插值表达式</code>、<code>v-cloak</code></h2><h2 id=\"Vue指令之v-text和v-html\"><a href=\"#Vue指令之v-text和v-html\" class=\"headerlink\" title=\"Vue指令之v-text和v-html\"></a>Vue指令之<code>v-text</code>和<code>v-html</code></h2><h2 id=\"Vue指令之v-bind的三种用法\"><a href=\"#Vue指令之v-bind的三种用法\" class=\"headerlink\" title=\"Vue指令之v-bind的三种用法\"></a>Vue指令之<code>v-bind</code>的三种用法</h2><ol>\n<li><p>直接使用指令<code>v-bind</code></p>\n</li>\n<li><p>使用简化指令<code>:</code></p>\n</li>\n<li><p>在绑定的时候，拼接绑定内容：<code>:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot;</code></p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class=\"line\">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class=\"line\">    &lt;!-- &lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; --&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        &#x2F;* 默认加入v-cloak的元素 隐藏 *&#x2F;</span><br><span class=\"line\">        [v-cloak] &#123;</span><br><span class=\"line\">            display: none;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;&#x2F;style&gt;</span><br><span class=\"line\">&lt;&#x2F;head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 使用v-cloak能够解决插值表达式闪烁的问题 --&gt;</span><br><span class=\"line\">        &lt;p v-cloak&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class=\"line\">        &lt;!-- 默认v-text是没有闪烁问题的</span><br><span class=\"line\">            v-text 会覆盖元素中原本的内容，但是插值表达式 只会替换自己的这个占位符 不会吧扎鞥个元素内容清空</span><br><span class=\"line\">        --&gt;</span><br><span class=\"line\">        &lt;h4 v-text&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;h4&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- v-html会解析html格式字符串 --&gt;</span><br><span class=\"line\">        &lt;div&gt;&#123;&#123;msg2&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\">        &lt;div v-text&#x3D;&quot;msg2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">        &lt;div v-html&#x3D;&quot;msg2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">         &lt;!-- v-bind 是vue中提供用于绑定属性的指令 --&gt;</span><br><span class=\"line\">         &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot; title&#x3D;&quot;123&quot;&gt;</span><br><span class=\"line\">         &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot; title&#x3D;&quot;mytitle&quot;&gt;</span><br><span class=\"line\">         &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot; v-bind:title&#x3D;&quot;mytitle&quot;&gt;</span><br><span class=\"line\">         &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot; v-bind:title&#x3D;&quot;mytitle+&#39;123&#39;&quot;&gt;</span><br><span class=\"line\">         &lt;!-- 简化写 --&gt;</span><br><span class=\"line\">         &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot; :title&#x3D;&quot;mytitle+&#39;456&#39;&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">         &lt;!-- vue中 提供了v-on 事件绑定机制 --&gt;</span><br><span class=\"line\">         &lt;!-- 这样写会报错 未定义alert方法 --&gt;</span><br><span class=\"line\">         &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot; :title&#x3D;&quot;mytitle+&#39; v-on&#39;&quot; v-on:click&#x3D;&quot;alert(&#39;报警&#39;)&quot;&gt;</span><br><span class=\"line\">         &lt;!-- 貌似v-bind:title不生效 --&gt;</span><br><span class=\"line\">         &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot; :title&#x3D;&quot;show_title&quot; v-on:click&#x3D;&quot;show&quot;&gt;</span><br><span class=\"line\">         &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot; :title&#x3D;&quot;show_title&quot; v-on:mouseover&#x3D;&quot;show&quot;&gt;</span><br><span class=\"line\">         &lt;!-- v-on缩写 用@代替 v-on:--&gt;</span><br><span class=\"line\">         &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot; :title&#x3D;&quot;show_title&quot; @mouseover&#x3D;&quot;show&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- vue.js放在这里时 如果网速过慢 会导致 &#123;&#123;msg&#125;&#125; 展现在页面</span><br><span class=\"line\">        需要加v-cloak 设置样式为none 这样在网速慢的时候加载出来不会出现&#123;&#123;msg&#125;&#125;</span><br><span class=\"line\">        而是当msg数据返回时才会展示信息</span><br><span class=\"line\">    --&gt;</span><br><span class=\"line\">    &lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">            el: &quot;#app&quot;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                msg:123,</span><br><span class=\"line\">                msg2:&#39;&lt;h1&gt;哈哈 我是一个大大的H1&lt;&#x2F;h1&gt;&#39;,</span><br><span class=\"line\">                mytitle:&quot;这是一个自己定义的title&quot;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            methods:&#123; &#x2F;&#x2F; 这个methods 属性中国定义了当前vue实例所有可用的方法</span><br><span class=\"line\">                show: function () &#123;</span><br><span class=\"line\">                    alert(&quot;报警&quot;)</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Vue指令之v-on和跑马灯效果\"><a href=\"#Vue指令之v-on和跑马灯效果\" class=\"headerlink\" title=\"Vue指令之v-on和跑马灯效果\"></a>Vue指令之<code>v-on</code>和<code>跑马灯效果</code></h2><h3 id=\"跑马灯效果\"><a href=\"#跑马灯效果\" class=\"headerlink\" title=\"跑马灯效果\"></a>跑马灯效果</h3><ol>\n<li>HTML结构：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;开启&quot; v-on:click&#x3D;&quot;go&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;停止&quot; v-on:click&#x3D;&quot;stop&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>Vue实例：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\"></span><br><span class=\"line\">   var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     el: &#39;#app&#39;,</span><br><span class=\"line\"></span><br><span class=\"line\">     data: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       info: &#39;猥琐发育，别浪~！&#39;,</span><br><span class=\"line\"></span><br><span class=\"line\">       intervalId: null</span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">     methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       go() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         &#x2F;&#x2F; 如果当前有定时器在运行，则直接return</span><br><span class=\"line\"></span><br><span class=\"line\">         if (this.intervalId !&#x3D; null) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           return;</span><br><span class=\"line\"></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         &#x2F;&#x2F; 开始定时器</span><br><span class=\"line\"></span><br><span class=\"line\">         this.intervalId &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           this.info &#x3D; this.info.substring(1) + this.info.substring(0, 1);</span><br><span class=\"line\"></span><br><span class=\"line\">         &#125;, 500);</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">       stop() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         clearInterval(this.intervalId);</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"Vue指令之v-on的缩写和事件修饰符\"><a href=\"#Vue指令之v-on的缩写和事件修饰符\" class=\"headerlink\" title=\"Vue指令之v-on的缩写和事件修饰符\"></a>Vue指令之<code>v-on的缩写</code>和<code>事件修饰符</code></h2><h3 id=\"事件修饰符：\"><a href=\"#事件修饰符：\" class=\"headerlink\" title=\"事件修饰符：\"></a>事件修饰符：</h3><ul>\n<li><p>.stop       阻止冒泡</p>\n</li>\n<li><p>.prevent    阻止默认事件</p>\n</li>\n<li><p>.capture    添加事件侦听器时使用事件捕获模式</p>\n</li>\n<li><p>.self       只当事件在该元素本身（比如不是子元素）触发时触发回调</p>\n</li>\n<li><p>.once       事件只触发一次</p>\n</li>\n</ul>\n<h2 id=\"Vue指令之v-model和双向数据绑定\"><a href=\"#Vue指令之v-model和双向数据绑定\" class=\"headerlink\" title=\"Vue指令之v-model和双向数据绑定\"></a>Vue指令之<code>v-model</code>和<code>双向数据绑定</code></h2><h2 id=\"简易计算器案例\"><a href=\"#简易计算器案例\" class=\"headerlink\" title=\"简易计算器案例\"></a>简易计算器案例</h2><ol>\n<li>HTML 代码结构</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;n1&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;select v-model&#x3D;&quot;opt&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;option value&#x3D;&quot;0&quot;&gt;+&lt;&#x2F;option&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;option value&#x3D;&quot;1&quot;&gt;-&lt;&#x2F;option&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;option value&#x3D;&quot;2&quot;&gt;*&lt;&#x2F;option&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;option value&#x3D;&quot;3&quot;&gt;÷&lt;&#x2F;option&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;&#x2F;select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;n2&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;&#x3D;&quot; v-on:click&#x3D;&quot;getResult&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;result&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>Vue实例代码：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\"></span><br><span class=\"line\">   var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     el: &#39;#app&#39;,</span><br><span class=\"line\"></span><br><span class=\"line\">     data: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       n1: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">       n2: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">       result: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">       opt: &#39;0&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">     methods: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       getResult() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         switch (this.opt) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           case &#39;0&#39;:</span><br><span class=\"line\"></span><br><span class=\"line\">             this.result &#x3D; parseInt(this.n1) + parseInt(this.n2);</span><br><span class=\"line\"></span><br><span class=\"line\">             break;</span><br><span class=\"line\"></span><br><span class=\"line\">           case &#39;1&#39;:</span><br><span class=\"line\"></span><br><span class=\"line\">             this.result &#x3D; parseInt(this.n1) - parseInt(this.n2);</span><br><span class=\"line\"></span><br><span class=\"line\">             break;</span><br><span class=\"line\"></span><br><span class=\"line\">           case &#39;2&#39;:</span><br><span class=\"line\"></span><br><span class=\"line\">             this.result &#x3D; parseInt(this.n1) * parseInt(this.n2);</span><br><span class=\"line\"></span><br><span class=\"line\">             break;</span><br><span class=\"line\"></span><br><span class=\"line\">           case &#39;3&#39;:</span><br><span class=\"line\"></span><br><span class=\"line\">             this.result &#x3D; parseInt(this.n1) &#x2F; parseInt(this.n2);</span><br><span class=\"line\"></span><br><span class=\"line\">             break;</span><br><span class=\"line\"></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h2 id=\"在Vue中使用样式\"><a href=\"#在Vue中使用样式\" class=\"headerlink\" title=\"在Vue中使用样式\"></a>在Vue中使用样式</h2><h3 id=\"使用class样式\"><a href=\"#使用class样式\" class=\"headerlink\" title=\"使用class样式\"></a>使用class样式</h3><ol>\n<li><p>数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;]&quot;&gt;这是一个邪恶的H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>数组中使用三元表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是一个邪恶的H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>数组中嵌套对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;h1 :class&#x3D;&quot;[&#39;red&#39;, &#39;thin&#39;, &#123;&#39;active&#39;: isactive&#125;]&quot;&gt;这是一个邪恶的H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>直接使用对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;h1 :class&#x3D;&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是一个邪恶的H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"使用内联样式\"><a href=\"#使用内联样式\" class=\"headerlink\" title=\"使用内联样式\"></a>使用内联样式</h3><ol>\n<li><p>直接在元素上通过 <code>:style</code> 的形式，书写样式对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;h1 :style&#x3D;&quot;&#123;color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;&#125;&quot;&gt;这是一个善良的H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>将样式对象，定义到 <code>data</code> 中，并直接引用到 <code>:style</code> 中</p>\n</li>\n</ol>\n<ul>\n<li>在data上定义样式：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">data: &#123;</span><br><span class=\"line\">        h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;h1 :style&#x3D;&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>在 <code>:style</code> 中通过数组，引用多个 <code>data</code> 上的样式对象</li>\n</ol>\n<ul>\n<li>在data上定义样式：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">data: &#123;</span><br><span class=\"line\">        h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;,</span><br><span class=\"line\">        h1StyleObj2: &#123; fontStyle: &#39;italic&#39; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;h1 :style&#x3D;&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Vue指令之v-for和key属性\"><a href=\"#Vue指令之v-for和key属性\" class=\"headerlink\" title=\"Vue指令之v-for和key属性\"></a>Vue指令之<code>v-for</code>和<code>key</code>属性</h2><ol>\n<li>迭代数组</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li v-for&#x3D;&quot;(item, i) in list&quot;&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class=\"line\">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>迭代对象中的属性</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 循环遍历对象身上的属性 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;div v-for&#x3D;&quot;(val, key, i) in userInfo&quot;&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>迭代数字</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;p v-for&#x3D;&quot;i in 10&quot;&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;&#x2F;p&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>2.2.0+ 的版本里，<strong>当在组件中使用</strong> v-for 时，key 现在是必须的。</p>\n</blockquote>\n<p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “<strong>就地复用</strong>” 策略。如果数据项的顺序被改变，Vue将<strong>不是移动 DOM 元素来匹配数据项的顺序</strong>， 而是<strong>简单复用此处每个元素</strong>，并且确保它在特定索引下显示已被渲染过的每个元素。</p>\n<p>为了给 Vue 一个提示，<strong>以便它能跟踪每个节点的身份，从而重用和重新排序现有元素</strong>，你需要为每项提供一个唯一 key 属性。</p>\n<h2 id=\"Vue指令之v-if和v-show\"><a href=\"#Vue指令之v-if和v-show\" class=\"headerlink\" title=\"Vue指令之v-if和v-show\"></a>Vue指令之<code>v-if</code>和<code>v-show</code></h2><blockquote>\n<p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p>\n</blockquote>\n<h2 id=\"品牌管理案例\"><a href=\"#品牌管理案例\" class=\"headerlink\" title=\"品牌管理案例\"></a>品牌管理案例</h2><h3 id=\"添加新品牌\"><a href=\"#添加新品牌\" class=\"headerlink\" title=\"添加新品牌\"></a>添加新品牌</h3><h3 id=\"删除品牌\"><a href=\"#删除品牌\" class=\"headerlink\" title=\"删除品牌\"></a>删除品牌</h3><h3 id=\"根据条件筛选品牌\"><a href=\"#根据条件筛选品牌\" class=\"headerlink\" title=\"根据条件筛选品牌\"></a>根据条件筛选品牌</h3><ol>\n<li>1.x 版本中的filterBy指令，在2.x中已经被废除：</li>\n</ol>\n<p><a href=\"https://v1-cn.vuejs.org/api/#filterBy\">filterBy - 指令</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;tr v-for&#x3D;&quot;item in list | filterBy searchName in &#39;name&#39;&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;del(item.id)&quot;&gt;删除&lt;&#x2F;a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;tr&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在2.x版本中<a href=\"https://cn.vuejs.org/v2/guide/list.html#%E6%98%BE%E7%A4%BA%E8%BF%87%E6%BB%A4-%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C\">手动实现筛选的方式</a>：</li>\n</ol>\n<ul>\n<li>筛选框绑定到 VM 实例中的 <code>searchName</code> 属性：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;hr&gt; 输入筛选名称：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;searchName&quot;&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在使用 <code>v-for</code> 指令循环每一行数据的时候，不再直接 <code>item in list</code>，而是 <code>in</code> 一个 过滤的methods 方法，同时，把过滤条件<code>searchName</code>传递进去：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;tbody&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;tr v-for&#x3D;&quot;item in search(searchName)&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">          &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;del(item.id)&quot;&gt;删除&lt;&#x2F;a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;&#x2F;tr&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;&#x2F;tbody&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>search</code> 过滤方法中，使用 数组的 <code>filter</code> 方法进行过滤：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">search(name) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  return this.list.filter(x &#x3D;&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return x.name.indexOf(name) !&#x3D; -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"Vue调试工具vue-devtools的安装步骤和使用\"><a href=\"#Vue调试工具vue-devtools的安装步骤和使用\" class=\"headerlink\" title=\"Vue调试工具vue-devtools的安装步骤和使用\"></a>Vue调试工具<code>vue-devtools</code>的安装步骤和使用</h2><p><a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN\">Vue.js devtools - 翻墙安装方式 - 推荐</a></p>\n<h2 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h2><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p>\n<h3 id=\"私有过滤器\"><a href=\"#私有过滤器\" class=\"headerlink\" title=\"私有过滤器\"></a>私有过滤器</h3><ol>\n<li>HTML元素：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;td&gt;&#123;&#123;item.ctime | dataFormat(&#39;yyyy-mm-dd&#39;)&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>私有 <code>filters</code> 定义方式：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">filters: &#123; &#x2F;&#x2F; 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用</span><br><span class=\"line\"></span><br><span class=\"line\">    dataFormat(input, pattern &#x3D; &quot;&quot;) &#123; &#x2F;&#x2F; 在参数列表中 通过 pattern&#x3D;&quot;&quot; 来指定形参默认值，防止报错</span><br><span class=\"line\"></span><br><span class=\"line\">      var dt &#x3D; new Date(input);</span><br><span class=\"line\"></span><br><span class=\"line\">      &#x2F;&#x2F; 获取年月日</span><br><span class=\"line\"></span><br><span class=\"line\">      var y &#x3D; dt.getFullYear();</span><br><span class=\"line\"></span><br><span class=\"line\">      var m &#x3D; (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">      var d &#x3D; dt.getDate().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#x2F;&#x2F; 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span><br><span class=\"line\"></span><br><span class=\"line\">      &#x2F;&#x2F; 否则，就返回  年-月-日 时：分：秒</span><br><span class=\"line\"></span><br><span class=\"line\">      if (pattern.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;yyyy-mm-dd&#39;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;&#96;;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 获取时分秒</span><br><span class=\"line\"></span><br><span class=\"line\">        var hh &#x3D; dt.getHours().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">        var mm &#x3D; dt.getMinutes().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">        var ss &#x3D; dt.getSeconds().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;&#96;;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；</p>\n</blockquote>\n<h3 id=\"全局过滤器\"><a href=\"#全局过滤器\" class=\"headerlink\" title=\"全局过滤器\"></a>全局过滤器</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 定义一个全局过滤器</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.filter(&#39;dataFormat&#39;, function (input, pattern &#x3D; &#39;&#39;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var dt &#x3D; new Date(input);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 获取年月日</span><br><span class=\"line\"></span><br><span class=\"line\">  var y &#x3D; dt.getFullYear();</span><br><span class=\"line\"></span><br><span class=\"line\">  var m &#x3D; (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">  var d &#x3D; dt.getDate().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 否则，就返回  年-月-日 时：分：秒</span><br><span class=\"line\"></span><br><span class=\"line\">  if (pattern.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;yyyy-mm-dd&#39;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;&#96;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 获取时分秒</span><br><span class=\"line\"></span><br><span class=\"line\">    var hh &#x3D; dt.getHours().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var mm &#x3D; dt.getMinutes().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var ss &#x3D; dt.getSeconds().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;&#96;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p>\n</blockquote>\n<h2 id=\"键盘修饰符以及自定义键盘修饰符\"><a href=\"#键盘修饰符以及自定义键盘修饰符\" class=\"headerlink\" title=\"键盘修饰符以及自定义键盘修饰符\"></a>键盘修饰符以及自定义键盘修饰符</h2><h3 id=\"1-x中自定义键盘修饰符【了解即可】\"><a href=\"#1-x中自定义键盘修饰符【了解即可】\" class=\"headerlink\" title=\"1.x中自定义键盘修饰符【了解即可】\"></a>1.x中自定义键盘修饰符【了解即可】</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Vue.directive(&#39;on&#39;).keyCodes.f2 &#x3D; 113;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-x中自定义键盘修饰符\"><a href=\"#2-x中自定义键盘修饰符\" class=\"headerlink\" title=\"2.x中自定义键盘修饰符\"></a><a href=\"https://cn.vuejs.org/v2/guide/events.html#%E9%94%AE%E5%80%BC%E4%BF%AE%E9%A5%B0%E7%AC%A6\">2.x中自定义键盘修饰符</a></h3><ol>\n<li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Vue.config.keyCodes.f2 &#x3D; 113;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用自定义的按键修饰符：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;name&quot; @keyup.f2&#x3D;&quot;add&quot;&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a><a href=\"https://cn.vuejs.org/v2/guide/custom-directive.html\">自定义指令</a></h2><ol>\n<li>自定义全局和局部的 自定义指令：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 自定义全局指令 v-focus，为绑定的元素自动获取焦点：</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.directive(&#39;focus&#39;, &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  inserted: function (el) &#123; &#x2F;&#x2F; inserted 表示被绑定元素插入父节点时调用</span><br><span class=\"line\"></span><br><span class=\"line\">    el.focus();</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：</span><br><span class=\"line\"></span><br><span class=\"line\">  directives: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    color: &#123; &#x2F;&#x2F; 为元素设置指定的字体颜色</span><br><span class=\"line\"></span><br><span class=\"line\">      bind(el, binding) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        el.style.color &#x3D; binding.value;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    &#39;font-weight&#39;: function (el, binding2) &#123; &#x2F;&#x2F; 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数</span><br><span class=\"line\"></span><br><span class=\"line\">      el.style.fontWeight &#x3D; binding2.value;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>自定义指令的使用方式：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;searchName&quot; v-focus v-color&#x3D;&quot;&#39;red&#39;&quot; v-font-weight&#x3D;&quot;900&quot;&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Vue-1-x-中-自定义元素指令【已废弃-了解即可】\"><a href=\"#Vue-1-x-中-自定义元素指令【已废弃-了解即可】\" class=\"headerlink\" title=\"Vue 1.x 中 自定义元素指令【已废弃,了解即可】\"></a>Vue 1.x 中 自定义元素指令【已废弃,了解即可】</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.elementDirective(&#39;red-color&#39;, &#123;</span><br><span class=\"line\">  bind: function () &#123;</span><br><span class=\"line\">    this.el.style.color &#x3D; &#39;red&#39;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;red-color&gt;1232&lt;&#x2F;red-color&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h2><ol>\n<li><a href=\"https://v1-cn.vuejs.org/\">vue.js 1.x 文档</a></li>\n<li><a href=\"https://cn.vuejs.org/\">vue.js 2.x 文档</a></li>\n<li><a href=\"http://www.css88.com/archives/7715\">String.prototype.padStart(maxLength, fillString)</a></li>\n<li><a href=\"http://www.cnblogs.com/wuhua1/p/6686237.html\">js 里面的键盘事件对应的键码</a></li>\n<li><a href=\"http://www.cnblogs.com/kidney/p/6052935.html\">Vue.js双向绑定的实现原理</a></li>\n</ol>\n","categories":["vue2.0基础课程"],"tags":["vue","vue2.0基础课程"]},{"title":"Vue.js - Day2","url":"/2021/05/02/vue/vue2.0%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/day2/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 id=\"Vue-js-Day2\"><a href=\"#Vue-js-Day2\" class=\"headerlink\" title=\"Vue.js - Day2\"></a>Vue.js - Day2</h1><h2 id=\"品牌管理案例\"><a href=\"#品牌管理案例\" class=\"headerlink\" title=\"品牌管理案例\"></a>品牌管理案例</h2><h3 id=\"添加新品牌\"><a href=\"#添加新品牌\" class=\"headerlink\" title=\"添加新品牌\"></a>添加新品牌</h3><h3 id=\"删除品牌\"><a href=\"#删除品牌\" class=\"headerlink\" title=\"删除品牌\"></a>删除品牌</h3><h3 id=\"根据条件筛选品牌\"><a href=\"#根据条件筛选品牌\" class=\"headerlink\" title=\"根据条件筛选品牌\"></a>根据条件筛选品牌</h3><ol>\n<li>1.x 版本中的filterBy指令，在2.x中已经被废除：</li>\n</ol>\n<p><a href=\"https://v1-cn.vuejs.org/api/#filterBy\">filterBy - 指令</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;tr v-for&#x3D;&quot;item in list | filterBy searchName in &#39;name&#39;&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;del(item.id)&quot;&gt;删除&lt;&#x2F;a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;tr&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在2.x版本中<a href=\"https://cn.vuejs.org/v2/guide/list.html#%E6%98%BE%E7%A4%BA%E8%BF%87%E6%BB%A4-%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C\">手动实现筛选的方式</a>：</li>\n</ol>\n<ul>\n<li>筛选框绑定到 VM 实例中的 <code>searchName</code> 属性：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;hr&gt; 输入筛选名称：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;searchName&quot;&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在使用 <code>v-for</code> 指令循环每一行数据的时候，不再直接 <code>item in list</code>，而是 <code>in</code> 一个 过滤的methods 方法，同时，把过滤条件<code>searchName</code>传递进去：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;tbody&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;tr v-for&#x3D;&quot;item in search(searchName)&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">          &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;del(item.id)&quot;&gt;删除&lt;&#x2F;a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;&#x2F;tr&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;&#x2F;tbody&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>search</code> 过滤方法中，使用 数组的 <code>filter</code> 方法进行过滤：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">search(name) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  return this.list.filter(x &#x3D;&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return x.name.indexOf(name) !&#x3D; -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Vue调试工具vue-devtools的安装步骤和使用\"><a href=\"#Vue调试工具vue-devtools的安装步骤和使用\" class=\"headerlink\" title=\"Vue调试工具vue-devtools的安装步骤和使用\"></a>Vue调试工具<code>vue-devtools</code>的安装步骤和使用</h2><p><a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN\">Vue.js devtools - 翻墙安装方式 - 推荐</a></p>\n<h2 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h2><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p>\n<h3 id=\"私有过滤器\"><a href=\"#私有过滤器\" class=\"headerlink\" title=\"私有过滤器\"></a>私有过滤器</h3><ol>\n<li>HTML元素：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;td&gt;&#123;&#123;item.ctime | dataFormat(&#39;yyyy-mm-dd&#39;)&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>私有 <code>filters</code> 定义方式：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">filters: &#123; &#x2F;&#x2F; 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用</span><br><span class=\"line\"></span><br><span class=\"line\">    dataFormat(input, pattern &#x3D; &quot;&quot;) &#123; &#x2F;&#x2F; 在参数列表中 通过 pattern&#x3D;&quot;&quot; 来指定形参默认值，防止报错</span><br><span class=\"line\"></span><br><span class=\"line\">      var dt &#x3D; new Date(input);</span><br><span class=\"line\"></span><br><span class=\"line\">      &#x2F;&#x2F; 获取年月日</span><br><span class=\"line\"></span><br><span class=\"line\">      var y &#x3D; dt.getFullYear();</span><br><span class=\"line\"></span><br><span class=\"line\">      var m &#x3D; (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">      var d &#x3D; dt.getDate().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#x2F;&#x2F; 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span><br><span class=\"line\"></span><br><span class=\"line\">      &#x2F;&#x2F; 否则，就返回  年-月-日 时：分：秒</span><br><span class=\"line\"></span><br><span class=\"line\">      if (pattern.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;yyyy-mm-dd&#39;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;&#96;;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 获取时分秒</span><br><span class=\"line\"></span><br><span class=\"line\">        var hh &#x3D; dt.getHours().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">        var mm &#x3D; dt.getMinutes().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">        var ss &#x3D; dt.getSeconds().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;&#96;;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；</p>\n</blockquote>\n<h3 id=\"全局过滤器\"><a href=\"#全局过滤器\" class=\"headerlink\" title=\"全局过滤器\"></a>全局过滤器</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 定义一个全局过滤器</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.filter(&#39;dataFormat&#39;, function (input, pattern &#x3D; &#39;&#39;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var dt &#x3D; new Date(input);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 获取年月日</span><br><span class=\"line\"></span><br><span class=\"line\">  var y &#x3D; dt.getFullYear();</span><br><span class=\"line\"></span><br><span class=\"line\">  var m &#x3D; (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">  var d &#x3D; dt.getDate().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 否则，就返回  年-月-日 时：分：秒</span><br><span class=\"line\"></span><br><span class=\"line\">  if (pattern.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;yyyy-mm-dd&#39;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;&#96;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 获取时分秒</span><br><span class=\"line\"></span><br><span class=\"line\">    var hh &#x3D; dt.getHours().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var mm &#x3D; dt.getMinutes().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var ss &#x3D; dt.getSeconds().toString().padStart(2, &#39;0&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;&#96;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p>\n</blockquote>\n<h2 id=\"键盘修饰符以及自定义键盘修饰符\"><a href=\"#键盘修饰符以及自定义键盘修饰符\" class=\"headerlink\" title=\"键盘修饰符以及自定义键盘修饰符\"></a>键盘修饰符以及自定义键盘修饰符</h2><h3 id=\"1-x中自定义键盘修饰符【了解即可】\"><a href=\"#1-x中自定义键盘修饰符【了解即可】\" class=\"headerlink\" title=\"1.x中自定义键盘修饰符【了解即可】\"></a>1.x中自定义键盘修饰符【了解即可】</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Vue.directive(&#39;on&#39;).keyCodes.f2 &#x3D; 113;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-x中自定义键盘修饰符\"><a href=\"#2-x中自定义键盘修饰符\" class=\"headerlink\" title=\"2.x中自定义键盘修饰符\"></a><a href=\"https://cn.vuejs.org/v2/guide/events.html#%E9%94%AE%E5%80%BC%E4%BF%AE%E9%A5%B0%E7%AC%A6\">2.x中自定义键盘修饰符</a></h3><ol>\n<li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Vue.config.keyCodes.f2 &#x3D; 113;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用自定义的按键修饰符：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;name&quot; @keyup.f2&#x3D;&quot;add&quot;&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a><a href=\"https://cn.vuejs.org/v2/guide/custom-directive.html\">自定义指令</a></h2><ol>\n<li>自定义全局和局部的 自定义指令：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 自定义全局指令 v-focus，为绑定的元素自动获取焦点：</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.directive(&#39;focus&#39;, &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  inserted: function (el) &#123; &#x2F;&#x2F; inserted 表示被绑定元素插入父节点时调用</span><br><span class=\"line\"></span><br><span class=\"line\">    el.focus();</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：</span><br><span class=\"line\"></span><br><span class=\"line\">  directives: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    color: &#123; &#x2F;&#x2F; 为元素设置指定的字体颜色</span><br><span class=\"line\"></span><br><span class=\"line\">      bind(el, binding) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        el.style.color &#x3D; binding.value;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    &#39;font-weight&#39;: function (el, binding2) &#123; &#x2F;&#x2F; 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数</span><br><span class=\"line\"></span><br><span class=\"line\">      el.style.fontWeight &#x3D; binding2.value;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>自定义指令的使用方式：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;searchName&quot; v-focus v-color&#x3D;&quot;&#39;red&#39;&quot; v-font-weight&#x3D;&quot;900&quot;&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Vue-1-x-中-自定义元素指令【已废弃-了解即可】\"><a href=\"#Vue-1-x-中-自定义元素指令【已废弃-了解即可】\" class=\"headerlink\" title=\"Vue 1.x 中 自定义元素指令【已废弃,了解即可】\"></a>Vue 1.x 中 自定义元素指令【已废弃,了解即可】</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.elementDirective(&#39;red-color&#39;, &#123;</span><br><span class=\"line\">  bind: function () &#123;</span><br><span class=\"line\">    this.el.style.color &#x3D; &#39;red&#39;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;red-color&gt;1232&lt;&#x2F;red-color&gt;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"vue实例的生命周期\"><a href=\"#vue实例的生命周期\" class=\"headerlink\" title=\"vue实例的生命周期\"></a><a href=\"https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">vue实例的生命周期</a></h2><ul>\n<li>什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\">生命周期钩子</a>：就是生命周期事件的别名而已；</li>\n<li>生命周期钩子 = 生命周期函数 = 生命周期事件</li>\n<li>主要的生命周期函数分类：</li>\n</ul>\n<ul>\n<li>创建期间的生命周期函数：<ul>\n<li>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li>\n<li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</li>\n<li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li>\n<li>mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</li>\n</ul>\n</li>\n<li>运行期间的生命周期函数：<ul>\n<li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li>\n<li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li>\n</ul>\n</li>\n<li>销毁期间的生命周期函数：<ul>\n<li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li>\n<li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<br><img src=\"https://user-images.githubusercontent.com/28568478/116815239-3b63c780-ab8f-11eb-9453-11e40b354c4e.png\" alt=\"lifecycle\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"vue-resource-实现-get-post-jsonp请求\"><a href=\"#vue-resource-实现-get-post-jsonp请求\" class=\"headerlink\" title=\"vue-resource 实现 get, post, jsonp请求\"></a><a href=\"https://github.com/pagekit/vue-resource\">vue-resource 实现 get, post, jsonp请求</a></h2><p>除了 vue-resource 之外，还可以使用 <code>axios</code> 的第三方包实现实现数据的请求</p>\n<ol>\n<li>之前的学习中，如何发起数据请求？</li>\n<li>常见的数据请求类型？  get  post jsonp</li>\n<li>测试的URL请求资源地址：</li>\n</ol>\n<ul>\n<li>get请求地址： <a href=\"http://vue.studyit.io/api/getlunbo\">http://vue.studyit.io/api/getlunbo</a></li>\n<li>post请求地址：<a href=\"http://vue.studyit.io/api/post\">http://vue.studyit.io/api/post</a></li>\n<li>jsonp请求地址：<a href=\"http://vue.studyit.io/api/jsonp\">http://vue.studyit.io/api/jsonp</a></li>\n</ul>\n<ol start=\"4\">\n<li>JSONP的实现原理</li>\n</ol>\n<ul>\n<li>由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；</li>\n<li>可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；</li>\n<li>具体实现过程：<ul>\n<li>先在客户端定义一个回调方法，预定义对数据的操作；</li>\n<li>再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口；</li>\n<li>服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行；</li>\n<li>客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；</li>\n</ul>\n</li>\n<li>带大家通过 Node.js ，来手动实现一个JSONP的请求例子；<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const http &#x3D; require(&#39;http&#39;);</span><br><span class=\"line\">&#x2F;&#x2F; 导入解析 URL 地址的核心模块</span><br><span class=\"line\">const urlModule &#x3D; require(&#39;url&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">const server &#x3D; http.createServer();</span><br><span class=\"line\">&#x2F;&#x2F; 监听 服务器的 request 请求事件，处理每个请求</span><br><span class=\"line\">server.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class=\"line\">  const url &#x3D; req.url;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 解析客户端请求的URL地址</span><br><span class=\"line\">  var info &#x3D; urlModule.parse(url, true);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 如果请求的 URL 地址是 &#x2F;getjsonp ，则表示要获取JSONP类型的数据</span><br><span class=\"line\">  if (info.pathname &#x3D;&#x3D;&#x3D; &#39;&#x2F;getjsonp&#39;) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 获取客户端指定的回调函数的名称</span><br><span class=\"line\">    var cbName &#x3D; info.query.callback;</span><br><span class=\"line\">    &#x2F;&#x2F; 手动拼接要返回给客户端的数据对象</span><br><span class=\"line\">    var data &#x3D; &#123;</span><br><span class=\"line\">      name: &#39;zs&#39;,</span><br><span class=\"line\">      age: 22,</span><br><span class=\"line\">      gender: &#39;男&#39;,</span><br><span class=\"line\">      hobby: [&#39;吃饭&#39;, &#39;睡觉&#39;, &#39;运动&#39;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法：</span><br><span class=\"line\">    var result &#x3D; &#96;$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)&#96;;</span><br><span class=\"line\">    &#x2F;&#x2F; 将拼接好的方法的调用，返回给客户端去解析执行</span><br><span class=\"line\">    res.end(result);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    res.end(&#39;404&#39;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(3000, () &#x3D;&gt; &#123;</span><br><span class=\"line\">  console.log(&#39;server running at http:&#x2F;&#x2F;127.0.0.1:3000&#39;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"5\">\n<li>vue-resource 的配置步骤：</li>\n</ol>\n<ul>\n<li>直接在页面中，通过<code>script</code>标签，引入 <code>vue-resource</code> 的脚本文件；</li>\n<li>注意：引用的先后顺序是：先引用 <code>Vue</code> 的脚本文件，再引用 <code>vue-resource</code> 的脚本文件；</li>\n</ul>\n<ol start=\"6\">\n<li>发送get请求：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getInfo() &#123; &#x2F;&#x2F; get 方式获取数据</span><br><span class=\"line\">  this.$http.get(&#39;http:&#x2F;&#x2F;127.0.0.1:8899&#x2F;api&#x2F;getlunbo&#39;).then(res &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(res.body);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>发送post请求：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">postInfo() &#123;</span><br><span class=\"line\">  var url &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8899&#x2F;api&#x2F;post&#39;;</span><br><span class=\"line\">  &#x2F;&#x2F; post 方法接收三个参数：</span><br><span class=\"line\">  &#x2F;&#x2F; 参数1： 要请求的URL地址</span><br><span class=\"line\">  &#x2F;&#x2F; 参数2： 要发送的数据对象</span><br><span class=\"line\">  &#x2F;&#x2F; 参数3： 指定post提交的编码类型为 application&#x2F;x-www-form-urlencoded</span><br><span class=\"line\">  this.$http.post(url, &#123; name: &#39;zs&#39; &#125;, &#123; emulateJSON: true &#125;).then(res &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(res.body);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>发送JSONP请求获取数据：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">jsonpInfo() &#123; &#x2F;&#x2F; JSONP形式从服务器获取数据</span><br><span class=\"line\">  var url &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8899&#x2F;api&#x2F;jsonp&#39;;</span><br><span class=\"line\">  this.$http.jsonp(url).then(res &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(res.body);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"配置本地数据库和数据接口API\"><a href=\"#配置本地数据库和数据接口API\" class=\"headerlink\" title=\"配置本地数据库和数据接口API\"></a>配置本地数据库和数据接口API</h2><ol>\n<li>先解压安装 <code>PHPStudy</code>;</li>\n<li>解压安装 <code>Navicat</code> 这个数据库可视化工具，并激活；</li>\n<li>打开 <code>Navicat</code> 工具，新建空白数据库，名为 <code>dtcmsdb4</code>;</li>\n<li>双击新建的数据库，连接上这个空白数据库，在新建的数据库上<code>右键</code> -&gt; <code>运行SQL文件</code>，选择并执行 <code>dtcmsdb4.sql</code> 这个数据库脚本文件；如果执行不报错，则数据库导入完成；</li>\n<li>进入文件夹 <code>vuecms3_nodejsapi</code> 内部，执行 <code>npm i</code> 安装所有的依赖项；</li>\n<li>先确保本机安装了 <code>nodemon</code>, 没有安装，则运行 <code>npm i nodemon -g</code> 进行全局安装，安装完毕后，进入到 <code>vuecms3_nodejsapi</code>目录 -&gt; <code>src</code>目录 -&gt; 双击运行 <code>start.bat</code></li>\n<li>如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 <code>app.js</code> 中第 <code>14行</code> 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root</li>\n</ol>\n<h2 id=\"品牌管理改造\"><a href=\"#品牌管理改造\" class=\"headerlink\" title=\"品牌管理改造\"></a>品牌管理改造</h2><h3 id=\"展示品牌列表\"><a href=\"#展示品牌列表\" class=\"headerlink\" title=\"展示品牌列表\"></a>展示品牌列表</h3><h3 id=\"添加品牌数据\"><a href=\"#添加品牌数据\" class=\"headerlink\" title=\"添加品牌数据\"></a>添加品牌数据</h3><h3 id=\"删除品牌数据\"><a href=\"#删除品牌数据\" class=\"headerlink\" title=\"删除品牌数据\"></a>删除品牌数据</h3><h2 id=\"Vue中的动画\"><a href=\"#Vue中的动画\" class=\"headerlink\" title=\"Vue中的动画\"></a><a href=\"https://cn.vuejs.org/v2/guide/transitions.html\">Vue中的动画</a></h2><p>为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；</p>\n<h3 id=\"使用过渡类名\"><a href=\"#使用过渡类名\" class=\"headerlink\" title=\"使用过渡类名\"></a>使用过渡类名</h3><ol>\n<li>HTML结构：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;动起来&quot; @click&#x3D;&quot;myAnimate&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt;</span><br><span class=\"line\">    &lt;transition name&#x3D;&quot;fade&quot;&gt;</span><br><span class=\"line\">      &lt;div v-show&#x3D;&quot;isshow&quot;&gt;动画哦&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;&#x2F;transition&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>\n<li>VM 实例：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#app&#39;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    isshow: false</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    myAnimate() &#123;</span><br><span class=\"line\">      this.isshow &#x3D; !this.isshow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>定义两组类样式：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;* 定义进入和离开时候的过渡状态 *&#x2F;</span><br><span class=\"line\">    .fade-enter-active,</span><br><span class=\"line\">    .fade-leave-active &#123;</span><br><span class=\"line\">      transition: all 0.2s ease;</span><br><span class=\"line\">      position: absolute;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* 定义进入过渡的开始状态 和 离开过渡的结束状态 *&#x2F;</span><br><span class=\"line\">    .fade-enter,</span><br><span class=\"line\">    .fade-leave-to &#123;</span><br><span class=\"line\">      opacity: 0;</span><br><span class=\"line\">      transform: translateX(100px);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"使用第三方-CSS-动画库\"><a href=\"#使用第三方-CSS-动画库\" class=\"headerlink\" title=\"使用第三方 CSS 动画库\"></a><a href=\"https://cn.vuejs.org/v2/guide/transitions.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%B8%A1%E7%B1%BB%E5%90%8D\">使用第三方 CSS 动画库</a></h3><ol>\n<li>导入动画类库：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;.&#x2F;lib&#x2F;animate.css&quot;&gt;</span><br></pre></td></tr></table></figure></li>\n<li>定义 transition 及属性：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;transition</span><br><span class=\"line\">\tenter-active-class&#x3D;&quot;fadeInRight&quot;</span><br><span class=\"line\">    leave-active-class&#x3D;&quot;fadeOutRight&quot;</span><br><span class=\"line\">    :duration&#x3D;&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;</span><br><span class=\"line\">  \t&lt;div class&#x3D;&quot;animated&quot; v-show&#x3D;&quot;isshow&quot;&gt;动画哦&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;transition&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"使用动画钩子函数\"><a href=\"#使用动画钩子函数\" class=\"headerlink\" title=\"使用动画钩子函数\"></a>使用动画钩子函数</h3><ol>\n<li>定义 transition 组件以及三个钩子函数：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;切换动画&quot; @click&#x3D;&quot;isshow &#x3D; !isshow&quot;&gt;</span><br><span class=\"line\">    &lt;transition</span><br><span class=\"line\">    @before-enter&#x3D;&quot;beforeEnter&quot;</span><br><span class=\"line\">    @enter&#x3D;&quot;enter&quot;</span><br><span class=\"line\">    @after-enter&#x3D;&quot;afterEnter&quot;&gt;</span><br><span class=\"line\">      &lt;div v-if&#x3D;&quot;isshow&quot; class&#x3D;&quot;show&quot;&gt;OK&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;&#x2F;transition&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>\n<li>定义三个 methods 钩子方法：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">        beforeEnter(el) &#123; &#x2F;&#x2F; 动画进入之前的回调</span><br><span class=\"line\">          el.style.transform &#x3D; &#39;translateX(500px)&#39;;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        enter(el, done) &#123; &#x2F;&#x2F; 动画进入完成时候的回调</span><br><span class=\"line\">          el.offsetWidth;</span><br><span class=\"line\">          el.style.transform &#x3D; &#39;translateX(0px)&#39;;</span><br><span class=\"line\">          done();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        afterEnter(el) &#123; &#x2F;&#x2F; 动画进入完成之后的回调</span><br><span class=\"line\">          this.isshow &#x3D; !this.isshow;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></li>\n<li>定义动画过渡时长和样式：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.show&#123;</span><br><span class=\"line\">      transition: all 0.4s ease;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"v-for-的列表过渡\"><a href=\"#v-for-的列表过渡\" class=\"headerlink\" title=\"v-for 的列表过渡\"></a><a href=\"https://cn.vuejs.org/v2/guide/transitions.html#%E5%88%97%E8%A1%A8%E7%9A%84%E8%BF%9B%E5%85%A5%E5%92%8C%E7%A6%BB%E5%BC%80%E8%BF%87%E6%B8%A1\">v-for 的列表过渡</a></h3><ol>\n<li>定义过渡样式：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .list-enter,</span><br><span class=\"line\">    .list-leave-to &#123;</span><br><span class=\"line\">      opacity: 0;</span><br><span class=\"line\">      transform: translateY(10px);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    .list-enter-active,</span><br><span class=\"line\">    .list-leave-active &#123;</span><br><span class=\"line\">      transition: all 0.3s ease;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>\n<li>定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;txt&quot; @keyup.enter&#x3D;&quot;add&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;transition-group tag&#x3D;&quot;ul&quot; name&#x3D;&quot;list&quot;&gt;</span><br><span class=\"line\">    &lt;li v-for&#x3D;&quot;(item, i) in list&quot; :key&#x3D;&quot;i&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class=\"line\">  &lt;&#x2F;transition-group&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>\n<li>定义 VM中的结构：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#app&#39;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    txt: &#39;&#39;,</span><br><span class=\"line\">    list: [1, 2, 3, 4]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    add() &#123;</span><br><span class=\"line\">      this.list.push(this.txt);</span><br><span class=\"line\">      this.txt &#x3D; &#39;&#39;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"列表的排序过渡\"><a href=\"#列表的排序过渡\" class=\"headerlink\" title=\"列表的排序过渡\"></a>列表的排序过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，<strong>还可以改变定位</strong>。要使用这个新功能只需了解新增的 <code>v-move</code> 特性，<strong>它会在元素的改变定位的过程中应用</strong>。</p>\n<ul>\n<li><code>v-move</code> 和 <code>v-leave-active</code> 结合使用，能够让列表的过渡更加平缓柔和：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.v-move&#123;</span><br><span class=\"line\">  transition: all 0.8s ease;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.v-leave-active&#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h2><ol>\n<li><a href=\"https://v1-cn.vuejs.org/\">vue.js 1.x 文档</a></li>\n<li><a href=\"https://cn.vuejs.org/\">vue.js 2.x 文档</a></li>\n<li><a href=\"http://www.css88.com/archives/7715\">String.prototype.padStart(maxLength, fillString)</a></li>\n<li><a href=\"http://www.cnblogs.com/wuhua1/p/6686237.html\">js 里面的键盘事件对应的键码</a></li>\n<li><a href=\"https://github.com/pagekit/vue-resource\">pagekit/vue-resource</a></li>\n<li><a href=\"https://jingyan.baidu.com/article/a65957f4976aad24e67f9b9b.html\">navicat如何导入sql文件和导出sql文件</a></li>\n<li><a href=\"http://cubic-bezier.com/#.4,-0.3,1,.33\">贝塞尔在线生成器</a></li>\n</ol>\n","categories":["vue2.0基础课程"],"tags":["vue","vue2.0基础课程"]},{"title":"Vue.js - Day3","url":"/2021/05/04/vue/vue2.0%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/day3/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 id=\"Vue-js-Day3\"><a href=\"#Vue-js-Day3\" class=\"headerlink\" title=\"Vue.js - Day3\"></a>Vue.js - Day3</h1><h2 id=\"定义Vue组件\"><a href=\"#定义Vue组件\" class=\"headerlink\" title=\"定义Vue组件\"></a>定义Vue组件</h2><p>什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p>\n<ul>\n<li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li>\n<li>组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；<h3 id=\"全局组件定义的三种方式\"><a href=\"#全局组件定义的三种方式\" class=\"headerlink\" title=\"全局组件定义的三种方式\"></a>全局组件定义的三种方式</h3></li>\n</ul>\n<ol>\n<li>使用 Vue.extend 配合 Vue.component 方法：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var login &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">      template: &#39;&lt;h1&gt;登录&lt;&#x2F;h1&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Vue.component(&#39;login&#39;, login);</span><br></pre></td></tr></table></figure></li>\n<li>直接使用 Vue.component 方法：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.component(&#39;register&#39;, &#123;</span><br><span class=\"line\">      template: &#39;&lt;h1&gt;注册&lt;&#x2F;h1&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></li>\n<li>将模板字符串，定义到script标签种：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script id&#x3D;&quot;tmpl&quot; type&#x3D;&quot;x-template&quot;&gt;</span><br><span class=\"line\">      &lt;div&gt;&lt;a href&#x3D;&quot;#&quot;&gt;登录&lt;&#x2F;a&gt; | &lt;a href&#x3D;&quot;#&quot;&gt;注册&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n同时，需要使用 Vue.component 来定义组件：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.component(&#39;account&#39;, &#123;</span><br><span class=\"line\">      template: &#39;#tmpl&#39;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p>注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！</p>\n</blockquote>\n<h3 id=\"组件中展示数据和响应事件\"><a href=\"#组件中展示数据和响应事件\" class=\"headerlink\" title=\"组件中展示数据和响应事件\"></a>组件中展示数据和响应事件</h3><ol>\n<li>在组件中，<code>data</code>需要被定义为一个方法，例如：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.component(&#39;account&#39;, &#123;</span><br><span class=\"line\">      template: &#39;#tmpl&#39;,</span><br><span class=\"line\">      data() &#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">          msg: &#39;大家好！&#39;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      methods:&#123;</span><br><span class=\"line\">        login()&#123;</span><br><span class=\"line\">          alert(&#39;点击了登录按钮&#39;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></li>\n<li>在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</li>\n</ol>\n<h3 id=\"【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象\"><a href=\"#【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象\" class=\"headerlink\" title=\"【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象\"></a>【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象</h3><ol>\n<li>通过计数器案例演示</li>\n</ol>\n<h3 id=\"使用components属性定义局部子组件\"><a href=\"#使用components属性定义局部子组件\" class=\"headerlink\" title=\"使用components属性定义局部子组件\"></a>使用<code>components</code>属性定义局部子组件</h3><ol>\n<li>组件实例定义方式：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;&#125;,</span><br><span class=\"line\">      methods: &#123;&#125;,</span><br><span class=\"line\">      components: &#123; &#x2F;&#x2F; 定义子组件</span><br><span class=\"line\">        account: &#123; &#x2F;&#x2F; account 组件</span><br><span class=\"line\">          template: &#39;&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;&lt;login&gt;&lt;&#x2F;login&gt;&lt;&#x2F;div&gt;&#39;, &#x2F;&#x2F; 在这里使用定义的子组件</span><br><span class=\"line\">          components: &#123; &#x2F;&#x2F; 定义子组件的子组件</span><br><span class=\"line\">            login: &#123; &#x2F;&#x2F; login 组件</span><br><span class=\"line\">              template: &quot;&lt;h3&gt;这是登录组件&lt;&#x2F;h3&gt;&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n<li>引用组件：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;account&gt;&lt;&#x2F;account&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"使用flag标识符结合v-if和v-else切换组件\"><a href=\"#使用flag标识符结合v-if和v-else切换组件\" class=\"headerlink\" title=\"使用flag标识符结合v-if和v-else切换组件\"></a>使用<code>flag</code>标识符结合<code>v-if</code>和<code>v-else</code>切换组件</h2><ol>\n<li>页面结构：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;toggle&quot; @click&#x3D;&quot;flag&#x3D;!flag&quot;&gt;</span><br><span class=\"line\">    &lt;my-com1 v-if&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;my-com1&gt;</span><br><span class=\"line\">    &lt;my-com2 v-else&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;my-com2&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>\n<li>Vue实例定义：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    Vue.component(&#39;myCom1&#39;, &#123;</span><br><span class=\"line\">      template: &#39;&lt;h3&gt;奔波霸&lt;&#x2F;h3&gt;&#39;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    Vue.component(&#39;myCom2&#39;, &#123;</span><br><span class=\"line\">      template: &#39;&lt;h3&gt;霸波奔&lt;&#x2F;h3&gt;&#39;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        flag: true</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      methods: &#123;&#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"使用-is属性来切换不同的子组件-并添加切换动画\"><a href=\"#使用-is属性来切换不同的子组件-并添加切换动画\" class=\"headerlink\" title=\"使用:is属性来切换不同的子组件,并添加切换动画\"></a>使用<code>:is</code>属性来切换不同的子组件,并添加切换动画</h2><ol>\n<li>组件实例定义方式：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 登录组件</span><br><span class=\"line\">  const login &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">    template: &#96;&lt;div&gt;</span><br><span class=\"line\">      &lt;h3&gt;登录组件&lt;&#x2F;h3&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;&#96;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  Vue.component(&#39;login&#39;, login);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 注册组件</span><br><span class=\"line\">  const register &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">    template: &#96;&lt;div&gt;</span><br><span class=\"line\">      &lt;h3&gt;注册组件&lt;&#x2F;h3&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;&#96;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  Vue.component(&#39;register&#39;, register);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">  var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">    el: &#39;#app&#39;,</span><br><span class=\"line\">    data: &#123; comName: &#39;login&#39; &#125;,</span><br><span class=\"line\">    methods: &#123;&#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></li>\n<li>使用<code>component</code>标签，来引用组件，并通过<code>:is</code>属性来指定要加载的组件：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;comName&#x3D;&#39;login&#39;&quot;&gt;登录&lt;&#x2F;a&gt;</span><br><span class=\"line\">  &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;comName&#x3D;&#39;register&#39;&quot;&gt;注册&lt;&#x2F;a&gt;</span><br><span class=\"line\">  &lt;hr&gt;</span><br><span class=\"line\">  &lt;transition mode&#x3D;&quot;out-in&quot;&gt;</span><br><span class=\"line\">    &lt;component :is&#x3D;&quot;comName&quot;&gt;&lt;&#x2F;component&gt;</span><br><span class=\"line\">  &lt;&#x2F;transition&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>\n<li>添加切换样式：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  .v-enter,</span><br><span class=\"line\">  .v-leave-to &#123;</span><br><span class=\"line\">    opacity: 0;</span><br><span class=\"line\">    transform: translateX(30px);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .v-enter-active,</span><br><span class=\"line\">  .v-leave-active &#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    transition: all 0.3s ease;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  h3&#123;</span><br><span class=\"line\">    margin: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"父组件向子组件传值\"><a href=\"#父组件向子组件传值\" class=\"headerlink\" title=\"父组件向子组件传值\"></a>父组件向子组件传值</h2><ol>\n<li>组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        msg: &#39;这是父组件中的消息&#39;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      components: &#123;</span><br><span class=\"line\">        son: &#123;</span><br><span class=\"line\">          template: &#39;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;&#x2F;h1&gt;&#39;,</span><br><span class=\"line\">          props: [&#39;finfo&#39;]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n<li>使用<code>v-bind</code>或简化指令，将数据传递到子组件中：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;son :finfo&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;son&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"子组件向父组件传值\"><a href=\"#子组件向父组件传值\" class=\"headerlink\" title=\"子组件向父组件传值\"></a>子组件向父组件传值</h2><ol>\n<li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li>\n<li>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt;</span><br></pre></td></tr></table></figure></li>\n<li>子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 引用父组件 --&gt;</span><br><span class=\"line\">    &lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 组件模板定义 --&gt;</span><br><span class=\"line\">    &lt;script type&#x3D;&quot;x-template&quot; id&#x3D;&quot;son&quot;&gt;</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;向父组件传值&quot; @click&#x3D;&quot;sendMsg&quot; &#x2F;&gt;</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    &#x2F;&#x2F; 子组件的定义方式</span><br><span class=\"line\">    Vue.component(&#39;son&#39;, &#123;</span><br><span class=\"line\">      template: &#39;#son&#39;, &#x2F;&#x2F; 组件模板Id</span><br><span class=\"line\">      methods: &#123;</span><br><span class=\"line\">        sendMsg() &#123; &#x2F;&#x2F; 按钮的点击事件</span><br><span class=\"line\">          this.$emit(&#39;func&#39;, &#39;OK&#39;); &#x2F;&#x2F; 调用父组件传递过来的方法，同时把数据传递出去</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;&#125;,</span><br><span class=\"line\">      methods: &#123;</span><br><span class=\"line\">        getMsg(val)&#123; &#x2F;&#x2F; 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义</span><br><span class=\"line\">          alert(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"评论列表案例\"><a href=\"#评论列表案例\" class=\"headerlink\" title=\"评论列表案例\"></a>评论列表案例</h2><p>目标：主要练习父子组件之间传值</p>\n<h2 id=\"使用-this-refs-来获取元素和组件\"><a href=\"#使用-this-refs-来获取元素和组件\" class=\"headerlink\" title=\"使用 this.$refs 来获取元素和组件\"></a>使用 <code>this.$refs</code> 来获取元素和组件</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;获取元素内容&quot; @click&#x3D;&quot;getElement&quot; &#x2F;&gt;</span><br><span class=\"line\">    &lt;!-- 使用 ref 获取元素 --&gt;</span><br><span class=\"line\">    &lt;h1 ref&#x3D;&quot;myh1&quot;&gt;这是一个大大的H1&lt;&#x2F;h1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;hr&gt;</span><br><span class=\"line\">    &lt;!-- 使用 ref 获取子组件 --&gt;</span><br><span class=\"line\">    &lt;my-com ref&#x3D;&quot;mycom&quot;&gt;&lt;&#x2F;my-com&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  Vue.component(&#39;my-com&#39;, &#123;</span><br><span class=\"line\">    template: &#39;&lt;h5&gt;这是一个子组件&lt;&#x2F;h5&gt;&#39;,</span><br><span class=\"line\">    data() &#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        name: &#39;子组件&#39;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">  var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">    el: &#39;#app&#39;,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">      getElement() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 通过 this.$refs 来获取元素</span><br><span class=\"line\">        console.log(this.$refs.myh1.innerText);</span><br><span class=\"line\">        &#x2F;&#x2F; 通过 this.$refs 来获取组件</span><br><span class=\"line\">        console.log(this.$refs.mycom.name);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"什么是路由\"><a href=\"#什么是路由\" class=\"headerlink\" title=\"什么是路由\"></a>什么是路由</h2><ol>\n<li><p>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</p>\n</li>\n<li><p>对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</p>\n</li>\n<li><p>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</p>\n</li>\n</ol>\n<h2 id=\"在-vue-中使用-vue-router\"><a href=\"#在-vue-中使用-vue-router\" class=\"headerlink\" title=\"在 vue 中使用 vue-router\"></a>在 vue 中使用 vue-router</h2><ol>\n<li>导入 vue-router 组件类库：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 1. 导入 vue-router 组件类库 --&gt;</span><br><span class=\"line\">  &lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;vue-router-2.7.0.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n<li>使用 router-link 组件来导航<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 2. 使用 router-link 组件来导航 --&gt;</span><br><span class=\"line\">&lt;router-link to&#x3D;&quot;&#x2F;login&quot;&gt;登录&lt;&#x2F;router-link&gt;</span><br><span class=\"line\">&lt;router-link to&#x3D;&quot;&#x2F;register&quot;&gt;注册&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure></li>\n<li>使用 router-view 组件来显示匹配到的组件<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;</span><br><span class=\"line\">&lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br></pre></td></tr></table></figure></li>\n<li>创建使用<code>Vue.extend</code>创建组件<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 4.1 使用 Vue.extend 来创建登录组件</span><br><span class=\"line\">var login &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">  template: &#39;&lt;h1&gt;登录组件&lt;&#x2F;h1&gt;&#39;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 4.2 使用 Vue.extend 来创建注册组件</span><br><span class=\"line\">var register &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">  template: &#39;&lt;h1&gt;注册组件&lt;&#x2F;h1&gt;&#39;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</span><br><span class=\"line\">    var router &#x3D; new VueRouter(&#123;</span><br><span class=\"line\">      routes: [</span><br><span class=\"line\">        &#123; path: &#39;&#x2F;login&#39;, component: login &#125;,</span><br><span class=\"line\">        &#123; path: &#39;&#x2F;register&#39;, component: register &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></li>\n<li>使用 router 属性来使用路由规则<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 6. 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      router: router &#x2F;&#x2F; 使用 router 属性来使用路由规则</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"设置路由高亮\"><a href=\"#设置路由高亮\" class=\"headerlink\" title=\"设置路由高亮\"></a>设置路由高亮</h2><h2 id=\"设置路由切换动效\"><a href=\"#设置路由切换动效\" class=\"headerlink\" title=\"设置路由切换动效\"></a>设置路由切换动效</h2><h2 id=\"在路由规则中定义参数\"><a href=\"#在路由规则中定义参数\" class=\"headerlink\" title=\"在路由规则中定义参数\"></a>在路由规则中定义参数</h2><ol>\n<li>在规则中定义参数：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; path: &#39;&#x2F;register&#x2F;:id&#39;, component: register &#125;</span><br></pre></td></tr></table></figure></li>\n<li>通过 <code>this.$route.params</code>来获取路由中的参数：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var register &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">      template: &#39;&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;&#x2F;h1&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"使用-children-属性实现路由嵌套\"><a href=\"#使用-children-属性实现路由嵌套\" class=\"headerlink\" title=\"使用 children 属性实现路由嵌套\"></a>使用 <code>children</code> 属性实现路由嵌套</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;router-link to&#x3D;&quot;&#x2F;account&quot;&gt;Account&lt;&#x2F;router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  &#x2F;&#x2F; 父路由中的组件</span><br><span class=\"line\">  const account &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">    template: &#96;&lt;div&gt;</span><br><span class=\"line\">      这是account组件</span><br><span class=\"line\">      &lt;router-link to&#x3D;&quot;&#x2F;account&#x2F;login&quot;&gt;login&lt;&#x2F;router-link&gt; |</span><br><span class=\"line\">      &lt;router-link to&#x3D;&quot;&#x2F;account&#x2F;register&quot;&gt;register&lt;&#x2F;router-link&gt;</span><br><span class=\"line\">      &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;&#96;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 子路由中的 login 组件</span><br><span class=\"line\">  const login &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">    template: &#39;&lt;div&gt;登录组件&lt;&#x2F;div&gt;&#39;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 子路由中的 register 组件</span><br><span class=\"line\">  const register &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">    template: &#39;&lt;div&gt;注册组件&lt;&#x2F;div&gt;&#39;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 路由实例</span><br><span class=\"line\">  var router &#x3D; new VueRouter(&#123;</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">      &#123; path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;account&#x2F;login&#39; &#125;, &#x2F;&#x2F; 使用 redirect 实现路由重定向</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#39;&#x2F;account&#39;,</span><br><span class=\"line\">        component: account,</span><br><span class=\"line\">        children: [ &#x2F;&#x2F; 通过 children 数组属性，来实现路由的嵌套</span><br><span class=\"line\">          &#123; path: &#39;login&#39;, component: login &#125;, &#x2F;&#x2F; 注意，子路由的开头位置，不要加 &#x2F; 路径符</span><br><span class=\"line\">          &#123; path: &#39;register&#39;, component: register &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">  var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">    el: &#39;#app&#39;,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    components: &#123;</span><br><span class=\"line\">      account</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    router: router</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"命名视图实现经典布局\"><a href=\"#命名视图实现经典布局\" class=\"headerlink\" title=\"命名视图实现经典布局\"></a>命名视图实现经典布局</h2><ol>\n<li>标签代码结构：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;content&quot;&gt;</span><br><span class=\"line\">      &lt;router-view name&#x3D;&quot;a&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">      &lt;router-view name&#x3D;&quot;b&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>\n<li>JS代码：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var header &#x3D; Vue.component(&#39;header&#39;, &#123;</span><br><span class=\"line\">      template: &#39;&lt;div class&#x3D;&quot;header&quot;&gt;header&lt;&#x2F;div&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var sidebar &#x3D; Vue.component(&#39;sidebar&#39;, &#123;</span><br><span class=\"line\">      template: &#39;&lt;div class&#x3D;&quot;sidebar&quot;&gt;sidebar&lt;&#x2F;div&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var mainbox &#x3D; Vue.component(&#39;mainbox&#39;, &#123;</span><br><span class=\"line\">      template: &#39;&lt;div class&#x3D;&quot;mainbox&quot;&gt;mainbox&lt;&#x2F;div&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建路由对象</span><br><span class=\"line\">    var router &#x3D; new VueRouter(&#123;</span><br><span class=\"line\">      routes: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path: &#39;&#x2F;&#39;, components: &#123;</span><br><span class=\"line\">            default: header,</span><br><span class=\"line\">            a: sidebar,</span><br><span class=\"line\">            b: mainbox</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;&#125;,</span><br><span class=\"line\">      methods: &#123;&#125;,</span><br><span class=\"line\">      router</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n<li>CSS 样式：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  .header &#123;</span><br><span class=\"line\">    border: 1px solid red;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .content&#123;</span><br><span class=\"line\">    display: flex;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .sidebar &#123;</span><br><span class=\"line\">    flex: 2;</span><br><span class=\"line\">    border: 1px solid green;</span><br><span class=\"line\">    height: 500px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .mainbox&#123;</span><br><span class=\"line\">    flex: 8;</span><br><span class=\"line\">    border: 1px solid blue;</span><br><span class=\"line\">    height: 500px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"watch属性的使用\"><a href=\"#watch属性的使用\" class=\"headerlink\" title=\"watch属性的使用\"></a><code>watch</code>属性的使用</h2><p>考虑一个问题：想要实现 <code>名</code> 和 <code>姓</code> 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）</p>\n<ol>\n<li>监听<code>data</code>中属性的改变：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt; +</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt; &#x3D;</span><br><span class=\"line\">    &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        firstName: &#39;jack&#39;,</span><br><span class=\"line\">        lastName: &#39;chen&#39;,</span><br><span class=\"line\">        fullName: &#39;jack - chen&#39;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      methods: &#123;&#125;,</span><br><span class=\"line\">      watch: &#123;</span><br><span class=\"line\">        &#39;firstName&#39;: function (newVal, oldVal) &#123; &#x2F;&#x2F; 第一个参数是新数据，第二个参数是旧数据</span><br><span class=\"line\">          this.fullName &#x3D; newVal + &#39; - &#39; + this.lastName;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#39;lastName&#39;: function (newVal, oldVal) &#123;</span><br><span class=\"line\">          this.fullName &#x3D; this.firstName + &#39; - &#39; + newVal;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n<li>监听路由对象的改变：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;router-link to&#x3D;&quot;&#x2F;login&quot;&gt;登录&lt;&#x2F;router-link&gt;</span><br><span class=\"line\">    &lt;router-link to&#x3D;&quot;&#x2F;register&quot;&gt;注册&lt;&#x2F;router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    var login &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">      template: &#39;&lt;h1&gt;登录组件&lt;&#x2F;h1&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var register &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">      template: &#39;&lt;h1&gt;注册组件&lt;&#x2F;h1&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var router &#x3D; new VueRouter(&#123;</span><br><span class=\"line\">      routes: [</span><br><span class=\"line\">        &#123; path: &quot;&#x2F;login&quot;, component: login &#125;,</span><br><span class=\"line\">        &#123; path: &quot;&#x2F;register&quot;, component: register &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;&#125;,</span><br><span class=\"line\">      methods: &#123;&#125;,</span><br><span class=\"line\">      router: router,</span><br><span class=\"line\">      watch: &#123;</span><br><span class=\"line\">        &#39;$route&#39;: function (newVal, oldVal) &#123;</span><br><span class=\"line\">          if (newVal.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class=\"line\">            console.log(&#39;这是登录组件&#39;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"computed计算属性的使用\"><a href=\"#computed计算属性的使用\" class=\"headerlink\" title=\"computed计算属性的使用\"></a><code>computed</code>计算属性的使用</h2><ol>\n<li>默认只有<code>getter</code>的计算属性：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt; +</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt; &#x3D;</span><br><span class=\"line\">    &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        firstName: &#39;jack&#39;,</span><br><span class=\"line\">        lastName: &#39;chen&#39;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      methods: &#123;&#125;,</span><br><span class=\"line\">      computed: &#123; &#x2F;&#x2F; 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值</span><br><span class=\"line\">        fullName() &#123;</span><br><span class=\"line\">          return this.firstName + &#39; - &#39; + this.lastName;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n<li>定义有<code>getter</code>和<code>setter</code>的计算属性：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;修改fullName&quot; @click&#x3D;&quot;changeName&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        firstName: &#39;jack&#39;,</span><br><span class=\"line\">        lastName: &#39;chen&#39;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      methods: &#123;</span><br><span class=\"line\">        changeName() &#123;</span><br><span class=\"line\">          this.fullName &#x3D; &#39;TOM - chen2&#39;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      computed: &#123;</span><br><span class=\"line\">        fullName: &#123;</span><br><span class=\"line\">          get: function () &#123;</span><br><span class=\"line\">            return this.firstName + &#39; - &#39; + this.lastName;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          set: function (newVal) &#123;</span><br><span class=\"line\">            var parts &#x3D; newVal.split(&#39; - &#39;);</span><br><span class=\"line\">            this.firstName &#x3D; parts[0];</span><br><span class=\"line\">            this.lastName &#x3D; parts[1];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"watch、computed和methods之间的对比\"><a href=\"#watch、computed和methods之间的对比\" class=\"headerlink\" title=\"watch、computed和methods之间的对比\"></a><code>watch</code>、<code>computed</code>和<code>methods</code>之间的对比</h2><ol>\n<li><code>computed</code>属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；</li>\n<li><code>methods</code>方法表示一个具体的操作，主要书写业务逻辑；</li>\n<li><code>watch</code>一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是<code>computed</code>和<code>methods</code>的结合体；</li>\n</ol>\n<h2 id=\"nrm的安装使用\"><a href=\"#nrm的安装使用\" class=\"headerlink\" title=\"nrm的安装使用\"></a><code>nrm</code>的安装使用</h2><p>作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；<br>什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；</p>\n<ol>\n<li>运行<code>npm i nrm -g</code>全局安装<code>nrm</code>包；</li>\n<li>使用<code>nrm ls</code>查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；</li>\n<li>使用<code>nrm use npm</code>或<code>nrm use taobao</code>切换不同的镜像源地址；</li>\n</ol>\n<h2 id=\"相关文件\"><a href=\"#相关文件\" class=\"headerlink\" title=\"相关文件\"></a>相关文件</h2><ol>\n<li><a href=\"http://www.cnblogs.com/joyho/articles/4430148.html\">URL中的hash（井号）</a></li>\n</ol>\n","categories":["vue2.0基础课程"],"tags":["vue","vue2.0基础课程"]},{"title":"Vue.js - Day4","url":"/2021/05/04/vue/vue2.0%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/day4/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 id=\"Vue-js-Day4\"><a href=\"#Vue-js-Day4\" class=\"headerlink\" title=\"Vue.js - Day4\"></a>Vue.js - Day4</h1><h2 id=\"父组件向子组件传值\"><a href=\"#父组件向子组件传值\" class=\"headerlink\" title=\"父组件向子组件传值\"></a>父组件向子组件传值</h2><ol>\n<li>组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        msg: &#39;这是父组件中的消息&#39;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      components: &#123;</span><br><span class=\"line\">        son: &#123;</span><br><span class=\"line\">          template: &#39;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;&#x2F;h1&gt;&#39;,</span><br><span class=\"line\">          props: [&#39;finfo&#39;]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n<li>使用<code>v-bind</code>或简化指令，将数据传递到子组件中：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;son :finfo&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;son&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"子组件向父组件传值\"><a href=\"#子组件向父组件传值\" class=\"headerlink\" title=\"子组件向父组件传值\"></a>子组件向父组件传值</h2><ol>\n<li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li>\n<li>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt;</span><br></pre></td></tr></table></figure></li>\n<li>子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 引用父组件 --&gt;</span><br><span class=\"line\">    &lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 组件模板定义 --&gt;</span><br><span class=\"line\">    &lt;script type&#x3D;&quot;x-template&quot; id&#x3D;&quot;son&quot;&gt;</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;向父组件传值&quot; @click&#x3D;&quot;sendMsg&quot; &#x2F;&gt;</span><br><span class=\"line\">      &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    &#x2F;&#x2F; 子组件的定义方式</span><br><span class=\"line\">    Vue.component(&#39;son&#39;, &#123;</span><br><span class=\"line\">      template: &#39;#son&#39;, &#x2F;&#x2F; 组件模板Id</span><br><span class=\"line\">      methods: &#123;</span><br><span class=\"line\">        sendMsg() &#123; &#x2F;&#x2F; 按钮的点击事件</span><br><span class=\"line\">          this.$emit(&#39;func&#39;, &#39;OK&#39;); &#x2F;&#x2F; 调用父组件传递过来的方法，同时把数据传递出去</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;&#125;,</span><br><span class=\"line\">      methods: &#123;</span><br><span class=\"line\">        getMsg(val)&#123; &#x2F;&#x2F; 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义</span><br><span class=\"line\">          alert(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"组件中data和props的区别\"><a href=\"#组件中data和props的区别\" class=\"headerlink\" title=\"组件中data和props的区别\"></a>组件中data和props的区别</h2><h2 id=\"评论列表案例\"><a href=\"#评论列表案例\" class=\"headerlink\" title=\"评论列表案例\"></a>评论列表案例</h2><p>目标：主要练习父子组件之间传值</p>\n<h2 id=\"使用-this-refs-来获取元素和组件\"><a href=\"#使用-this-refs-来获取元素和组件\" class=\"headerlink\" title=\"使用 this.$refs 来获取元素和组件\"></a>使用 <code>this.$refs</code> 来获取元素和组件</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;获取元素内容&quot; @click&#x3D;&quot;getElement&quot; &#x2F;&gt;</span><br><span class=\"line\">    &lt;!-- 使用 ref 获取元素 --&gt;</span><br><span class=\"line\">    &lt;h1 ref&#x3D;&quot;myh1&quot;&gt;这是一个大大的H1&lt;&#x2F;h1&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;hr&gt;</span><br><span class=\"line\">    &lt;!-- 使用 ref 获取子组件 --&gt;</span><br><span class=\"line\">    &lt;my-com ref&#x3D;&quot;mycom&quot;&gt;&lt;&#x2F;my-com&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  Vue.component(&#39;my-com&#39;, &#123;</span><br><span class=\"line\">    template: &#39;&lt;h5&gt;这是一个子组件&lt;&#x2F;h5&gt;&#39;,</span><br><span class=\"line\">    data() &#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        name: &#39;子组件&#39;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">  var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">    el: &#39;#app&#39;,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">      getElement() &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 通过 this.$refs 来获取元素</span><br><span class=\"line\">        console.log(this.$refs.myh1.innerText);</span><br><span class=\"line\">        &#x2F;&#x2F; 通过 this.$refs 来获取组件</span><br><span class=\"line\">        console.log(this.$refs.mycom.name);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"什么是路由\"><a href=\"#什么是路由\" class=\"headerlink\" title=\"什么是路由\"></a>什么是路由</h2><ol>\n<li><p><strong>后端路由：</strong>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</p>\n</li>\n<li><p><strong>前端路由：</strong>对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</p>\n</li>\n<li><p>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</p>\n</li>\n</ol>\n<h2 id=\"在-vue-中使用-vue-router\"><a href=\"#在-vue-中使用-vue-router\" class=\"headerlink\" title=\"在 vue 中使用 vue-router\"></a>在 vue 中使用 vue-router</h2><ol>\n<li>导入 vue-router 组件类库：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 1. 导入 vue-router 组件类库 --&gt;</span><br><span class=\"line\">  &lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;vue-router-2.7.0.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n<li>使用 router-link 组件来导航<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 2. 使用 router-link 组件来导航 --&gt;</span><br><span class=\"line\">&lt;router-link to&#x3D;&quot;&#x2F;login&quot;&gt;登录&lt;&#x2F;router-link&gt;</span><br><span class=\"line\">&lt;router-link to&#x3D;&quot;&#x2F;register&quot;&gt;注册&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure></li>\n<li>使用 router-view 组件来显示匹配到的组件<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;</span><br><span class=\"line\">&lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br></pre></td></tr></table></figure></li>\n<li>创建使用<code>Vue.extend</code>创建组件<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 4.1 使用 Vue.extend 来创建登录组件</span><br><span class=\"line\">var login &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">  template: &#39;&lt;h1&gt;登录组件&lt;&#x2F;h1&gt;&#39;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 4.2 使用 Vue.extend 来创建注册组件</span><br><span class=\"line\">var register &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">  template: &#39;&lt;h1&gt;注册组件&lt;&#x2F;h1&gt;&#39;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</span><br><span class=\"line\">    var router &#x3D; new VueRouter(&#123;</span><br><span class=\"line\">      routes: [</span><br><span class=\"line\">        &#123; path: &#39;&#x2F;login&#39;, component: login &#125;,</span><br><span class=\"line\">        &#123; path: &#39;&#x2F;register&#39;, component: register &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></li>\n<li>使用 router 属性来使用路由规则<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 6. 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      router: router &#x2F;&#x2F; 使用 router 属性来使用路由规则</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"使用tag属性指定router-link渲染的标签类型\"><a href=\"#使用tag属性指定router-link渲染的标签类型\" class=\"headerlink\" title=\"使用tag属性指定router-link渲染的标签类型\"></a>使用tag属性指定router-link渲染的标签类型</h2><h2 id=\"设置路由重定向\"><a href=\"#设置路由重定向\" class=\"headerlink\" title=\"设置路由重定向\"></a>设置路由重定向</h2><h2 id=\"设置路由高亮\"><a href=\"#设置路由高亮\" class=\"headerlink\" title=\"设置路由高亮\"></a>设置路由高亮</h2><h2 id=\"设置路由切换动效\"><a href=\"#设置路由切换动效\" class=\"headerlink\" title=\"设置路由切换动效\"></a>设置路由切换动效</h2><h2 id=\"在路由规则中定义参数\"><a href=\"#在路由规则中定义参数\" class=\"headerlink\" title=\"在路由规则中定义参数\"></a>在路由规则中定义参数</h2><ol>\n<li>在规则中定义参数：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; path: &#39;&#x2F;register&#x2F;:id&#39;, component: register &#125;</span><br></pre></td></tr></table></figure></li>\n<li>通过 <code>this.$route.params</code>来获取路由中的参数：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var register &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">      template: &#39;&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;&#x2F;h1&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"使用-children-属性实现路由嵌套\"><a href=\"#使用-children-属性实现路由嵌套\" class=\"headerlink\" title=\"使用 children 属性实现路由嵌套\"></a>使用 <code>children</code> 属性实现路由嵌套</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;router-link to&#x3D;&quot;&#x2F;account&quot;&gt;Account&lt;&#x2F;router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  &#x2F;&#x2F; 父路由中的组件</span><br><span class=\"line\">  const account &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">    template: &#96;&lt;div&gt;</span><br><span class=\"line\">      这是account组件</span><br><span class=\"line\">      &lt;router-link to&#x3D;&quot;&#x2F;account&#x2F;login&quot;&gt;login&lt;&#x2F;router-link&gt; |</span><br><span class=\"line\">      &lt;router-link to&#x3D;&quot;&#x2F;account&#x2F;register&quot;&gt;register&lt;&#x2F;router-link&gt;</span><br><span class=\"line\">      &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;&#96;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 子路由中的 login 组件</span><br><span class=\"line\">  const login &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">    template: &#39;&lt;div&gt;登录组件&lt;&#x2F;div&gt;&#39;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 子路由中的 register 组件</span><br><span class=\"line\">  const register &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">    template: &#39;&lt;div&gt;注册组件&lt;&#x2F;div&gt;&#39;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 路由实例</span><br><span class=\"line\">  var router &#x3D; new VueRouter(&#123;</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">      &#123; path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;account&#x2F;login&#39; &#125;, &#x2F;&#x2F; 使用 redirect 实现路由重定向</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: &#39;&#x2F;account&#39;,</span><br><span class=\"line\">        component: account,</span><br><span class=\"line\">        children: [ &#x2F;&#x2F; 通过 children 数组属性，来实现路由的嵌套</span><br><span class=\"line\">          &#123; path: &#39;login&#39;, component: login &#125;, &#x2F;&#x2F; 注意，子路由的开头位置，不要加 &#x2F; 路径符</span><br><span class=\"line\">          &#123; path: &#39;register&#39;, component: register &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">  var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">    el: &#39;#app&#39;,</span><br><span class=\"line\">    data: &#123;&#125;,</span><br><span class=\"line\">    methods: &#123;&#125;,</span><br><span class=\"line\">    components: &#123;</span><br><span class=\"line\">      account</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    router: router</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"命名视图实现经典布局\"><a href=\"#命名视图实现经典布局\" class=\"headerlink\" title=\"命名视图实现经典布局\"></a>命名视图实现经典布局</h2><ol>\n<li>标签代码结构：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;content&quot;&gt;</span><br><span class=\"line\">      &lt;router-view name&#x3D;&quot;a&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">      &lt;router-view name&#x3D;&quot;b&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>\n<li>JS代码：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    var header &#x3D; Vue.component(&#39;header&#39;, &#123;</span><br><span class=\"line\">      template: &#39;&lt;div class&#x3D;&quot;header&quot;&gt;header&lt;&#x2F;div&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var sidebar &#x3D; Vue.component(&#39;sidebar&#39;, &#123;</span><br><span class=\"line\">      template: &#39;&lt;div class&#x3D;&quot;sidebar&quot;&gt;sidebar&lt;&#x2F;div&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var mainbox &#x3D; Vue.component(&#39;mainbox&#39;, &#123;</span><br><span class=\"line\">      template: &#39;&lt;div class&#x3D;&quot;mainbox&quot;&gt;mainbox&lt;&#x2F;div&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建路由对象</span><br><span class=\"line\">    var router &#x3D; new VueRouter(&#123;</span><br><span class=\"line\">      routes: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          path: &#39;&#x2F;&#39;, components: &#123;</span><br><span class=\"line\">            default: header,</span><br><span class=\"line\">            a: sidebar,</span><br><span class=\"line\">            b: mainbox</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;&#125;,</span><br><span class=\"line\">      methods: &#123;&#125;,</span><br><span class=\"line\">      router</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n<li>CSS 样式：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  .header &#123;</span><br><span class=\"line\">    border: 1px solid red;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .content&#123;</span><br><span class=\"line\">    display: flex;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .sidebar &#123;</span><br><span class=\"line\">    flex: 2;</span><br><span class=\"line\">    border: 1px solid green;</span><br><span class=\"line\">    height: 500px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .mainbox&#123;</span><br><span class=\"line\">    flex: 8;</span><br><span class=\"line\">    border: 1px solid blue;</span><br><span class=\"line\">    height: 500px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"watch属性的使用\"><a href=\"#watch属性的使用\" class=\"headerlink\" title=\"watch属性的使用\"></a><code>watch</code>属性的使用</h2><p>考虑一个问题：想要实现 <code>名</code> 和 <code>姓</code> 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）</p>\n<ol>\n<li>监听<code>data</code>中属性的改变：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt; +</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt; &#x3D;</span><br><span class=\"line\">    &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        firstName: &#39;jack&#39;,</span><br><span class=\"line\">        lastName: &#39;chen&#39;,</span><br><span class=\"line\">        fullName: &#39;jack - chen&#39;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      methods: &#123;&#125;,</span><br><span class=\"line\">      watch: &#123;</span><br><span class=\"line\">        &#39;firstName&#39;: function (newVal, oldVal) &#123; &#x2F;&#x2F; 第一个参数是新数据，第二个参数是旧数据</span><br><span class=\"line\">          this.fullName &#x3D; newVal + &#39; - &#39; + this.lastName;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#39;lastName&#39;: function (newVal, oldVal) &#123;</span><br><span class=\"line\">          this.fullName &#x3D; this.firstName + &#39; - &#39; + newVal;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n<li>监听路由对象的改变：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;router-link to&#x3D;&quot;&#x2F;login&quot;&gt;登录&lt;&#x2F;router-link&gt;</span><br><span class=\"line\">    &lt;router-link to&#x3D;&quot;&#x2F;register&quot;&gt;注册&lt;&#x2F;router-link&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    var login &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">      template: &#39;&lt;h1&gt;登录组件&lt;&#x2F;h1&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var register &#x3D; Vue.extend(&#123;</span><br><span class=\"line\">      template: &#39;&lt;h1&gt;注册组件&lt;&#x2F;h1&gt;&#39;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var router &#x3D; new VueRouter(&#123;</span><br><span class=\"line\">      routes: [</span><br><span class=\"line\">        &#123; path: &quot;&#x2F;login&quot;, component: login &#125;,</span><br><span class=\"line\">        &#123; path: &quot;&#x2F;register&quot;, component: register &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;&#125;,</span><br><span class=\"line\">      methods: &#123;&#125;,</span><br><span class=\"line\">      router: router,</span><br><span class=\"line\">      watch: &#123;</span><br><span class=\"line\">        &#39;$route&#39;: function (newVal, oldVal) &#123;</span><br><span class=\"line\">          if (newVal.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123;</span><br><span class=\"line\">            console.log(&#39;这是登录组件&#39;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"computed计算属性的使用\"><a href=\"#computed计算属性的使用\" class=\"headerlink\" title=\"computed计算属性的使用\"></a><code>computed</code>计算属性的使用</h2><ol>\n<li>默认只有<code>getter</code>的计算属性：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt; +</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt; &#x3D;</span><br><span class=\"line\">    &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        firstName: &#39;jack&#39;,</span><br><span class=\"line\">        lastName: &#39;chen&#39;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      methods: &#123;&#125;,</span><br><span class=\"line\">      computed: &#123; &#x2F;&#x2F; 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值</span><br><span class=\"line\">        fullName() &#123;</span><br><span class=\"line\">          return this.firstName + &#39; - &#39; + this.lastName;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n<li>定义有<code>getter</code>和<code>setter</code>的计算属性：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;修改fullName&quot; @click&#x3D;&quot;changeName&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel</span><br><span class=\"line\">    var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">      el: &#39;#app&#39;,</span><br><span class=\"line\">      data: &#123;</span><br><span class=\"line\">        firstName: &#39;jack&#39;,</span><br><span class=\"line\">        lastName: &#39;chen&#39;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      methods: &#123;</span><br><span class=\"line\">        changeName() &#123;</span><br><span class=\"line\">          this.fullName &#x3D; &#39;TOM - chen2&#39;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      computed: &#123;</span><br><span class=\"line\">        fullName: &#123;</span><br><span class=\"line\">          get: function () &#123;</span><br><span class=\"line\">            return this.firstName + &#39; - &#39; + this.lastName;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          set: function (newVal) &#123;</span><br><span class=\"line\">            var parts &#x3D; newVal.split(&#39; - &#39;);</span><br><span class=\"line\">            this.firstName &#x3D; parts[0];</span><br><span class=\"line\">            this.lastName &#x3D; parts[1];</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"watch、computed和methods之间的对比\"><a href=\"#watch、computed和methods之间的对比\" class=\"headerlink\" title=\"watch、computed和methods之间的对比\"></a><code>watch</code>、<code>computed</code>和<code>methods</code>之间的对比</h2><ol>\n<li><code>computed</code>属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；</li>\n<li><code>methods</code>方法表示一个具体的操作，主要书写业务逻辑；</li>\n<li><code>watch</code>一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是<code>computed</code>和<code>methods</code>的结合体；</li>\n</ol>\n<h2 id=\"nrm的安装使用\"><a href=\"#nrm的安装使用\" class=\"headerlink\" title=\"nrm的安装使用\"></a><code>nrm</code>的安装使用</h2><p>作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；<br>什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；</p>\n<ol>\n<li>运行<code>npm i nrm -g</code>全局安装<code>nrm</code>包；</li>\n<li>使用<code>nrm ls</code>查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；</li>\n<li>使用<code>nrm use npm</code>或<code>nrm use taobao</code>切换不同的镜像源地址；</li>\n</ol>\n<blockquote>\n<p>注意： nrm 只是单纯的提供了几个常用的 下载包的 URL地址，并能够让我们在 这几个 地址之间，很方便的进行切换，但是，我们每次装包的时候，使用的 装包工具，都是  npm</p>\n</blockquote>\n<blockquote>\n<p>npm i cnpm -g<br><a href=\"https://www.cnblogs.com/chase-star/p/10455703.html\">npm 和 cnpm 的区别，你真的搞懂了嘛</a></p>\n</blockquote>\n<h2 id=\"相关文件\"><a href=\"#相关文件\" class=\"headerlink\" title=\"相关文件\"></a>相关文件</h2><ol>\n<li><a href=\"http://www.cnblogs.com/joyho/articles/4430148.html\">URL中的hash（井号）</a></li>\n</ol>\n","categories":["vue2.0基础课程"],"tags":["vue","vue2.0基础课程"]},{"title":"Vue.js - Day5","url":"/2021/05/04/vue/vue2.0%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/day5/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 id=\"Vue-js-Day5-Webpack\"><a href=\"#Vue-js-Day5-Webpack\" class=\"headerlink\" title=\"Vue.js - Day5 - Webpack\"></a>Vue.js - Day5 - Webpack</h1><h2 id=\"在网页中会引用哪些常见的静态资源？\"><a href=\"#在网页中会引用哪些常见的静态资源？\" class=\"headerlink\" title=\"在网页中会引用哪些常见的静态资源？\"></a>在网页中会引用哪些常见的静态资源？</h2><ul>\n<li>JS</li>\n</ul>\n<ul>\n<li>.js  .jsx  .coffee  .ts（TypeScript  类 C# 语言）</li>\n</ul>\n<ul>\n<li>CSS</li>\n</ul>\n<ul>\n<li>.css  .less   .sass  .scss</li>\n</ul>\n<ul>\n<li>Images</li>\n</ul>\n<ul>\n<li>.jpg   .png   .gif   .bmp   .svg</li>\n</ul>\n<ul>\n<li>字体文件（Fonts）</li>\n</ul>\n<ul>\n<li>.svg   .ttf   .eot   .woff   .woff2</li>\n</ul>\n<ul>\n<li>模板文件</li>\n</ul>\n<ul>\n<li>.ejs   .jade  .vue【这是在webpack中定义组件的方式，推荐这么用】</li>\n</ul>\n<h2 id=\"网页中引入的静态资源多了以后有什么问题？？？\"><a href=\"#网页中引入的静态资源多了以后有什么问题？？？\" class=\"headerlink\" title=\"网页中引入的静态资源多了以后有什么问题？？？\"></a>网页中引入的静态资源多了以后有什么问题？？？</h2><ol>\n<li>网页加载速度慢， 因为 我们要发起很多的二次请求；</li>\n<li>要处理错综复杂的依赖关系</li>\n</ol>\n<h2 id=\"如何解决上述两个问题\"><a href=\"#如何解决上述两个问题\" class=\"headerlink\" title=\"如何解决上述两个问题\"></a>如何解决上述两个问题</h2><ol>\n<li>合并、压缩、精灵图、图片的Base64编码</li>\n<li>可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系；</li>\n</ol>\n<h2 id=\"什么是webpack\"><a href=\"#什么是webpack\" class=\"headerlink\" title=\"什么是webpack?\"></a>什么是webpack?</h2><p>webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；</p>\n<h2 id=\"如何完美实现上述的2种解决方案\"><a href=\"#如何完美实现上述的2种解决方案\" class=\"headerlink\" title=\"如何完美实现上述的2种解决方案\"></a>如何完美实现上述的2种解决方案</h2><ol>\n<li>使用Gulp， 是基于 task 任务的；</li>\n<li>使用Webpack， 是基于整个项目进行构建的；</li>\n</ol>\n<ul>\n<li>借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。</li>\n<li>根据官网的图片介绍webpack打包的过程</li>\n<li><a href=\"http://webpack.github.io/\">webpack官网</a></li>\n<li><a href=\"https://webpack.docschina.org/\">webpack中文文档</a></li>\n</ul>\n<h2 id=\"webpack安装的两种方式\"><a href=\"#webpack安装的两种方式\" class=\"headerlink\" title=\"webpack安装的两种方式\"></a>webpack安装的两种方式</h2><ol>\n<li>运行<code>npm i webpack -g</code>全局安装webpack，这样就能在全局使用webpack的命令</li>\n<li>在项目根目录中运行<code>npm i webpack --save-dev</code>安装到项目依赖中</li>\n</ol>\n<h2 id=\"初步使用webpack打包构建列表隔行变色案例\"><a href=\"#初步使用webpack打包构建列表隔行变色案例\" class=\"headerlink\" title=\"初步使用webpack打包构建列表隔行变色案例\"></a>初步使用webpack打包构建列表隔行变色案例</h2><ol>\n<li>运行<code>npm init</code>初始化项目，使用npm管理项目中的依赖包 (npm init -y 一键初始化) 自动生成package.json文件</li>\n<li>创建项目基本的目录结构 src:存放源代码  dist: 项目发布后的文件存放目录</li>\n<li>使用<code>cnpm i jquery --save</code>安装jquery类库 （npm i jquery -s） 安装包后自动生成node_modules文件夹，并把包安装到这个文件夹</li>\n<li>创建<code>main.js</code>并书写各行变色的代码逻辑：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 导入jquery类库</span><br><span class=\"line\">   import $ from &#39;jquery&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#x2F;&#x2F; 设置偶数行背景色，索引从0开始，0是偶数</span><br><span class=\"line\">   $(&#39;#list li:even&#39;).css(&#39;backgroundColor&#39;,&#39;lightblue&#39;);</span><br><span class=\"line\">   &#x2F;&#x2F; 设置奇数行背景色</span><br><span class=\"line\">   $(&#39;#list li:odd&#39;).css(&#39;backgroundColor&#39;,&#39;pink&#39;);</span><br></pre></td></tr></table></figure></li>\n<li>直接在页面上引用<code>main.js</code>会报错，因为浏览器不认识<code>import</code>这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；</li>\n<li>运行<code>webpack 入口文件路径 输出文件路径</code>对<code>main.js</code>进行处理：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">webpack src&#x2F;js&#x2F;main.js dist&#x2F;bundle.js</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"使用webpack的配置文件简化打包时候的命令\"><a href=\"#使用webpack的配置文件简化打包时候的命令\" class=\"headerlink\" title=\"使用webpack的配置文件简化打包时候的命令\"></a>使用webpack的配置文件简化打包时候的命令</h2><ol>\n<li>在项目根目录中创建<code>webpack.config.js</code></li>\n<li>由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在<code>webpack.config.js</code>中配置这两个路径：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 导入处理路径的模块</span><br><span class=\"line\">var path &#x3D; require(&#39;path&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理</span><br><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">    entry: path.resolve(__dirname, &#39;src&#x2F;js&#x2F;main.js&#39;), &#x2F;&#x2F; 项目入口文件</span><br><span class=\"line\">    output: &#123; &#x2F;&#x2F; 配置输出选项</span><br><span class=\"line\">        path: path.resolve(__dirname, &#39;dist&#39;), &#x2F;&#x2F; 配置输出的路径</span><br><span class=\"line\">        filename: &#39;bundle.js&#39; &#x2F;&#x2F; 配置输出的文件名</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"实现webpack的实时打包构建\"><a href=\"#实现webpack的实时打包构建\" class=\"headerlink\" title=\"实现webpack的实时打包构建\"></a>实现webpack的实时打包构建</h2><ol>\n<li>由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用<code>webpack-dev-server</code>来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。</li>\n<li>运行<code>cnpm i webpack-dev-server --save-dev</code>安装到开发依赖</li>\n<li>安装完成之后，在命令行直接运行<code>webpack-dev-server</code>来进行打包，发现报错，此时需要借助于<code>package.json</code>文件中的指令，来进行运行<code>webpack-dev-server</code>命令，在<code>scripts</code>节点下新增<code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code>指令，发现可以进行实时打包，但是dist目录下并没有生成<code>bundle.js</code>文件，这是因为<code>webpack-dev-server</code>将打包好的文件放在了内存中</li>\n</ol>\n<ul>\n<li>把<code>bundle.js</code>放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快</li>\n<li>这个时候访问webpack-dev-server启动的<code>http://localhost:8080/</code>网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:<code>&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt;</code></li>\n<li>为了能在访问<code>http://localhost:8080/</code>的时候直接访问到index首页，可以使用<code>--contentBase src</code>指令来修改dev指令，指定启动的根目录：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;dev&quot;: &quot;webpack-dev-server --contentBase src&quot;</span><br></pre></td></tr></table></figure>\n同时修改index页面中script的src属性为<code>&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</code></li>\n</ul>\n<h2 id=\"使用html-webpack-plugin插件配置启动页面\"><a href=\"#使用html-webpack-plugin插件配置启动页面\" class=\"headerlink\" title=\"使用html-webpack-plugin插件配置启动页面\"></a>使用<code>html-webpack-plugin</code>插件配置启动页面</h2><p>由于使用<code>--contentBase</code>指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用<code>html-webpack-plugin</code>插件配置启动页面.</p>\n<ol>\n<li>运行<code>cnpm i html-webpack-plugin --save-dev</code>安装到开发依赖</li>\n<li>修改<code>webpack.config.js</code>配置文件如下：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 导入处理路径的模块</span><br><span class=\"line\">var path &#x3D; require(&#39;path&#39;);</span><br><span class=\"line\">&#x2F;&#x2F; 导入自动生成HTMl文件的插件</span><br><span class=\"line\">var htmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">    entry: path.resolve(__dirname, &#39;src&#x2F;js&#x2F;main.js&#39;), &#x2F;&#x2F; 项目入口文件</span><br><span class=\"line\">    output: &#123; &#x2F;&#x2F; 配置输出选项</span><br><span class=\"line\">        path: path.resolve(__dirname, &#39;dist&#39;), &#x2F;&#x2F; 配置输出的路径</span><br><span class=\"line\">        filename: &#39;bundle.js&#39; &#x2F;&#x2F; 配置输出的文件名</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins:[ &#x2F;&#x2F; 添加plugins节点配置插件</span><br><span class=\"line\">        new htmlWebpackPlugin(&#123;</span><br><span class=\"line\">            template:path.resolve(__dirname, &#39;src&#x2F;index.html&#39;),&#x2F;&#x2F;模板路径</span><br><span class=\"line\">            filename:&#39;index.html&#39;&#x2F;&#x2F;自动生成的HTML文件的名称</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修改<code>package.json</code>中<code>script</code>节点中的dev指令如下：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br></pre></td></tr></table></figure></li>\n<li>将index.html中script标签注释掉，因为<code>html-webpack-plugin</code>插件会自动把bundle.js注入到index.html页面中！</li>\n</ol>\n<h2 id=\"实现自动打开浏览器、热更新和配置浏览器的默认端口号\"><a href=\"#实现自动打开浏览器、热更新和配置浏览器的默认端口号\" class=\"headerlink\" title=\"实现自动打开浏览器、热更新和配置浏览器的默认端口号\"></a>实现自动打开浏览器、热更新和配置浏览器的默认端口号</h2><p><strong>注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！</strong></p>\n<h3 id=\"方式1：\"><a href=\"#方式1：\" class=\"headerlink\" title=\"方式1：\"></a>方式1：</h3><ul>\n<li>修改<code>package.json</code>的script节点如下，其中<code>--open</code>表示自动打开浏览器，<code>--port 4321</code>表示打开的端口号为4321，<code>--hot</code>表示启用浏览器热更新：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open&quot;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"方式2：\"><a href=\"#方式2：\" class=\"headerlink\" title=\"方式2：\"></a>方式2：</h3><ol>\n<li>修改<code>webpack.config.js</code>文件，新增<code>devServer</code>节点如下：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">devServer:&#123;</span><br><span class=\"line\">        hot:true,</span><br><span class=\"line\">        open:true,</span><br><span class=\"line\">        port:4321</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li>在头部引入<code>webpack</code>模块：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var webpack &#x3D; require(&#39;webpack&#39;);</span><br></pre></td></tr></table></figure></li>\n<li>在<code>plugins</code>节点下新增：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new webpack.HotModuleReplacementPlugin()</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"使用webpack打包css文件\"><a href=\"#使用webpack打包css文件\" class=\"headerlink\" title=\"使用webpack打包css文件\"></a>使用webpack打包css文件</h2><ol>\n<li>运行<code>cnpm i style-loader css-loader --save-dev</code></li>\n<li>修改<code>webpack.config.js</code>这个配置文件：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">module: &#123; &#x2F;&#x2F; 用来配置第三方loader模块的</span><br><span class=\"line\">        rules: [ &#x2F;&#x2F; 文件的匹配规则</span><br><span class=\"line\">            &#123; test: &#x2F;\\.css$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] &#125;&#x2F;&#x2F;处理css文件的规则</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li>注意：<code>use</code>表示使用哪些模块来处理<code>test</code>所匹配到的文件；<code>use</code>中相关loader模块的调用顺序是从后向前调用的；</li>\n</ol>\n<h2 id=\"使用webpack打包less文件\"><a href=\"#使用webpack打包less文件\" class=\"headerlink\" title=\"使用webpack打包less文件\"></a>使用webpack打包less文件</h2><ol>\n<li>运行<code>cnpm i less-loader less -D</code></li>\n<li>修改<code>webpack.config.js</code>这个配置文件：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; test: &#x2F;\\.less$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] &#125;,</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"使用webpack打包sass文件\"><a href=\"#使用webpack打包sass文件\" class=\"headerlink\" title=\"使用webpack打包sass文件\"></a>使用webpack打包sass文件</h2><ol>\n<li>运行<code>cnpm i sass-loader node-sass --save-dev</code></li>\n<li>在<code>webpack.config.js</code>中添加处理sass文件的loader模块：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; test: &#x2F;\\.scss$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"使用webpack处理css中的路径\"><a href=\"#使用webpack处理css中的路径\" class=\"headerlink\" title=\"使用webpack处理css中的路径\"></a>使用webpack处理css中的路径</h2><ol>\n<li>运行<code>cnpm i url-loader file-loader --save-dev</code></li>\n<li>在<code>webpack.config.js</code>中添加处理url路径的loader模块：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; test: &#x2F;\\.(png|jpg|gif)$&#x2F;, use: &#39;url-loader&#39; &#125;</span><br></pre></td></tr></table></figure></li>\n<li>可以通过<code>limit</code>指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; test: &#x2F;\\.(png|jpg|gif)$&#x2F;, use: &#39;url-loader?limit&#x3D;43960&#39; &#125;,</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"使用babel处理高级JS语法\"><a href=\"#使用babel处理高级JS语法\" class=\"headerlink\" title=\"使用babel处理高级JS语法\"></a>使用babel处理高级JS语法</h2><ol>\n<li>运行<code>cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev</code>安装babel的相关loader包</li>\n<li>运行<code>cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev</code>安装babel转换的语法</li>\n<li>在<code>webpack.config.js</code>中添加相关loader模块，其中需要注意的是，一定要把<code>node_modules</code>文件夹添加到排除项：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; test: &#x2F;\\.js$&#x2F;, use: &#39;babel-loader&#39;, exclude: &#x2F;node_modules&#x2F; &#125;</span><br></pre></td></tr></table></figure></li>\n<li>在项目根目录中添加<code>.babelrc</code>文件，并修改这个配置文件如下：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;:[&quot;es2015&quot;, &quot;stage-0&quot;],</span><br><span class=\"line\">    &quot;plugins&quot;:[&quot;transform-runtime&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>注意：语法插件<code>babel-preset-es2015</code>可以更新为<code>babel-preset-env</code>，它包含了所有的ES相关的语法；</strong></li>\n</ol>\n<h2 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h2><p><a href=\"https://segmentfault.com/p/1210000008466178\">babel-preset-env：你需要的唯一Babel插件</a><br><a href=\"https://segmentfault.com/a/1190000009065987\">Runtime transform 运行时编译es6</a></p>\n","categories":["vue2.0基础课程"],"tags":["vue2.0基础课程","Webpack"]}]