[{"title":"抓包工具-charles","url":"/2021/05/18/爬虫/Charles的使用/","content":"\n## 一 、Charles 的安装与使用\n\n### Charles官网：https://www.charlesproxy.com/\n\nCharles的作用：\n![image](https://user-images.githubusercontent.com/28568478/118580794-1728fd00-b7c3-11eb-810b-64204319df1d.png)\n\n### 1. 对请求抓包\n保证iPhone和PC工作在同一局域网内（即同一个WIFI下）。\n\n#### 1.1 获取PC端的IP地址\n![image](https://user-images.githubusercontent.com/28568478/118580840-2c059080-b7c3-11eb-925e-fcf375981e38.png)\n\n打开网络偏好设置...\n\n![image](https://user-images.githubusercontent.com/28568478/118580852-33c53500-b7c3-11eb-94ca-ae08bfd9227d.png)\n获取IP地址。\n\n#### 1.2 配置手机代理\n设置->无线局域网\n![image](https://user-images.githubusercontent.com/28568478/118580927-59523e80-b7c3-11eb-8b5f-0103a15cc260.png)\nHTTP代理->配置代理（手动）\n![image](https://user-images.githubusercontent.com/28568478/118580939-5ce5c580-b7c3-11eb-9876-39186efb944c.png)\n\n\n#### 1.3 PC端的Charles设置\n具体的端口可以从Charles菜单栏 -> Proxy -> Proxy Settings中查看。图示如下：\n![image](https://user-images.githubusercontent.com/28568478/118581127-a9310580-b7c3-11eb-85ee-32165789ea92.png)\n代理配置完成后，Charles会弹出连接提示框，点击Allow之后即可使用Charles对从该手机发出的请求进行抓包了。图示如下：\n![image](https://user-images.githubusercontent.com/28568478/118581179-c36ae380-b7c3-11eb-90ed-4f5dae97304f.png)\n\n\n### 2. 抓取HTTPS请求\n配置iPhone代理完毕后，就可以通过Structure或者Sequence窗口预览HTTP请求的数据了。但由于HTTPS请求被加密过，预览请求时只能预览到乱码数据。要预览到HTTPS请求的数据明文，需要PC和iPhone安装证书授权。\n\n#### 2.1 PC端安装证书\n在Charles菜单栏 -> Help -> SSL Proxying -> Install Charles Root Certificate中可以为PC安装证书，证书可以在Mac的钥匙串中查看。图示如下：\n![image](https://user-images.githubusercontent.com/28568478/118581241-e1384880-b7c3-11eb-8999-47c18149561c.png)\n\n\n证书可以在Mac的钥匙串中查看，双击证书，将信任权限设定为始终信任。图示如下：\n![image](https://user-images.githubusercontent.com/28568478/118581258-e7c6c000-b7c3-11eb-9c44-f8dfd864606b.png)\n\n#### 2.2 在手机端配置根证书\n##### 2.2.1 iPhone手机安装证书\n\n- 1、打开Charles，选择help→SSL Proxying→Install Charles Root Certificate on a Mobile Device or Remote Browser\n    ![image](https://user-images.githubusercontent.com/28568478/118582584-2bbac480-b7c6-11eb-8ea9-3352629687aa.png)\n\n- 2、手机连接电脑代理，打开safari，输入网址：chls.pro/ssl\n选择后会显示IP与端口号，用于手机设置http代理：\n![image](https://user-images.githubusercontent.com/28568478/118582629-3d9c6780-b7c6-11eb-9bd6-7b6ccd44f28e.png)\n手机的网络上设置成电脑的http代理：\n此时必须保证手机和电脑在同一网络，并且手机可以访问电脑的ip与端口\n\n![image](https://user-images.githubusercontent.com/28568478/118582754-789e9b00-b7c6-11eb-9f79-44b426cda1ae.png)\n- 3、手机弹出提示：此网站正尝试打开“设置”已向您显示一个配置描述文件。您要允许吗？忽略|允许，选择允许，安装描述文件，并信任\n\n![image](https://user-images.githubusercontent.com/28568478/118582765-7d634f00-b7c6-11eb-94ff-81428d1e1573.png)\n- 4.1、iOS10.3以上的手机需要在：设置→ 通用 → 关于本机 → 证书信任设置→ 找到charles proxy CA证书，打开信任即可\n- 4.2、 手机浏览器（笔者使用Chrome）访问chls.pro/ssl，下载证书并安装(证书名任意)：\n![image](https://user-images.githubusercontent.com/28568478/118582782-8522f380-b7c6-11eb-8979-4b74a651fc99.png)\n\n在iPhone浏览器中访问http://charlesproxy.com/getssl可以下载证书并安装。\n基于iOS的证书信任机制，在安装完成并信任证书后，需要到iPhone设置 ->通用-> 关于本机 -> 证书信任设置中启用根证书。\n\n\n##### 2.2.2 安卓手机安装证书\n\n- 方法一：\n\n        1、打开Charles，选择help→SSL Proxying→Install Charles Root Certificate on a Mobile Device or Remote Browser\n\n        2、手机连接电脑代理，打开浏览器，输入网址：chls.pro/ssl\n\n        3、手机弹出提示：安装配置描述文件。您要允许吗？忽略|允许，选择允许，即可\n\n- 方法二：\n\n        1、打开Charles，选择help→SSL Proxying→Save Charles Certificate，将证书导入到手机中\n\n        2、导入后直接点击安装证书即可\n\n- 方法三：\n\n        1、打开Charles，选择help→SSL Proxying→Save Charles Certificate，将证书导入到手机中\n\n        2、导入后直接点击安装证书，提示无法打开\n\n        3、进入手机设置 → 更多设置 → 系统安全 → 从存储设备安装 → 选择charles.pem，点击高级，安装证书即可\n\n常见手机：小米手机，华为手机，需要设置手机锁屏密码\n\n##### 2.2.3 如果证书下载不下来怎么办？\n可根据安卓我手机安装证书的方法 将证书下载并导入手机进行安装\n\n\n#### 2.4 启动抓包的SSL权限\n在Charles菜单栏 -> Proxy -> SSL Proxying Settings中勾选Enable SSL Proxying，然后在Locations中添加需要抓包的Host和Port即可。图示如下：\n![image](https://user-images.githubusercontent.com/28568478/118581370-180e5e80-b7c4-11eb-9979-a322b1a9f39b.png)\n\n\n即对所有的https都进行抓包。\n\n\n## 二、Charles的破解方法\n### 破解网站：https://www.zzzmode.com/mytools/charles/\n\n#### 此工具用于计算Charles激活码\n输入RegisterName(此名称随意，用于显示 Registered to xxx)，点击生成计算出注册码，打开Charles输入注册码即可。\n![image](https://user-images.githubusercontent.com/28568478/118581701-a5ea4980-b7c4-11eb-85ee-31e28e3e9264.png)\n打开Charles菜单栏 -> help -> Register Charles\n填入上述产生的Registered Name和License Key，即可破解成功！\n![image](https://user-images.githubusercontent.com/28568478/118582091-5bb59800-b7c5-11eb-8c29-a556dd717469.png)\n破解成功\n![image](https://user-images.githubusercontent.com/28568478/118583990-8b19d400-b7c8-11eb-96ff-a152b36ea1ec.png)\n\n## 三、Android 7.0以上手机抓包方式（抓取https，亲测有用）\n安卓7.0有安全保护，用户级别的证书在大部分app中无法通过验证。（charles安装的证书就是用户级别的）\n\nAndroid7.0 之后默认不信任用户添加到系统的CA证书：\n>   To provide a more consistent and more secure experience across the Android ecosystem, beginning with Android Nougat, compatible devices trust only the standardized system CAs maintained in AOSP.（[文档链接](https://android-developers.googleblog.com/2016/07/changes-to-trusted-certificate.html)）\n\n也就是说对基于 SDK24 及以上的APP来说，即使你在手机上安装了抓包工具的证书也无法抓取 https 请求\n\n### 1、下载VritualXposed apk包安装到android手机\n\nhttps://github.com/android-hacker/VirtualXposed\n\n### 2、下载JustTrustMe apk包安装到android手机\n\nhttps://github.com/Fuzion24/JustTrustMe\n\n### 3、安装完成进入VirtualXposed apk应用，点击6个小点进入设置页面\n![image](https://user-images.githubusercontent.com/28568478/118583816-3fffc100-b7c8-11eb-91c3-7745b4d09681.png)\n### 4、进入设置页面，点击模块管理，勾选JustTrustMe（如果没有找到它，可能是这个版本不需要在手动选择了，安装之后自动识别到了）\n\n### 5、重启VirtualXposed\n\n### 6、重启之后我们重新进去设置页面，添加我们需要抓包的应用即可，比如网速管家APP\n\n![image](https://user-images.githubusercontent.com/28568478/118583877-5a399f00-b7c8-11eb-8e3c-0db4541e3516.png)\n![image](https://user-images.githubusercontent.com/28568478/118583888-6160ad00-b7c8-11eb-8d83-fbef18212e8b.png)\n\n\n### 7、设置Fiddler/charles代理，手机设置wifi里面代理改成手动。输入ip，端口：默认8888，注意手机和电脑在一个wifi下就可以了\n\n### 8、回到VirtualXposed 上滑解锁，打开我们安装的应用进行操作，则发现Fiddler/Charles已经成功抓取到安居客的HTTPS的数据包\n![image](https://user-images.githubusercontent.com/28568478/118584941-8a823d00-b7ca-11eb-8252-ba1e28dc6c1a.png)\n\n","tags":["爬虫","抓包","手机抓包","Charles"],"categories":["爬虫"]},{"title":"driver failed programming external connectivity on endpoint nginx","url":"/2021/05/16/Linux/driver failed programming external connectivity on endpoint nginx/","content":"\n今天在阿里云部署服务的时候报如下错：\n```\nroot@iZ2zeagh7rzys1hl53collZ:~/data/csh_bk/docker# docker-compose -f nginx/docker-compose.yml up\nCreating nginx ...\nCreating nginx ... error\n\nERROR: for nginx  Cannot start service nginx: driver failed programming external connectivity on endpoint nginx (84a2d44102b6fd874d94c52c199958bbb88214bf31890d9a66e264336f2a9794):  (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 80 -j DNAT --to-destination 172.20.0.2:80 ! -i br-90c5e5593694: iptables: No chain/target/match by that name.\n (exit status 1))\n\nERROR: for nginx  Cannot start service nginx: driver failed programming external connectivity on endpoint nginx (84a2d44102b6fd874d94c52c199958bbb88214bf31890d9a66e264336f2a9794):  (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 80 -j DNAT --to-destination 172.20.0.2:80 ! -i br-90c5e5593694: iptables: No chain/target/match by that name.\n (exit status 1))\nERROR: Encountered errors while bringing up the project.\n```\n\n1、本身部署服务需要按照Nginx  mysql redis\n2、安装完成后去阿里云设置安全组，打开对应的端口\n3、打开后发现mysql和redis都可以访问  但是Nginx无法访问\n4、后来发现是不小心动了防火墙，导致docker异常，重启docker服务，然后再重启对应服务即可\n\n```\nsystemctl restart docker\n```\n#### 原因:\ndocker服务启动时定义的自定义链DOCKER由于 centos7 firewall 被清掉\n\nfirewall的底层是使用iptables进行数据过滤，建立在iptables之上，这可能会与 Docker 产生冲突。\n\n当 firewalld 启动或者重启的时候，将会从 iptables 中移除 DOCKER 的规则，从而影响了 Docker 的正常工作。\n\n当你使用的是 Systemd 的时候， firewalld 会在 Docker 之前启动，但是如果你在 Docker 启动之后再启动 或者重启 firewalld ，你就需要重启 Docker 进程了。\n\n重启docker服务及可重新生成自定义链DOCKER\n\n\n参考：https://blog.csdn.net/liyanhui1001/article/details/107507847\n","tags":["docker","nginx","aliyun"],"categories":["Linux"]},{"title":"查找日志","url":"/2021/05/07/Linux web/查找日志/","content":"\n```\nfunction latest_log(){\n    for i in $(ls -th $1); do\n        if [[ -f $1$i ]]; then\n            log=$i\n            break;\n        fi\n    done\n    echo $log\n    tail -f $1$log\n}\n```\n","tags":["shell","日志"],"categories":["Linux web"]},{"title":"Unable to read additional data from client, it probably closed the socket","url":"/2021/05/07/异常问题/Unable to read additional data from client, it probab/","content":"今天在用docker-compose 部署Apache DolphinScheduler的时候在我的mac上报如下的错，但是服务器上是正常的，正常来讲用docker部署项目不应该出现这种问题，上网查了很多，说是初始化Zookeeper连接时，将接收超时参数值调整大一些即可（tickTime2000改为10000），默认是毫秒（ms），但是还是不行，后来看到一篇文章说可能是docker内存不够的关系，后来将docker内存从2G跳到了4G好了，但感觉不太像是这个问题，所以记录一下\n\n```\n2021-02-27 19:21:26,435 [myid:1] - WARN  [NIOWorkerThread-1:NIOServerCnxn@364] - Unexpected exception\nEndOfStreamException: Unable to read additional data from client, it probably closed the socket: address = /172.21.0.5:39431, session = 0x0\n\tat org.apache.zookeeper.server.NIOServerCnxn.handleFailedRead(NIOServerCnxn.java:163)\n\tat org.apache.zookeeper.server.NIOServerCnxn.doIO(NIOServerCnxn.java:326)\n\tat org.apache.zookeeper.server.NIOServerCnxnFactory$IOWorkRequest.doWork(NIOServerCnxnFactory.java:522)\n\tat org.apache.zookeeper.server.WorkerService$ScheduledWorkRequest.run(WorkerService.java:154)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\n\tat java.base/java.lang.Thread.run(Thread.java:834)\n```\n","tags":["docker"],"categories":["异常问题"]},{"title":"nginx an upstream response is buffered to a temporary file","url":"/2021/05/07/异常问题/nginx an upstream response is buffered to a temporary file/","content":"查看Nginx日志，发现有很多报错\n```\n2021/02/27 17:00:54 [warn] 28#28: *49939\nan upstream response is buffered to a temporary file /var/cache/nginx/proxy_temp/6/14/0000000146 while reading upstream, client: xxx.xxx.xxx.x,\nserver: airflow.yidianshihui.com, request: \"GET /home HTTP/1.1\", upstream: \"http://xxx.xxx.xxx.xxx:xxxx/home\", host: \"airflow.yidianshihui.com\",\nreferrer: \"http://airflow.yidianshihui.com/home?tags=%E6%AF%8F%E6%97%A5ic_sku%E5%90%8C%E6%AD%A5\"\n```\n\n\n\n### 1.错误日志：warn：an upstream response is buffered to a temporary file\n\n    解决办法：增加fastcgi_buffers      8 4K;     fastcgi_buffer_size  4K;\n#### 2. a client request body is buffered to a temporary file\n\n解决办法：增加client_max_body_size 2050m;     client_body_buffer_size 1024k;\n<!--more-->\n\n###Nginx 的 buffer 机制：\n\n\n对于来自 FastCGI Server 的 Response，Nginx 将其缓冲到内存中，然后依次发送到客户端浏览器。缓冲区的大小由 fastcgi_buffers 和 fastcgi_buffer_size 两个值控制。\n\n比如如下配置：\n ```\nfastcgi_buffers      8 4K;\nfastcgi_buffer_size  4K;\n```\nfastcgi_buffers 控制 nginx 最多创建 8 个大小为 4K 的缓冲区，而 fastcgi_buffer_size 则是处理 Response 时第一个缓冲区的大小，不包含在前者中。所以总计能创建的最大内存缓冲区大小是 8*4K+4K = 36k。而这些缓冲区是根据实际的 Response 大小动态生成的，并不是一次性创建的。比如一个 8K 的页面，Nginx 会创建 2*4K 共 2 个 buffers。\n\n当 Response 小于等于 36k 时，所有数据当然全部在内存中处理。如果 Response 大于 36k 呢？fastcgi_temp 的作用就在于此。多出来的数据会被临时写入到文件中，放在这个目录下面。同时你会在 error.log 中看到一条类似 warning：\n```\n2010/03/13 03:42:22 [warn] 3994#0: *1 an upstream response is buffered to a temporary file\n/usr/local/nginx/fastcgi_temp/1/00/0000000001 while reading upstream,\nclient: 192.168.1.111,\nserver: www.xxx.cn,\nrequest: \"POST /test.php HTTP/1.1\",\nupstream: \"fastcgi://127.0.0.1:9000\",\nhost: \"xxx.cn\",\nreferrer: \"http://xxx.cn/test.php\"\n```\n显然，缓冲区设置的太小的话，Nginx 会频繁读写硬盘，对性能有很大的影响，但也不是越大越好，没意义\n\n官方文档：\n[http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size](http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size) \n\n修改Nginx配置：\n```\nlocation /api {\n        proxy_set_header  Host  $http_host;\n        proxy_set_header  X-Real-IP  $remote_addr;\n        proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_pass   http://elk_server/api;\n        client_body_buffer_size 1024k;\n        client_max_body_size 2050m;\n        fastcgi_buffers 8 4K;\n        fastcgi_buffer_size 4K;\n    }\n```\n\n参考：\n[Nginx性能调优之buffer参数设置](https://blog.csdn.net/zhouyan8603/article/details/89410119)\n [nginx常见问题](https://my.oschina.net/linland/blog/373315)\n","tags":["nginx"],"categories":["异常问题"]},{"title":"docker mysql Could not write unix socket lock file /var/run/mysqld/mysqld.sock.lock","url":"/2021/05/07/数据库/docker mysql Could not write unix socket lock file/","content":"昨天在用docker部署mysql的时候一直报错\n```\n2020-06-23T09:59:47.339758Z 0 [Note] Skipping generation of SSL certificates as certificate files are present in data directory.\n2020-06-23T09:59:47.340593Z 0 [Warning] CA certificate ca.pem is self signed.\n2020-06-23T09:59:47.340636Z 0 [Note] Skipping generation of RSA key pair as key files are present in data directory.\n2020-06-23T09:59:47.340852Z 0 [ERROR] Could not create unix socket lock file /var/run/mysqld/mysqld.sock.lock.\n2020-06-23T09:59:47.340867Z 0 [ERROR] Unable to setup unix socket lock file.\n2020-06-23T09:59:47.340872Z 0 [ERROR] Aborting\n```\n\n解决方法：\n这里可以看到mysqld.sock的目录是在/var/run/mysqld目录下，但是这个目录，我们并没有挂载主机目录，下面我们重新运行mysql容器，挂载相应的容器\n```\n volumes:\n      - /data/mysql-data:/var/lib/mysql\n      - ./init:/docker-entrypoint-initdb.d/\n      - /data/mysql-data/mysqld:/var/run/mysqld\n```\n\n参考：\n[docker安装mysql及相关配置、运行细节和常见报错解决方案](https://zhangxueliang.blog.csdn.net/article/details/111266278)\n","tags":["docker","mysql"],"categories":["数据库"]},{"title":"mac 相关命令","url":"/2021/05/07/mac/mac 相关命令/","content":"### 复制\nditto\n```\n ditto -V -x -k --sequesterRsrc --rsrc xxxx-img-1.zip xxxx-img-1\n```\n\n### 切割\nsplit\n```\nsplit -b 102400000   Joker.小丑.2019.中英字幕.WEBrip.720P-人人影视.mp4\n```\n","tags":["命令"],"categories":["mac"]},{"title":"mac 命令行终端 设置代理","url":"/2021/05/07/mac/mac 命令行终端 设置代理/","content":"## 环境：\n\n*   macOS Mojave 10.14.3\n*   iTrem 2 3.2.8\n*   酸酸乳1.1.4.4-R8\n\n查看自己命令行的状态\n\n```\ncurl ip.gs\n```\n\n## 正式开始\n\n### 一、首先检查自己的酸酸乳是否正常，并在高级设置页面，找到本地 Sock5 监听端口，我自己是 1086，注意这里还有一个 HTTP 代理监听端口，不是这个\n\n![image](https://user-images.githubusercontent.com/28568478/117410597-3adb8000-af45-11eb-96e1-0fde94cea9b3.png)\n\n###  二、安装需要的软件（没有 brew 就先安装 brew，具体自行搜索哈）\n\n```\nbrew install privoxy\n```\n### 三、配置 privoxy\n\n```\nvim /usr/local/etc/privoxy/config\n```\n\n在里面插入两行，\n\n```\nlisten-address 0.0.0.0:8118\nforward-socks5 / localhost:1086 .\n```\n\n 注意！！！ 这里的 1086 就是刚才上面圈出来的端口，千万不要弄错了，弄错了就用不了的\n\n### 四、启动 prioxy\n```\nsudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config\n```\n\n查看是否成功，输入命令\n\n\n```\nnetstat -na | grep 8118\n```\n\n看到有类似如下信息就表示启动成功了 \n\n```\ntcp4 0 0 *.8118 *.* LISTEN\n```\n\n### 五、最后一步，方便使用\n\n`在 ~/.zshrc` 里加入开关函数，使用起来更方便\n\n```\nvim ~/.zshrc\n```\n\n在里面插入\n\n```\nfunction proxy_off(){\n    unset http_proxy\n    unset https_proxy\n    echo -e \"已关闭代理\"\n}\n\nfunction proxy_on() {\n    export no_proxy=\"localhost,127.0.0.1,localaddress,.localdomain.com\"\n    export http_proxy=\"http://127.0.0.1:8118\"\n    export https_proxy=$http_proxy\n    echo -e \"已开启代理\"\n}\n```\n再 source 一下\n\n```\nsource  ~/.zshrc\n```\n\n然后就可以通过在命令行输入 proxy_on 和 proxy_off 来开启和关闭代理啦\n\n### 六、日常开启 prioxy 软件\n\n```\nbrew services start privoxy\n```\n### 七、日常使用步骤\n```\n先启动 provixy 软件\nbrew services start privoxy\n然后 启动代理\nproxy_on\n```\n\n最后在看看自己的命令行状态吧\n\n```\ncurl ip.gs\n```\n\n![image](https://user-images.githubusercontent.com/28568478/117410679-53e43100-af45-11eb-8193-cda84662c914.png)\n\n\n well done！\n","tags":["代理"],"categories":["mac"]},{"title":"mac rz sz 在服务器中上传下载文件","url":"/2021/05/07/mac/mac rz sz 在服务器中上传下载文件/","content":"\n# [mac rz sz 在服务器中上传下载文件](https://www.cnblogs.com/jellyabd/p/11388041.html)\n\n主要参考：[https://segmentfault.com/a/1190000012166969](https://segmentfault.com/a/1190000012166969)\n\n安装步骤参考：[https://github.com/aikuyun/iterm2-zmodem](https://github.com/aikuyun/iterm2-zmodem)\n\n**安装步骤**\n\n1.安装支持rz和sz命令的lrzsz：brew install lrzsz\n\n> 等了挺长时间的。\n\n2.在本地/usr/local/bin/目录下保存iterm2-send-zmodem.sh 和iterm2-recv-zmodem.sh两个脚本\n\niterm2-send-zmodem.sh\n<!--more-->\n\n```\n\n#!/bin/bash\n# Author: Matt Mastracci (matthew@mastracci.com)\n# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script\n# licensed under cc-wiki with attribution required\n# Remainder of script public domain\n\nosascript -e 'tell application \"iTerm2\" to version' > /dev/null 2>&1 && NAME=iTerm2 || NAME=iTerm\nif [[ $NAME = \"iTerm\" ]]; then\n    FILE=`osascript -e 'tell application \"iTerm\" to activate' -e 'tell application \"iTerm\" to set thefile to choose file with prompt \"Choose a file to send\"' -e \"do shell script (\\\"echo \\\"&(quoted form of POSIX path of thefile as Unicode text)&\\\"\\\")\"`\nelse\n    FILE=`osascript -e 'tell application \"iTerm2\" to activate' -e 'tell application \"iTerm2\" to set thefile to choose file with prompt \"Choose a file to send\"' -e \"do shell script (\\\"echo \\\"&(quoted form of POSIX path of thefile as Unicode text)&\\\"\\\")\"`\nfi\nif [[ $FILE = \"\" ]]; then\n    echo Cancelled.\n    # Send ZModem cancel\n    echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18\n    sleep 1\n    echo\n    echo \\# Cancelled transfer\nelse\n    /usr/local/bin/sz \"$FILE\" -e -b\n    sleep 1\n    echo\n    echo \\# Received $FILE\nfi\n```\n\n\niterm2-recv-zmodem.sh\n\n```\n#!/bin/bash\n# Author: Matt Mastracci (matthew@mastracci.com)\n# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script\n# licensed under cc-wiki with attribution required\n# Remainder of script public domain\n\nosascript -e 'tell application \"iTerm2\" to version' > /dev/null 2>&1 && NAME=iTerm2 || NAME=iTerm\nif [[ $NAME = \"iTerm\" ]]; then\n    FILE=`osascript -e 'tell application \"iTerm\" to activate' -e 'tell application \"iTerm\" to set thefile to choose folder with prompt \"Choose a folder to place received files in\"' -e \"do shell script (\\\"echo \\\"&(quoted form of POSIX path of thefile as Unicode text)&\\\"\\\")\"`\nelse\n    FILE=`osascript -e 'tell application \"iTerm2\" to activate' -e 'tell application \"iTerm2\" to set thefile to choose folder with prompt \"Choose a folder to place received files in\"' -e \"do shell script (\\\"echo \\\"&(quoted form of POSIX path of thefile as Unicode text)&\\\"\\\")\"`\nfi\n\nif [[ $FILE = \"\" ]]; then\n    echo Cancelled.\n    # Send ZModem cancel\n    echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18\n    sleep 1\n    echo\n    echo \\# Cancelled transfer\nelse\n    cd \"$FILE\"\n    /usr/local/bin/rz -E -e -b\n    sleep 1\n    echo\n    echo\n    echo \\# Sent \\-\\> $FILE\nfi\n```\n\n3.设置一下两个脚本的权限，一般 chmod 777 就行了\n\n```\nchmod 777 /usr/local/bin/iterm2-*\n```\n\n4.设置Iterm2的Tirgger特性，profiles->default->editProfiles->Advanced中的Tirgger\n\n添加两条trigger，分别设置 Regular expression，Action，Parameters，Instant如下：\n\n1.第一条\n\n        Regular expression: \\*\\*B0100\n\n        Action: Run Silent Coprocess\n\n        Parameters: /usr/local/bin/iterm2-send-zmodem.sh\n\n2.第二条\n\n        Regular expression: \\*\\*B00000000000000\n\n        Action: Run Silent Coprocess\n\n        Parameters: /usr/local/bin/iterm2-recv-zmodem.sh\n\n**需要注意的点：**\n\n# 使用expect自动登录后，不能使用rz和sz命令问题\n\n    脚本开头可以加入：export LC_CTYPE=en_US\n```\n对/usr/local/bin的\n *   iterm2-recv-zmodem.sh\n *  iterm2-send-zmodem.sh\n脚本添加权限\n```\n\n            chmod 777 iterm2-*\n\n*   iterm2 的设置路径为：\n\n            点击 iTerm2 的设置界面 Perference-> Profiles -> Default -> Advanced -> Triggers 的 Edit 按钮\n\n*   iterm2的triggers截图\n\n            1.第一行receive，只需要“**B0100”的内容，不要前面的那一串说明。\n\n            2.“**B0100”对应的是send\n\n![image](https://user-images.githubusercontent.com/28568478/117410212-b5f06680-af44-11eb-9282-2eb8dbea1b44.png)\n","tags":["macOS","rz sz"],"categories":["mac"]},{"title":"docker 命令","url":"/2021/05/07/docker/docker 命令/","content":"\n# 一、关于镜像\n\n### 1、删除所有镜像\n```\ndocker rmi `docker images -q`\n```\n\n### 2、按条件删除镜像\n\n- 没有打标签\n```\ndocker rmi `docker images -q | awk '/^<none>/ { print $3 }'`\n```\n- 镜像名包含关键字\n```\ndocker rmi --force `docker images | grep doss-api | awk '{print $3}'`    //其中doss-api为关键字\n```\n\n<!--more-->\n\n# 二、关于容器\n\n ### 1、查看运行容器\n```\ndocker ps\n```\n\n### 2、查看所有容器\n\n```\ndocker ps -a\n```\n\n### 3、进入容器\n\n- 其中字符串为容器ID:\n\n```\ndocker exec -it d27bd3008ad9 /bin/bash\n```\n\n### 4、停用全部运行中的容器:\n\n```\ndocker stop $(docker ps -q)\n```\n\n### 5、删除全部容器：\n\n```\ndocker rm $(docker ps -aq)\n```\n\n### 6、一条命令实现停用并删除容器：\n\n```\ndocker stop $(docker ps -q) & docker rm $(docker ps -aq)\n```\n","tags":["命令","镜像","容器"],"categories":["docker"]},{"title":"/var/lib/docker/overlay2 占用很大，清理Docker占用的磁盘空间，迁移 /var/lib/docker 目录","url":"/2021/05/07/docker/清理Docker占用的磁盘空间/","content":"#### 0、  du -hs /var/lib/docker/ 命令查看磁盘使用情况。\n```\nlinlf@dacent:~$ sudo du -hs /var/lib/docker/\n237G\t/var/lib/docker/\n```\n#### 1 docker system df命令，类似于Linux上的df命令，用于查看Docker的磁盘使用情况:\n```\nlinlf@dacent:~$ docker system df\nTYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\nImages              7                   2                   122.2GB             79.07GB (64%)\nContainers          2                   2                   61.96GB             0B (0%)\nLocal Volumes       0                   0                   0B                  0B\nBuild Cache         0                   0                   0B                  0B\n```\n#### 2 docker system prune命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像)。\n```\nlinlf@dacent:~$ docker system prune\nWARNING! This will remove:\n        - all stopped containers\n        - all networks not used by at least one container\n        - all dangling images\n        - all build cache\nAre you sure you want to continue? [y/N] y\nTotal reclaimed space: 0B\n```\n#### 3 docker system prune -a命令清理得更加彻底，可以将没有容器使用Docker镜像都删掉。注意，这两个命令会把你暂时关闭的容器，以及暂时没有用到的Docker镜像都删掉了…所以使用之前一定要想清楚.。我没用过，因为会清理 没有开启的  Docker 镜像。\n\n \n\n#### 4 迁移 /var/lib/docker 目录。\n\n- 4.1 停止docker服务。\n```\nsystemctl stop docker\n```\n- 4.2 创建新的docker目录，执行命令df -h,找一个大的磁盘。 我在 /home目录下面建了 /home/docker/lib目录，执行的命令是：\n```\nmkdir -p /home/docker/lib\n```\n- 4.3 迁移/var/lib/docker目录下面的文件到 /home/docker/lib：\n```\nrsync -avz /var/lib/docker /home/docker/lib/\n```\n- 4.4 配置 /etc/systemd/system/docker.service.d/devicemapper.conf。查看 devicemapper.conf 是否存在。如果不存在，就新建。\n```\nsudo mkdir -p /etc/systemd/system/docker.service.d/\nsudo vi /etc/systemd/system/docker.service.d/devicemapper.conf\n```\n- 4.5 然后在 devicemapper.conf 写入：（同步的时候把父文件夹一并同步过来，实际上的目录应在 /home/docker/lib/docker ）\n```\n[Service]\nExecStart=\nExecStart=/usr/bin/dockerd  --graph=/home/docker/lib/docker\n```\n- 4.6 重新加载 docker\n```\nsystemctl daemon-reload\n\nsystemctl restart docker\n\nsystemctl enable docker\n```\n- 4.7 为了确认一切顺利，运行\n```\n# docker info\n```\n命令检查Docker 的根目录.它将被更改为 /home/docker/lib/docker\n\n```\nDocker Root Dir: /home/docker/lib/docker\nDebug Mode (client): false\nDebug Mode (server): false\nRegistry: https://index.docker.io/v1/\n\n```\n\n- 4.8 启动成功后，再确认之前的镜像还在：\n```\nlinlf@dacent:~$ docker images\nREPOSITORY           TAG                 IMAGE ID            CREATED             SIZE\nAAA/AAA               v2                  7331b8651bcc        27 hours ago        3.85GB\nBBB/BBB               v1                  da4a80dd8424        28 hours ago        3.47GB\n```\n- 4.9 确定容器没问题后删除/var/lib/docker/目录中的文件。\n\n \n\n参考链接：\nhttps://blog.csdn.net/qq_37674858/article/details/79976751\n\nhttps://blog.csdn.net/cmrsautomation/article/details/52857791\n\n\n原文链接：https://blog.csdn.net/weixin_32820767/article/details/81196250\n","tags":["docker","overlay2","清理"],"categories":["docker"]},{"title":"aws 安装docker","url":"/2021/05/07/docker/aws 安装docker/","content":"\n1、[aws官方教程](https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/docker-basics.html)\n\n2、\n```\nsudo yum update -y\n```\n发现报错\n![image](https://user-images.githubusercontent.com/28568478/117409227-8a20b100-af43-11eb-977b-29b69dc8895e.png)\n\n\n安装提示进行解决\n```\nsudo yum-config-manager --disable docker-ce-stable\n```\n<!--more-->\n\n3、安装官方文档进行安装docker 启动docker\n```\nsudo yum update -y\n\nsudo amazon-linux-extras install docker\n\n/bin/systemctl start docker.service\n# 原本使用命令 sudo service docker start   实际提示  Redirecting to /bin/systemctl start docker.service\n\nsudo usermod -a -G docker ec2-user 或者 sudo gpasswd -a ${USER} docker  都可以\n\n# 然后退出服务器重新登录服务器\n\ndocker info # 发现docker安装完成\n```\n\n\n4、 docker-compose 安装\n[docker-compose github](https://github.com/docker/compose)\n```\nsudo curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose\n\n# 安装最新版本\nsudo curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose\n\n# 修改权限\nsudo chmod +x /usr/local/bin/docker-compose\n\n# 验证是否安装成功\ndocker-compose version\n\n```\n\n#### 注意 ：\n          如果不退出服务器再次登录  docker info 会报错无权限\n![](https://upload-images.jianshu.io/upload_images/5818745-630d6164d4278a6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 参考文档：\nhttps://gist.github.com/npearce/6f3c7826c7499587f00957fee62f8ee9\n","tags":["docker","aws"],"categories":["docker"]},{"title":"mac docker","url":"/2021/05/07/docker/mac docker/","content":"### 安装命令\n```\nbrew cask install docker\n```\n![image](https://user-images.githubusercontent.com/28568478/117409037-4b8af680-af43-11eb-8584-074f05051f51.png)\n\n\n在启动台点击Docker app, 在载入 Docker app 后，点击 Next，可能会询问你的 macOS 登陆密码，你输入即可。之后会弹出一个 Docker 运行的提示窗口，状态栏上也有有个小鲸鱼的图标\n（![image](https://user-images.githubusercontent.com/28568478/117409069-56de2200-af43-11eb-94bf-a3abda66bea4.png)）。\n\n\n###  Docker app 启动命令\n安装完成后会自启动 如果没有启动  可以用这个命令\n```\ndocker run -d -p 80:80 docker/getting-started\n```\n![image](https://user-images.githubusercontent.com/28568478/117409079-59d91280-af43-11eb-960b-0fcc22502921.png)\n\n","tags":["docker","macOS"],"categories":["docker"]},{"title":"Go struct 类型的 map 结构体成员不能修改的问题","url":"/2021/05/07/golang/Go struct 类型的 map 结构体成员不能修改的问题/","content":"\n\n\n引入： 错误 Reports assignments directly to a struct field of a map\n\n![image](https://user-images.githubusercontent.com/28568478/117408509-a3752d80-af42-11eb-9267-d8146f2ff28b.png)\n\n\n### 1. 问题的产生\n\n这个问题在github上可以追溯到2012年提交的一个issue，链接为 [https://github.com/golang/go/issues/3117](https://github.com/golang/go/issues/3117) ；如上图，结构体作为map的元素时，不能够直接赋值给结构体的某个字段，也就是map中的struct中的字段不能够直接寻址。\n\n<!--more-->\n\n### 2. 问题产生的原因\n\n关于golang中map的这种古怪的特性有这样几个观点：\n\n1）map作为一个封装好的数据结构，由于它底层可能会由于数据扩张而进行迁移，所以拒绝直接寻址，避免产生野指针；\n\n2）map中的key在不存在的时候，赋值语句其实会进行新的k-v值的插入，所以拒绝直接寻址结构体内的字段，以防结构体不存在的时候可能造成的错误；\n\n3）这可能和map的并发不安全性相关\n\n\n- x = y 这种赋值的方式，你必须知道 x的地址，然后才能把值 y 赋给 x。\n- 但 go 中的 map 的 value 本身是不可寻址的，因为 map 的扩容的时候，可能要做 key/val pair迁移\n- value 本身地址是会改变的\n- 不支持寻址的话又怎么能赋值呢\n\n### 3. 问题的解决\n\n1）迂回方式一：整体更新map的value部分\n\n```\npackage main\n\nimport \"fmt\"\n\ntype Person struct{\n\tname string\n\tsex string\n\tage int\n}\n\nfunc main(){\n\tm := map[uint]Person{\n\t\t0 : Person{\"张无忌\", \"男\", 18},\n\t\t1 : Person{\"周芷若\", \"女\", 17},\n\t}\n\n\t//m[0].age += 1\n\t//整体更新结构体\n\ttemp := m[0]\n\ttemp.age += 1\n\tm[0] = temp\n\tfmt.Println(m)\n}\n```\n\n运行结果：\n\n![image](https://user-images.githubusercontent.com/28568478/117408510-a3752d80-af42-11eb-8f10-e860eb41f4d0.png)\n\n\n2） 迂回方式二：把map的value部分定义为对应类型的指针类型或是slice或是map时，这样是可以更新v的内部字段的\n\n```\npackage main\n\nimport \"fmt\"\n\ntype Person struct{\n\tname string\n\tsex string\n\tage int\n}\n\nfunc main() {\n\t//定义map的value类型为指针类型\n\tm := map[uint]*Person{\n\t\t0: &Person{\"张无忌\", \"男\", 18},\n\t\t1: &Person{\"周芷若\", \"女\", 17},\n\t}\n\n\tm[0].age += 1\n\n\tfmt.Println(*m[0])\n}\n```\n\n运行结果：\n\n![image](https://user-images.githubusercontent.com/28568478/117408536-aa03a500-af42-11eb-9737-32d0b54feb84.png)\n\n\n\n原文链接：[golang 结构体作为map的元素时，不能够直接赋值给结构体的某个字段](https://blog.csdn.net/zhngcho/article/details/82424962)\n","tags":["struct"],"categories":["golang"]},{"title":"MAC brew update镜像源切换","url":"/2021/05/07/mac/MAC brew update镜像源切换/","content":"\n### 一、查看当前Homebrew 镜像源\n\n- 方法1\n```\nbrew config\n# 查看现在镜像源\n# ORIGIN:https://github.com/Homebrew/brew.git 之前未操作过则会显示这个链接，也就是官方镜像源\n```\n<!--more-->\n- 方法2\n```\n# brew.git镜像源\ngit -C \"$(brew --repo)\" remote -v\n\n# homebrew-core.git镜像源\ngit -C \"$(brew --repo homebrew/core)\" remote -v\n\n# homebrew-cask.git镜像源\ngit -C \"$(brew --repo homebrew/cask)\" remote -v\n```\n\n### 二、替换源\n\n#####  国内镜像地址\n\n*   科大: [https://mirrors.ustc.edu.cn](https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fmirrors.ustc.edu.cn)\n*   阿里: [https://mirrors.aliyun.com/homebrew/](https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fmirrors.aliyun.com%252Fhomebrew%252F)\n- 方法1\n```\n# 替换 brew.git\ncd \"$(brew --repo)\"\ngit remote set-url origin https://mirrors.ustc.edu.cn/brew.git\n\n# 替换 homebrew-core.git\ncd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\"\ngit remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git\n```\n- 方法2\n```\ngit -C \"$(brew --repo)\" remote set-url origin https://mirrors.ustc.edu.cn/brew.git\n\ngit -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git\n\ngit -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git\n\n```\n- 方法3\n```\nif [ $SHELL = \"/bin/bash\" ] # 如果你的是bash\nthen\n    echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/' >> ~/.bash_profile\n    source ~/.bash_profile\nelif [ $SHELL = \"/bin/zsh\" ] # 如果用的shell 是zsh 的话\nthen\n    echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/' >> ~/.zshrc\n    source ~/.zshrc\nfi\n```\n\n\n### 三、查看是否替换成功\n```\nbrew config\n#查看更换后的镜像源(ORIGIN: https://mirrors.ustc.edu.cn/brew.git 说明更换成功)\n```\n如果替换成功后，进行brew update就可以了\n\n\n### 四、恢复原有镜像源的方法\n- 如果需要恢复原有镜像源的话（国内镜像源突然不能用了或版本不够新）\n```\ngit -C \"$(brew --repo)\" remote set-url origin https://github.com/Homebrew/brew.git\n\ngit -C \"$(brew --repo homebrew/core)\" remote set-url origin https://github.com/Homebrew/homebrew-core.git\n\ngit -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://github.com/Homebrew/homebrew-cask.git\n\n# 找到 ~/.bash_profile 或者 ~/.zshrc 中的HOMEBREW_BOTTLE_DOMAIN 一行删除\n\nbrew update\n```\n\n参考：\n-  [mac brew update 卡着不动的问题](https://www.cnblogs.com/demingblog/p/11436602.html)\n\n- [Mac Homebrew 国内镜像源替换或重置（brew update 没反应）](https://zhuanlan.zhihu.com/p/102760018)\n\n- [Mac安装Homebrew并更换国内镜像源](https://www.cnblogs.com/StivenYang/p/12546605.html)\n","tags":["macOS","镜像源"],"categories":["mac"]},{"title":"解决MAC删除应用程序后依然残留的图标","url":"/2021/05/07/mac/解决MAC删除应用程序后依然残留的图标/","content":"在MAC，有时候删除应用程序后，发现 应用台 仍有该应用的图标\n\n## 删除方法：\n\n在终端输入\n```\nsqlite3 $(find /private/var/folders \\( -name com.apple.dock.launchpad -a -user $USER \\) 2> /dev/null)/db/db \"DELETE FROM apps WHERE title='TeamViewer';\" && killall Dock\n```\n我这个是删除TeamViewer,如果要删除其他的，改成相应应用程序的名字即可\n注意大小写\n","tags":["macOS","图标"],"categories":["mac"]},{"title":"证书的生成","url":"/2021/05/07/Linux web/证书的生成/","content":"我们通过-in参数指定传入的文件名称,而-out文件指定输出的文件名称,而-nodes参数表示不对私钥进行加密\n\n### 方法1：\n\n生成cert:\n```\nopenssl pkcs12 -clcerts -nokeys -out cert.pem  -in  cert.p12\n```\n生成key:\n\n```\nopenssl pkcs12 -nocerts -out key.pem  -in  key.p12\n```\n\n取消设置key时的密码:\n```\nopenssl rsa -in  key.pem  -out key.unencrypted.pem\n```\n\n### 方法2（常用方法）：\n\n默认没有密码生成cert:\n```\nopenssl pkcs12 -in   证书.p12    -nokeys  -out   cert.pem  -nodes\n```\n生成key:\n```\nopenssl pkcs12   -in  证书.p12   -nocerts -out key.pem   -nodes\n```\n注意：解压证书时万不可设置密码\n\n在终端测试证书是否可正常使用\n```\nopenssl   s_client  -connect   gateway.push.apple.com:2195  -cert  cert.pem -key   key.pem\n```\n","tags":["证书"],"categories":["Linux web"]},{"title":"pycharm如何配置pytest","url":"/2021/05/07/tools/pycharm如何配置pytest/","content":"\nMac下\nPyCharm Community Edition-->Preference-->Tools-->Python Integrated Tools， 把Default test runner换为pytest就可以了\n\n\n![image](https://user-images.githubusercontent.com/28568478/117407710-81c77680-af41-11eb-8ff3-29540ac4720e.png)\n\n正常情况下如下图\n![image](https://user-images.githubusercontent.com/28568478/117407724-8724c100-af41-11eb-8c2a-7d2f3426c78d.png)\n\n![image](https://user-images.githubusercontent.com/28568478/117407753-9441b000-af41-11eb-9ae6-4d1be9743971.png)\n\n\n\n如果无法正常使用，则可能你最开始用unittest进行了测试  则需要按照下图删除使用过的测试文件即可\n![image](https://user-images.githubusercontent.com/28568478/117407807-aa4f7080-af41-11eb-9a1c-5a09c623d1f6.png)\n![image](https://user-images.githubusercontent.com/28568478/117407815-ad4a6100-af41-11eb-84f4-7794dd0d8887.png)\n\n","tags":["python","pycharm"],"categories":["工具"]},{"title":"mac 安装 zookeeper kafka","url":"/2021/05/07/异步任务/mac 安装 zookeeper kafka/","content":"# 1、安装JSK\n\n# 2、安装zookeeper\n\n```\nbrew install zookeeper\n\n// 后台启动\nbrew services start zookeeper\n\n// 非后台启动\nzkServer start\n\n```\n\n![image](https://user-images.githubusercontent.com/28568478/117407463-2c8b6500-af41-11eb-8d22-2eb8ea34bd70.png)\n\n\n# 3、安装kafka\n```\nbrew install kafka\n\n// 后台启动\nbrew services start kafka\n\n// 非后台启动\nzookeeper-server-start /usr/local/etc/kafka/zookeeper.properties & kafka-server-start /usr/local/etc/kafka/server.properties\n```\n![image](https://user-images.githubusercontent.com/28568478/117407483-33b27300-af41-11eb-8dc3-b34985a1527c.png)\n\n\n","tags":["macOS","kafka"],"categories":["异步任务"]},{"title":"kafka基本命令","url":"/2021/05/07/异步任务/kafka基本命令/","content":"\n**一：Homebrew是神马**\n\n　　先介绍下mac 神器 Homebrew, 类似linux系统下的yum和 apt-get，Homebrew简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件\n\n**二：Homebrew官网** https://brew.sh/\n\n**三：Homebrew安装** \n\n打开终端，直接输入即可完成安装\n\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n<!--more-->\n**四：Homebrew使用**\n\nHomebrew使用没啥好说的了，常用的\n\n搜索软件：brew search 软件名，如brew search mysql\n\n安装软件：brew install 软件名，如brew install mysql\n\n卸载软件：brew remove 软件名，如brew remove mysql\n\n列出软件：brew list 软件名，如brew list mysql\n\n### 五. 安装kafka\n\n$   brew install kafka\n\n(1)  安装过程将依赖安装 zookeeper\n\n(2)  软件位置\n\n/usr/local/Cellar/zookeeper\n\n/usr/local/Cellar/kafka\n\n(3)  配置文件位置\n\n/usr/local/etc/kafka/zookeeper.properties\n\n/usr/local/etc/kafka/server.properties\n\n备注：后续操作均需进入 /usr/local/Cellar/kafka/2.0.0/bin 目录下。\n\n### 六、安装\n\nkafka依赖Java，因此要确保先安装好java\n\n```\n// mac 环境使用brew直接安装kafkabrew install kafka  // 卸载brew uninstall kafka\n```\n\n### 七、启动\n\n```\n// 启动brew services start kafkabrew services start zookeeper // 重启brew services restart kafkabrew services restart zookeeper\n```\n\n### 八、创建主题\n\n```\nkafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n\n```\n\n###  九、删除主题\n\n```\nkafka-topics  --delete --zookeeper localhost:2181 --topic 【topic name】\n\n```\n\n### 十、查看主题\n\n```\nkafka-topics --list --zookeeper localhost:2181\n\n```\n\n### 十一、生产消息\n\n```\nkafka-console-producer --broker-list localhost:9092 --topic test\n\n```\n\n### 十二、消费消息\n\n```\nkafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginning\n```\n\n","tags":["macOS","kafka"],"categories":["异步任务"]},{"title":"mac etcd","url":"/2021/05/07/异步任务/mac etcd/","content":"\n\n##一、使用 brew 安装\n#### 1、 确定 brew 是否有 etcd 包：\n\n```\nbrew search etcd\n```\n当然肯定有这个包，这样做的好处是养成一个好的习惯，避免盲目使用 brew install balabala\n<!--more-->\n####2、安装\n```\nbrew install etcd\n```\n![image](https://user-images.githubusercontent.com/28568478/117406890-51330d00-af40-11eb-9d77-cee34e5d064d.png)\n\n\n####3、运行 etcd\n安装完后，会有相关提示，告知我们怎么使用，推荐使用 brew services 来管理这些应用。\n运行 **brew services list**, 可以看到相关应用的状况，很方便。哎，真香！\n\n![image](https://user-images.githubusercontent.com/28568478/117406896-542dfd80-af40-11eb-858d-9a8334e523fb.png)\n\n\n\nbrew services 常用的操作\n\n```\n# 启动某个应用，这里用 etcd 做演示\nbrew services start etcd\n\n# 停止某个应用\nbrew services stop etcd\n\n# 查看当前应用列表\nbrew services list\n```\n![image](https://user-images.githubusercontent.com/28568478/117406908-58f2b180-af40-11eb-9b81-fd34bffa0fca.png)\n\n从执行结果中可以看出：\n\n- etcdserver: name = default， name表示节点名称，默认为default。\n- etcdserver: data dir = default.etcd，data-dir保存日志和快照的目录，默认为当前工作目录“./default.etcd/”。\n- etcdserver: initial advertise peer URLs = http://localhost:2380，通过http://localhost:2380，和集群中其他节点通信。\n- etcdserver: advertise client URLs = http://localhost:2379，通过http://localhost:2379，对外提供HTTP API服务，供客户端交互。如果配置webui，就使用这个地址。\n- etcdserver: heartbeat = 100ms leader发送心跳到followers的间隔时间。\n- etcdserver: election = 1000ms 重新投票的超时时间，如果follow在该时间间隔没有收到心跳包，会触发重新投票，默认为1000ms\n- 集群和每个节点都会生成一个 uuid。\n- 启动的时候，会运行 raft协议，选举出 leader。\n\n好了， etcd 已经启动了，现在验证下，是否正确的启动：\n```\netcdctl endpoint health\n```\n正常情况会输出：\n![image](https://user-images.githubusercontent.com/28568478/117406997-7e7fbb00-af40-11eb-951f-54cfe745af03.png)\n\n\n至此，etcd 已经安装完毕。\n\n## 二、安装etcd webui\n\n在安装etcd webui之前，请确保已安装node工具。使用brew search node命令，可以查看候选安装包；使用**brew install node**命令，即可安装node工具。\n\n使用git命令下载etcd webui代码，并修改配置文件：\n\n```\n$ git clone https://github.com/henszey/etcd-browser.git\n$ cd etcd-browser/\n$ vim server.js\n```\n\n编辑server.js，修改内容如下：\n\n```\nvar etcdHost = process.env.ETCD_HOST || '127.0.0.1'; // || '172.17.42.1';\nvar etcdPort = process.env.ETCD_PORT || 2379; // 4001\nvar serverPort = process.env.SERVER_PORT || 8000;\n```\n\n将etcd host修改为本机，将etcd port修改为2379（对于旧版etcd，修改为4001）。\n\n在安装etcd webui之前，务必先启动etcd。\n\n启动etcd webui，执行命令：\n\n```\nnode server.js\n```\n\n执行结果如下所示：\n\n```\nproxy /api requests to etcd on 127.0.0.1:2379etc-browser listening on port 8000\n```\n\n在浏览器中，直接访问：[http://127.0.0.1:8000/](http://127.0.0.1:8000/)，响应页面如下：\n\n![image](https://user-images.githubusercontent.com/28568478/117407010-82abd880-af40-11eb-83f7-840fac4b4a06.png)\n\n至此，mac下安装etcd成功，配置etcd可视化页面etcd webui成功。\n\n##三、操作\n最常见的就是put、get和del命令。\n  ```\n# 放入一个 键值对\n ~  etcdctl put \"name\" \"zyq1\"\nOK\n#取出一个 键值对\n ~  etcdctl get  \"name\"\nname\nzyq1\n# 删除一个 键值对\n ~  etcdctl del  \"name\"\n1\n# 放入一个 键值对\n```\nwatch\nwatch命令用来监测key的变化，会建立长连接，一直监听。\n\n```\n ~  etcdctl watch \"name\"\nPUT\nname\nzyq1\nDELETE\nname\n```\n\n##四、租约\n租约是一段时间，可以为etcd的key授予租约。当key被附加到租约时，它的生存时间被绑定到租约的生存时间，一旦租约的TTL到期，租约就过期并且所有附带的key都将被删除。\n\n一个租约可以绑定不止一个key。\n\n```\n# 创建一个20s的租约\n$ ./etcdctl lease grant 20\nlease 694d673115905e37 granted with TTL(20s)\n\n# 使用租约的 id 进行 put 操作\n$ ./etcdctl put --lease=694d673115905e37 \"name\" \"zyq\"\n\n# 20s后get发现 key被删除了\n$ ./etcdctl get \"name\"\n# 空应答\n```\n\n租约可以被删除\n\n```\n# 创建一个20s的租约\n$ ./etcdctl lease grant 1000\nlease 694d673115905e49 granted with TTL(1000s)\n\n# 使用租约的 id 进行 put 操作\n$ ./etcdctl put --lease=694d673115905e49 \"name\" \"zyq\"\nOK\n# 删除租约\n$ ./etcdctl lease revoke 694d673115905e49\nlease 694d673115905e49 revoked\n# 发现key也被删除了\n$ ./etcdctl get \"name\"\n# 空应答\n```\n\n租约可以自动续租\n\n```\n# 创建一个20s的租约\n$ ./etcdctl lease grant 20\nlease 694d673115905e4f granted with TTL(20s)\n# 自动续租\n$ ./etcdctl lease keep-alive 694d673115905e4f\nlease 694d673115905e4f keepalived with TTL(20)\nlease 694d673115905e4f keepalived with TTL(20)\n```\n\n————————————————\n转自链接：\nhttps://learnku.com/articles/42515\nhttps://blog.csdn.net/chinawangfei/article/details/94555155\n","tags":["macOS","etcd"],"categories":["异步任务"]},{"title":"在 Mac 下面安装 cryptography 依赖包，始终报错，出现 'openssl/opensslv.h' file not found 的错误。","url":"/2021/05/07/mac/在 Mac下面安装 cryptography 依赖包始终报错/","content":"\n在 Mac 下面安装 cryptography 依赖包，始终报错，出现 'openssl/opensslv.h' file not found 的错误。\n```\n$ pip install cryptography\n```\n```\nbuilding '_openssl' extension\ncc -fno-strict-aliasing -fno-common -dynamic -arch i386 -arch x86_64 -g -Os -pipe -fno-common -fno-strict-aliasing -fwrapv -DENABLE_DTRACE -DMACOSX -DNDEBUG -Wall -Wstrict-prototypes -Wshorten-64-to-32 -DNDEBUG -g -fwrapv -Os -Wall -Wstrict-prototypes -DENABLE_DTRACE -arch i386 -arch x86_64 -pipe -I/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -c build/temp.macosx-10.12-intel-2.7/_openssl.c -o build/temp.macosx-10.12-intel-2.7/build/temp.macosx-10.12-intel-2.7/_openssl.o\nbuild/temp.macosx-10.12-intel-2.7/_openssl.c:434:10: fatal error: 'openssl/opensslv.h' file not found\n#include <openssl/opensslv.h>\n         ^\n1 error generated.\nerror: command 'cc' failed with exit status 1\n```\n这是因为找不到 openssl 的头文件，可以使用 brew 命令进行安装:\n```\n$ brew install openssl\n```\n如果安装完成以后还是会出现上面的错误的话，就是环境变量的问题了，需要重新指定 openssl 的路径安装：\n```\n$ env LDFLAGS=\"-L$(brew --prefix openssl)/lib\" CFLAGS=\"-I$(brew --prefix openssl)/include\" pip install cryptography\n```\n这样就可以搞定了~~~\n","tags":["macOS","cryptography"],"categories":["mac"]},{"title":"服务器挂载大于2T的硬盘","url":"/2021/05/07/Linux/服务器挂载大于2T的硬盘/","content":"### 背景:\n- 服务器购买的时候带了一个5T硬盘，当使用fdisk进行格式化挂载到文件夹下，发现只有2T！！！后来网上查询发现fdisk只能处理2T以下的硬盘,需要使用parted处理大于2T  以上的硬盘!!\n![image](https://user-images.githubusercontent.com/28568478/117395390-60a75b80-af2a-11eb-9acd-ac5bdc4e0ee8.png)\n![image](https://user-images.githubusercontent.com/28568478/117395399-69982d00-af2a-11eb-9bfc-9308c3cb3f0b.png)\n\n\n<!--more-->\n\n### 命令说明:\n - 磁盘分区的命令有fdisk和parted，但fdisk只能处理2T以下的硬盘，parted能处理大于2T以上的硬盘，由于服务的硬盘是5T，所以我们采用parted作为磁盘分区。\n\n\n### 步骤：\n- 一块硬盘要想被使用，要经过分区——>格式化——>挂载。这三个步骤\n#### 1、查看硬盘情况\n    fdisk -l\n![image](https://user-images.githubusercontent.com/28568478/117395429-7ae13980-af2a-11eb-8224-5c6240ad3401.png)\n\n#### 2、挂载2T以上的硬盘需要GPT格式，使用parted命令，细节如下:\n```\n   parted /dev/vdc\n  挂载2T以上的硬盘需要GPT格式，使用parted命令，细节如下\n  （1）parted /dev/vdc （视具体情况盘符编号）\n  （2）print （查看当前分区情况）\n  （3）mklabel gpt （设置分区类型为gpt）\n  （4）mkpart extended 0% 100% （扩展分区extended ,主分区primary ,并使用整个硬盘）\n  （5）print （查看一下）\n  （6）quit\n  （7）mkfs.ext4 /dev/vdc（格式化新硬盘，格式化需要比较长的时间，具体根据磁盘读写速度和大小来确定。下面有节点数完成对应的数量即可）\n\n```\n\n![image](https://user-images.githubusercontent.com/28568478/117395473-90eefa00-af2a-11eb-8be4-a7b565266022.png)\n![image](https://user-images.githubusercontent.com/28568478/117395479-951b1780-af2a-11eb-8b1d-226524a7935a.png)\n\n\n\n\n#### 3、挂载目录\n```\nmkdir  /data2 (在根目录下，建一个文件夹，待会将分区挂载在这个文件夹上，以后要往新硬盘存东西就存在新建文件夹下就可以了。)\nmount /dev/vdc /data2 （挂载，之后即可使用了，第二个参数是挂载到哪个目录）\n```\n![image](https://user-images.githubusercontent.com/28568478/117395486-9ba98f00-af2a-11eb-84ef-12793057ee14.png)\n\n#### 3、自动挂载\n还没有完事，这样挂载的重启整个服务器后不会自动挂载\n需要修改/etc/fstab文件，在文件最后追加\n/dev/vdc /data ext4 defaults 0 0\n```\nsudo echo \"/dev/vdc /data2 ext4 defaults 0 1\" >> /etc/fstab       让系统开机自动挂载这块硬盘\n```\n这样在重启后会自动挂载\n![image](https://user-images.githubusercontent.com/28568478/117395551-bbd94e00-af2a-11eb-8007-4bd9d388179a.png)\n\n## 参考目录：\nhttps://blog.51cto.com/devin223/2175078\nhttps://blog.csdn.net/glongljl/article/details/80104569\n[fdisk和parted磁盘分区工具命令](https://blog.csdn.net/reliveIT/article/details/44602959)\n[磁盘挂载问题：Fdisk最大只能创建2T分区的盘，超过2T使用parted](https://blog.csdn.net/xianjuke008/article/details/88354466)\n[linux下（fdisk,gdisk,parted）三种分区工具比较](https://www.cnblogs.com/zhaojiedi1992/p/zhaojiedi_linux_039_fdisk_gdisk_parted.html)\n","tags":["硬盘挂载"],"categories":["Linux"]},{"title":"linux 新添加的硬盘格式化并挂载到目录下","url":"/2021/05/07/Linux/linux 新添加的硬盘格式化并挂载到目录下/","content":"\n\n需求: 新增加一块硬盘sdb，将sdb分区，只分一个区，格式化，挂载到目录/ssd下。\n\n### 1、  查看现在已有的分区状态\n```\ndf –l\ndf -h\n```\n![image](https://user-images.githubusercontent.com/28568478/117395814-491ca280-af2b-11eb-8e34-b84381e67aa8.png)\n\n图中显示，没有看到sdb硬盘\n<!--more-->\n### 2、  查看服务器安装的硬盘状态（包括格式化和未格式化）\n```\nfdisk –l\n```\n\n![image](https://user-images.githubusercontent.com/28568478/117395838-56399180-af2b-11eb-8651-47c79b52057f.png)\n\n图中显示，有sdb硬盘，但是没有分区。\n\n### 3、  添加新分区\n```\nfdisk /dev/sdb\n```\n![image](https://user-images.githubusercontent.com/28568478/117395863-6b162500-af2b-11eb-8a91-9e72f69c44fc.png)\n```\n按照以下红框输入\n\nN 回车\n\nP 回车\n\n1 回车\n\n两次回车\n\nW 回车\n```\n![image](https://user-images.githubusercontent.com/28568478/117395883-7701e700-af2b-11eb-88bb-20616afd029b.png)\n\n用以下命令查看分区\n```\nfdisk –l\n```\n![image](https://user-images.githubusercontent.com/28568478/117395904-8123e580-af2b-11eb-864c-57a14b6ece56.png)\n\n图中红框显示已多出了一个分区，但是还没有格式化。\n\n### 4、  格式化分区\n\ncentos6文件系统是ext4，因为设计较早，对于现今动辄上T的海量数据处理，性能较低。centos7文件系统是xfs，适用于海量数据。这两种文件系统都是日志文件系统。使用该文件系统的磁盘，空间包括两部分：日志空间和存储空间。写入的数据是先暂存在日志空间，然后刷入存储空间，这样有利于恢复数据。另外，xfs文件系统还支持将一块儿固态硬盘用作单独的日志空间盘，数据先写入固态硬盘，然后再刷入硬盘。对于操作系统来说，数据写入了日志空间盘，就算完成了I/O，因此这种方式提高了系统性能。\n```\n# mkfs -t ext4 -c /dev/sdb1\n# -t 制定要把磁盘格式化成什么类型\n# -c 在建立文件系统之前检查坏道，可能会很费时间，新硬盘一般不需要\n\n# 新硬盘可直接用此命令 格式化成不同类型的硬盘\nsudo mkfs.ext4 /dev/nvme1n1\n\nmkfs.xfs -f /dev/vdb\n\n# 查看硬盘类型\ndf -T\n```\n![image](https://user-images.githubusercontent.com/28568478/117395938-926cf200-af2b-11eb-9502-7b04a448c146.png)\n![image](https://user-images.githubusercontent.com/28568478/117395944-96007900-af2b-11eb-8797-4e08db65d265.png)\n\n### 5、  挂载新硬盘\n\n在根目录下，建一个文件夹，待会将分区挂载在这个文件夹上，以后要往新硬盘存东西就存在新建文件夹下就可以了。\n```\nmkdir /ssd\n```\n\n挂载硬盘\n\n```\nmount /dev/sdb1 /ssd\n```\n![image](https://user-images.githubusercontent.com/28568478/117395965-a153a480-af2b-11eb-9bed-22f5f33c9908.png)\n\n```\n sudo chown ec2-user:root /data1   用户权限\n```\n\n### 6、  让系统开机自动挂载这块硬盘\n\n```\necho \"/dev/sda1 /ssd ext4 defaults 0 0\" >> /etc/fstab\n```\n\n如果报错：\n```\n先更改权限\nsudo chown ec2-user:root  /etc/fstab\n```\n![image](https://user-images.githubusercontent.com/28568478/117396002-ae709380-af2b-11eb-8cb4-66d295993e02.png)\n\n\n## 注意：\n\n挂载硬盘\n```\nsudo mount  /dev/nvme1n1  /data1\n```\n\n取消挂载\n```\nsudo umount  /dev/nvme1n1\n```\n\n如果 /data1里原先有数据 他会自己保留 取消挂载后 会恢复回来\n\n## 查看文件夹大小\n```\ndu -h ./scheduler/\n\ndu -sh ./scheduler/\n\n参数解释\n\n-a ： 列出所有的文件与目录容量，因为默认仅统计目录的容量而已\n\n-h: 以人们较易读的容量格式呈现(G/M/K)显示，自动选择显示的单位大小\n\n-s : 列出总量而已，而不列出每个个别的目录占用容量\n\n-k ： 以KB为单位进行显示\n\n-m : 以MB为单位进行显示常用[命令](https://www.linuxcool.com/)参考  查看当前目录大小\n```\n\n\n参考文档：\n    [linux下查看硬盘信息、硬盘分区、格式化、挂载、及swap分区](https://blog.csdn.net/Ayhan_huang/article/details/72801647)\n    [linux 新添加的硬盘格式化并挂载到目录下](https://www.cnblogs.com/ddbear/p/7009736.html)\n","tags":["硬盘挂载"],"categories":["Linux"]},{"title":"Navicat Premium 15.0.21 强大的数据库管理工具(Big Sur 可用)","url":"/2021/05/07/tools/Navicat Premium 15.0.21 强大的数据库管理工具(Big Sur 可用)/","content":"Navicat Premium 15.0.21 强大的数据库管理工具(Big Sur 可用)\n链接： https://xclient.info/s/navicat-premium.html#versions\n","tags":["macOS","Navicat"],"categories":["工具"]},{"title":"Mysql5.7使用group by查询时order by无效问题","url":"/2021/05/07/数据库/Mysql5.7使用group by查询时order by无效问题/","content":"Mysql5.7使用group by查询时order by无效问题\n第一种写法：\n```\nSELECT\n\t*\nFROM\n\tuser_paper_relation\nWHERE\n\tpaper_id = \"\"\nGROUP BY\n\texamer_id\nORDER BY\n\ttotal_score DESC\n```\n问题：发现先执行的group by，后执行order by，我要的结果是先排序再分组。\n\n第二种写法：\n```\nSELECT\n\t*\nFROM\n\t( SELECT * FROM user_paper_relation WHERE paper_id = \"\"  ORDER BY consuming_time DESC ) u\nGROUP BY\n\tu.examer_id\n```\n问题：本以为将排序写成一个子查询应该会先排序后分组，执行后发现问题同第一种写法一样。\n\n第三种写法（最终解决的写法）：\n```\nSELECT\n\ta.*\nFROM\n\t(\n\tSELECT\n\t\t*\n\tFROM\n\t\tuser_paper_relation\n\tWHERE\n\t\tpaper_id = \"\"\n\tORDER BY\n\t\tconsuming_time\n\t\tLIMIT 0,\n\t\t300\n\t) a\nGROUP BY\n\ta.examer_id\n```\n解决方式：在子查询中添加LIMIT 0,300则可使子查询语句即排序执行完再进行分组。\n\n问题原因\n```\n原因：在mysql5.7中，如果不加limit，系统会把order by优化掉。\n在mysql5.7手册的8.2.2.1中有解释：\n子查询的优化是使用半连接的策略完成的(The optimizer uses semi-join strategies to improve subquery execution)\n使用半连接进行优化，子查询语句必须满足一些标准(In MySQL, a subquery must satisfy these criteria to be handled as a semi-join)。\n其中一个标准是:必须不是一个包含了limit和order by的语句(It must not have ORDER BY with LIMIT.)\n```\n原文链接：https://blog.csdn.net/weiwoyonzhe/article/details/82888281\n","tags":["mysql"],"categories":["数据库"]},{"title":"Can't connect to local MySQL server through socket'/var/run/mysqld/mysqld.sock' (2)","url":"/2021/05/07/数据库/Can't connect to local MySQL server through/","content":"启动命令mysql时报错：\n\nERROR2002 (HY000): Can't connect to local MySQL server through socket'/var/run/mysqld/mysqld.sock' (2)\n\n解决方法：\n\n找到配置文件/etc/mysql/conf.d/mysql.cnf添加\n\n[mysql]\n\nprotocol=tcp\n\n参考文献：https://www.cnblogs.com/zhao123h/p/5207622.html\n","tags":["mysql"],"categories":["数据库"]},{"title":"linux安装redis 完整步骤","url":"/2021/05/07/数据库/linux安装redis 完整步骤/","content":"## 安装：\n\n### 1.获取redis资源\n```\n　　wget http://download.redis.io/releases/redis-4.0.8.tar.gz\n```\n### 2.解压\n```\n　　tar xzvf redis-4.0.8.tar.gz\n```\n### 3.安装\n```\n　　cd redis-4.0.8\n\n　　make\n\n　　cd src\n\n　　make install PREFIX=/usr/local/redis\n```\n### 4.移动配置文件到安装目录下\n```\n　　cd ../\n\n　　mkdir /usr/local/redis/etc\n\n　　mv redis.conf /usr/local/redis/etc\n```\n### 5.配置redis为后台启动\n```\nvi /usr/local/redis/etc/redis.conf // 将daemonize no 改成daemonize yes\n```\n### 6.将redis加入到开机启动\n```\n　　vi /etc/rc.local // 在里面添加内容：/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf (意思就是开机调用这段开启redis的命令)\n```\n### 7.开启redis\n```\n　　/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf\n```\n\n```\n常用命令\n\n　　redis-server /usr/local/redis/etc/redis.conf //启动redis\n\n　　pkill redis  //停止redis\n\n卸载redis：\n\n　　rm -rf /usr/local/redis //删除安装目录\n\n　　rm -rf /usr/bin/redis-* //删除所有redis相关命令脚本\n\n　　rm -rf /root/download/redis-4.0.4 //删除redis解压文件夹\n```\n","tags":["redis"],"categories":["数据库"]},{"title":"Linux安装MySQL","url":"/2021/05/07/数据库/Linux安装MySQL/","content":"\n\n## 一、安装\n\nsudo apt update\n\nsudo apt-get install mysql-server  # 安装MySQL服务端\n\n以上两个命令 即安装成功\n\n<!--more-->\n\n## 二、安装后的密码问题\n\nsudo cat /etc/mysql/debian.cnf 查看默认的用户名和密码\n\n\n## 三、添加自己的密码\n\n- 1、use mysql; 然后敲回车\n\n- 2、update user set authentication_string=password(\"你的密码\") where user=\"root\"; 然后敲回车\n\n- 3、flush privileges; 然后敲回车\n\n用账户密码登录时发现报错\n\nERROR 1698 (28000): Access denied for user 'root'@'localhost'\n\n解决方法如下：\n\n* step1：在ubuntu的terminal（也即终端）上输入：\n\n        sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf,\n\n        进入到这个配置文件，\n\n        然后在这个配置文件中的[mysqld]这一块中加入skip-grant-tables这句话。\n\n        保存:wq，退出。输入：service mysql restart，重新启动mysql。\n\n* step2：在终端上输入mysql -u root -p，遇见输入密码的提示直接回车即可,进入mysql后，分别执行下面三句话：\n\n        1、use mysql; 然后敲回车\n\n        2、update user set authentication_string=password(\"你的密码\") where user=\"root\"; 然后敲回车\n\n        3、flush privileges; 然后敲回车\n\n\n\n* step3：重新进入到mysqld.cnf文件中去把刚开始加的skip-grant-tables这条语句给注释掉。\n\n            再返回终端输入mysql -u root -p，应该就可以进入数据库了。\n\n* step4：如果此时还是报出错误，那么就需要返回step3中，把注释掉的那条语句重新生效（就是删除#符号），重新进入mysql中，先选择一个数据库（use mysql;）,然后输入select user,plugin from user;，看下图：\n\n\n\n\n从图中可以看到在执行了select user,plugin from user;后，错误原因是因为plugin root的字段是auth_socket，那我们改掉它为下面的mysql_native_password就行了。输入：\n\n1、update user set authentication_string=password(\"你的密码\"),plugin='mysql_native_password' where user='root';\n\n\n\n最后quit退出。返回执行step3。\n\n那么这个问题就完全解决了\n\n\n\n\n\n参考链接：https://www.cnblogs.com/cpl9412290130/p/9583868.html\n","tags":["mysql"],"categories":["数据库"]},{"title":"Mac下MySQL-python安装及EnvironmentError mysql_config not found的解决办法","url":"/2021/05/07/数据库/Mac下MySQL-python安装及EnvironmentError: mysql_config not found的解决办法/","content":"今天  pip install MySQL-python==1.2.5  报如下错误：\n```\nEnvironmentError: mysql_config not found\n\nCommand \"python setup.py egg_info\" failed with error code 1 in /private/var/folders/6h/hchh3z9d6b33h11qh0wh__dh0000gn/T/pip-install-Rm43Qv/MySQL-python/\n\n```\n\n![image](https://user-images.githubusercontent.com/28568478/117392434-a6f9bc00-af24-11eb-836c-f51c7a67ae47.png)\n\n解决方法如下：\n\n1）首先需要进行Python的安装\n\n（2）进行mysql的安装，多种方式，偷懒一些可以直接使用brew指令\n\nbrew install mysql\n\n（3）mysql_config not found的造成原因就是因为我们默认安装的路径没有被填加进去，所以使用export命令来设置下环境变量：\n\nexport PATH=$PATH:/usr/local/mysql/bin\n\n（4）进行MySQL-Python的安装：\n\npip install MySQL-Python\n\n原文：https://blog.csdn.net/Megustas_JJC/article/details/78955958\n","tags":["mysql"],"categories":["数据库"]},{"title":"mac 安装redis、mysql、MongoDB","url":"/2021/05/07/数据库/mac 安装redis、mysql、MongoDB/","content":"## redis 安装\n* brew install redis\n#### 启动\n* brew services start redis（后台启动）\n* redis-server /usr/local/etc/redis.conf （非后台启动）\n\n<!--more-->\n\n## mysql 安装\n* brew install mysql\n#### 启动\n* brew services start mysql（后台启动）\n* mysql.server start（非后台启动）\n* 没有详细的配置文件，可参考其他系统下的my.cnf进行自我配置\n\n![image](https://user-images.githubusercontent.com/28568478/117404953-6d817a80-af3d-11eb-8663-cb188d59b022.png)\n\n1、我们在没有root 密码的情况下安装了您的MySQL数据库。确保它运行：mysql_secure_installation\n2、登录mysql: mysql -uroot\n3、如果忘记密码：\n```\ncd /usr/local/bin/mysql/\n./mysqld_safe --skip-grant-tables &  # 禁止mysql验证功能\n./mysql  # 进入mysql\nFLUSH PRIVILEGES;\nSET PASSWORD FOR 'root'@'localhost' = '你的新密码';\n```\n\n4、![image](https://user-images.githubusercontent.com/28568478/117405005-825e0e00-af3d-11eb-8a6e-20ae85e72642.png)\n ```\nALTER USER root@localhost IDENTIFIED WITH mysql_native_password BY ‘你的密码’;\n```\n##  mongodb 安装\n* brew install mongodb\n\n#### 启动\n* brew services start mongodb （后台启动）\n* mongod --config /usr/local/etc/mongod.conf （非后台启动）\n","tags":["macOS","mysql","mongodb","redis"],"categories":["数据库"]},{"title":"Ubuntu18.04 安装mysql","url":"/2021/05/07/数据库/Ubuntu18.04 安装mysql/","content":"## 一、安装方法\n[Ubuntu18.04下安装MySQL](https://www.cnblogs.com/opsprobe/p/9126864.html)\n\n<!--more-->\n\n## 二、常用命令\n\n　　1.启动：/etc/init.d/mysql start\nsudo service mysql restart\n\n　　2.停止：/etc/init.d/mysql stop\n\n　　3.重启：/etc/init.d/mysql restart\n##  三、报错\n#### 1、[Can't connect to MySQL server on '<remote-ip>' (61)](https://my.oschina.net/Laily/blog/712958)\n第一次安装可能是3306 只监听了localhost ，修改配置文件/etc/mysql/mysql.conf.d/mysqld.cnf中的bind-address为0.0.0.0即可\n![image](https://user-images.githubusercontent.com/28568478/117405298-fef0ec80-af3d-11eb-9d77-3c2cb8079e64.png)\n\n#### 2、权限不够\n```\n（1）SSH登录root管理员账户\n\n（2）登录MySql\n\n  mysql -u root -p\nEnter password:\n（3）执行授权命令\n\nmysql> grant all privileges on *.* to root@'localhost' identified by '密码';\nmysql> flush privileges;\n或\n\nmysql> grant all privileges on *.* to root@'%' identified by '密码';\nmysql> flush privileges;\n（4）退出再试\n\nmysql> quit\nBye\n（5）再次登录\n```\n\n## 四、 supervisor 配置(可不用配置 默认后台自启动)\n```\n[program:mysql_3306]\ncommand=/usr/sbin/mysqld --daemonize --pid-file=/run/mysqld/mysqld.pid\nprocess_name=mysql_3306\nnumprocs=1\n;user=martin\nautostart=true\nautorestart=true\nstartsecs=10\nstartretries=7\nstopsignal=TERM\nstopwaitsecs=60\nredirect_stderr=false\nstdout_logfile=/root/log/mysql/mysql.log\nstdout_logfile_maxbytes=50MB\nstdout_logfile_backups=10\nstdout_capture_maxbytes=1MB\nstderr_logfile=/root/log/mysql/mysql_error.log\nstderr_logfile_maxbytes=50MB\nstderr_logfile_backups=10\nstderr_capture_maxbytes=1MB\n;directory=/home/martin/data/logagent\nserverurl=AUTO\n```\n","tags":["mysql"],"categories":["数据库"]},{"title":"Ubuntu18.04 安装redis","url":"/2021/05/07/数据库/Ubuntu18.04 安装redis/","content":"### 一、安装\n```\nsudo apt install redis   # 安装redis\n\ncd /etc/redis/redis.conf # 变更配置\n注释bind 127.0.0.1 ::1\n加 bind 0.0.0.0\n```\n\n### 二、命令\n```\nbin/sh /etc/init.d/redis-server start/stop/restart\nsystemctl start/stop/restart redis-server\n/usr/bin/redis-server # 只是启动\n```\n","tags":["redis"],"categories":["数据库"]},{"title":"Ubuntu 18.04 安装MongoDB","url":"/2021/05/07/数据库/Ubuntu 18.04 安装MongoDB/","content":"### 第1步 – 导入公钥\n```\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6\n```\n### 第2步 – 创建源列表文件MongoDB\n```\necho \"deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.4 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list\n```\n<!--more-->\n### 第3步 – 更新存储库\n```\nsudo apt update\n\n```\n### 第4步 – 安装MongoDB\n```\nsudo apt install -y mongodb-org\n```\n### 第5– 步修改配置\n```\nnet:\n  port: 27017         # 端口号\n  bindIp: 0.0.0.0    # 允许访问host\nsetParameter:\n   enableLocalhostAuthBypass: false # 大意为开启授权\n```\n### 新建目录\n\n为什么要创建这样这个文件夹呢？看其他人的说法是这个：\n\nMongoDB的数据存储在data目录的db目录下，但是这个目录在安装过程不会自动创建，所以你需要手动创建data目录，并在data目录中创建db目录。\n\n然后等待完成就可以使用MongoDB了，输入mongo进入命令行就可以操作了。\n```\nmkdir -p /data/db\n```\n### 命令\n```\n/usr/bin/mongod --config /etc/mongod.conf -dbpath /data/db/\n```\n","tags":["mongodb"],"categories":["数据库"]},{"title":"Mysql命令行查看数据库大小(数据库版本为5.7以上)","url":"/2021/05/07/数据库/Mysql命令行查看数据库大小(数据库版本为5.7以上)/","content":"\n数据库版本为5.7以上\n1、选择数据库\n```\nuse mydb1;\n```\n2、查看指定数据库表结构\n```\nselect * from information_schema.TABLES where information_schema.TABLES.TABLE_SCHEMA='mydb1';\n```\n3、查看指定数据库的大小\n比如说 数据库mydb1\n```\nselect concat(round(sum(DATA_LENGTH/1024/1024),2), 'MB') as data from information_schema.TABLES where information_schema.TABLES.TABLE_SCHEMA='mydb1';\n```\n4、查看指定数据库的表的大小\n比如说 数据库mydb1中b1表\n```\nselect concat(round(sum(DATA_LENGTH/1024/1024),2), 'MB') as data from information_schema.TABLES where information_schema.TABLES.TABLE_SCHEMA='mydb1' and TABLE_NAME='b1';\n```\n","tags":["mysql"],"categories":["数据库"]},{"title":"SQL的模糊匹配区别---like,rlike,regexpx","url":"/2021/05/07/数据库/SQL的模糊匹配区别---like,rlike,regexpx/","content":"\n\n\n## 一、主要区别\n- (1) like的内容不是正则，而是通配符。像mysql中的\"like\",但是建议使用高级函数\"instr\"效率更高。\n\n- (2) rlike的内容可以是正则，正则的写法与java一样。需要转义，例如’\\m’需要使用’\\m’\n\n- (3) regexp == rlike 同义词 not like not regexp\n\n\n<!--more-->\n\n## 二、Like常用方法\n### 1.like关键字\nlike有两个模式：_和%\n\n_：表示单个字符，用来查询定长的数据\n\n%：表示0个或多个任意字符\n\n### 2.示例\n```\n（1）SELECT * FROM Persons  WHERE City LIKE 'N%'     \"Persons\" 表中选取居住在以 \"N\" 开始的城市里的人\n（2）SELECT * FROM Persons  WHERE City LIKE '%g'     \"Persons\" 表中选取居住在以 \"g\" 结尾的城市里的人\n（3）SELECT * FROM Persons   WHERE City LIKE '%lon%'  从 \"Persons\" 表中选取居住在包含 \"lon\" 的城市里的人\n（4）SELECT * FROM Persons   WHERE City NOT LIKE '%lon%'  从 \"Persons\" 表中选取居住在不包含 \"lon\" 的城市里的人\n```\n## 三、Mysql中Regexp常见用法\n\n* 模糊匹配，包含特定字符串\n```\n  #查找content字段中包含“车友俱乐部”的记录\n select * from club_content where content regexp '车友俱乐部'\n\n# 此时的regexp与like的以下用法是等同的\nselect * from club_content where content like '%车友俱乐部%'\n```\n* 模糊匹配，以特定字符串开头\n```\n# 查找content字段中以“车友”开头的记录\nselect * from club_content where content regexp '^车友'\n\n# 此时的regexp与like的以下用法是等同的\nselect * from club_content where content like '车友%'\n```\n\n* 模糊匹配，以特定字符串结尾\n```\n# 查找content字段中以“车友”结尾的记录\nselect * from club_content where content regexp '车友$'\n\n# 此时的regexp与like的以下用法是等同的\nselect * from club_content where content like '%车友'\n```\n* 模糊匹配 或关系\n```\n# 查找content字段中包含“心得”、“分享”或“技术贴”\nselect * from club_content where content  REGEXP '心得|分享|技术贴'\n```\n* 模糊匹配，不包含单个字符\n```\n# 查找content字段中不包含“车”字、“友”字的记录\nselect * from club_content where content  REGEXP [^车友]\n```\n这个结果跑出来一看大吃一惊，竟然把所有记录给跑出来，这是为什么呢？\n因为一旦加了这个方括号\"[]\"，它就把里面的内容拆成单个的字符再匹配，它会逐个字符去匹配判断是不是等于“车”，或者是不是等于“友“，返回的结果是一组0、1的逻辑值。\n\n如果想匹配不包含特定字符串，该怎么实现呢？\n\n模糊匹配，不包含特定字符串\n```\n# 查找content字段不包含“车友”字符串的记录\nselect * from club_content where content not REGEXP '车友'\n```\n\n```\n交集\n表的字段就是\nname  no\na     2,9\nb     8,10\n字符串是str=\"0,1,2,3,4\"\n接下来就是查 no字段里跟str里有交集的记录\n查询的结果就是name=a的,no=2,9的\nselect * from table1 where concat(',',no,',') regexp concat(',0,|,1,|,2,|,3,|,4,');\n\n某字段中搜索\n可以使用FIND_IN_SET\nname  no\na     2,9\nb     8,10\n想查出no中包含2的记录\nselect * from table1 where FIND_IN_SET('2', no)\n\n替换某字段中的内容\nUPDATE `blog_iplimit` SET `ip` = REPLACE(`ip`, ',', '')\n```\n原文链接：https://blog.csdn.net/ZZQHELLO2018/java/article/details/92794555\n","tags":["mysql","sql"],"categories":["数据库"]},{"title":"macOS pip 安装 mysqlclient 报错","url":"/2021/05/07/数据库/macOS pip 安装 mysqlclient 报错/","content":"\n```\nld: library not found for -lssl\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\nerror: command 'clang' failed with exit status 1\n```\n```\nexport LIBRARY_PATH=$LIBRARY_PATH:/usr/local/opt/openssl/lib/\n```\n然后再安装\n","tags":["macOS","mysql","mysqlclient"],"categories":["数据库"]},{"title":"mysql  show slave status 状态详解","url":"/2021/05/07/数据库/mysql  show slave status 状态详解/","content":"MySQL同步功能由3个线程(master上1个，slave上2个)来实现。执行 DE>START SLAVEDE> 语句后，slave就创建一个I/O线程。I/O线程连接到master上，并请求master发送二进制日志中的语句。master创建一个线程来把日志的内容发送到slave上。这个线程在master上执行 DE>SHOW PROCESSLISTDE> 语句后的结果中的 DE>Binlog DumpDE> 线程便是。slave上的I/O线程读取master的 DE>Binlog DumpDE> 线程发送的语句，并且把它们拷贝到其数据目录下的中继日志(relay logs)中。第三个是SQL线程，salve用它来读取中继日志，然后执行它们来更新数据。\n\n如上所述，每个master/slave上都有3个线程。每个master上有多个线程，它为每个slave连接都创建一个线程，每个slave只有I/O和SQL线程。\n\nshow slave master 用于提供有关从属服务器线程的关键参数的信息:\n<!--more-->\n```\nmysql> show slave status \\G;\n*************************** 1. row ***************************\n               Slave_IO_State: Waiting for master to send event\n                Master_Host: 172.17.2.40\n                Master_User: photorepl\n                Master_Port: 4331\n               Connect_Retry: 60\n               Master_Log_File: mysql-bin.005502\n                Read_Master_Log_Pos: 64401238\n               Relay_Log_File: mysqld-relay-bin.015418\n               Relay_Log_Pos: 13456757\n               Relay_Master_Log_File: mysql-bin.005152\n               Slave_IO_Running: Yes\n              Slave_SQL_Running: Yes\n               Replicate_Do_DB:\n               Replicate_Ignore_DB: mysql\n               Replicate_Do_Table:\n               Replicate_Ignore_Table:\n               Replicate_Wild_Do_Table: photo.%\n               Replicate_Wild_Ignore_Table: mysql.%\n                 Last_Errno: 0\n                 Last_Error:\n               Skip_Counter: 0\n               Exec_Master_Log_Pos: 13456620\n              Relay_Log_Space: 36764898503\n               Until_Condition: None\n              Until_Log_File:\n              Until_Log_Pos: 0\n              Master_SSL_Allowed: No\n             Master_SSL_CA_File:\n             Master_SSL_CA_Path:\n              Master_SSL_Cert:\n              Master_SSL_Cipher:\n             Master_SSL_Key:\n            Seconds_Behind_Master: 249904\n××××××××××××××××××××××××××××××××××××××××××××××××××××××××××\n```\n\nSHOW SLAVE STATUS会返回以下字段：\n```\n Slave_IO_State\n\nSHOW PROCESSLIST输出的State字段的拷贝。SHOW PROCESSLIST用于从属I/O线程。如果线程正在试图连接到主服务器，正在等待来自主服务器的时间或正在连接到主服务器等，本语句会通知您\n\n Master_User\n\n被用于连接主服务器的当前用户。\n\nMaster_Port\n\n当前的主服务器接口。\n\nConnect_Retry\n\n--master-connect-retry选项的当前值\n\nMaster_Log_File\n\nI/O线程当前正在读取的主服务器二进制日志文件的名称。\n\nRead_Master_Log_Pos\n\n在当前的主服务器二进制日志中，I/O线程已经读取的位置。\n\nRelay_Log_File\n\nSQL线程当前正在读取和执行的中继日志文件的名称。\n\nRelay_Log_Pos\n\n在当前的中继日志中，SQL线程已读取和执行的位置。\n\nRelay_Master_Log_File\n\n由SQL线程执行的包含多数近期事件的主服务器二进制日志文件的名称。\n\nSlave_IO_Running\n\nI/O线程是否被启动并成功地连接到主服务器上。\n\nSlave_SQL_Running\n\nSQL线程是否被启动。\n\nReplicate_Do_DB,Replicate_Ignore_DB\n\n使用--replicate-do-db和--replicate-ignore-db选项指定的数据库清单。\n\nReplicate_Do_Table,Replicate_Ignore_Table,Replicate_Wild_Do_Table,Replicate_Wild_Ignore_Table\n\n使用--replicate-do-table,--replicate-ignore-table,--replicate-wild-do-table和--replicate-wild-ignore_table选项指定的表清单。\n\nLast_Errno,Last_Error\n\n被多数最近被执行的查询返回的错误数量和错误消息。错误数量为0并且消息为空字符串意味着“没有错误”。如果Last_Error值不是空值，它也会在从属服务器的错误日志中作为消息显示。\n\n举例说明：\n\nLast_Errno: 1051\n\nLast_Error: error 'Unknown table 'z'' on query 'drop table z'\n\n该消息指示，表z曾经存在于在主服务器中并已被取消了，但是它没有在从属服务器中存在过，因此对于从属服务器，DROP TABLE失败。（举例说明，在设置复制时，如果您忘记了把此表拷贝到从属服务器中，则这有可能发生。）\n\nSkip_Counter\n\n最近被使用的用于SQL_SLAVE_SKIP_COUNTER的值。\n\nExec_Master_Log_Pos\n\n来自主服务器的二进制日志的由SQL线程执行的上一个时间的位置（Relay_Master_Log_File）。在主服务器的二进制日志中的(Relay_Master_Log_File,Exec_Master_Log_Pos)对应于在中继日志中的(Relay_Log_File,Relay_Log_Pos)。\n\nRelay_Log_Space\n\n所有原有的中继日志结合起来的总大小。\n\nUntil_Condition,Until_Log_File,Until_Log_Pos\n\n在START SLAVE语句的UNTIL子句中指定的值。\n\nUntil_Condition具有以下值：\n\n如果没有指定UNTIL子句，则没有值\n\n如果从属服务器正在读取，直到达到主服务器的二进制日志的给定位置为止，则值为Master\n\n如果从属服务器正在读取，直到达到其中继日志的给定位置为止，则值为Relay\n\nUntil_Log_File和Until_Log_Pos用于指示日志文件名和位置值。日志文件名和位置值定义了SQL线程在哪个点中止执行。\n\nMaster_SSL_Allowed,Master_SSL_CA_File,Master_SSL_CA_Path,Master_SSL_Cert,Master_SSL_Cipher,Master_SSL_Key\n\n这些字段显示了被从属服务器使用的参数。这些参数用于连接主服务器。\n\nMaster_SSL_Allowed具有以下值：\n\n如果允许对主服务器进行SSL连接，则值为Yes\n\n如果不允许对主服务器进行SSL连接，则值为No\n\n如果允许SSL连接，但是从属服务器没有让SSL支持被启用，则值为Ignored。\n\n与SSL有关的字段的值对应于--master-ca,--master-capath,--master-cert,--master-cipher和--master-key选项的值。\n\nSeconds_Behind_Master\n\n本字段是从属服务器“落后”多少的一个指示。当从属SQL线程正在运行时（处理更新），本字段为在主服务器上由此线程执行的最近的一个事件的时间标记开始，已经过的秒数。当此线程被从属服务器I/O线程赶上，并进入闲置状态，等待来自I/O线程的更多的事件时，本字段为零。总之，本字段测量从属服务器SQL线程和从属服务器I/O线程之间的时间差距，单位以秒计。\n\n如果主服务器和从属服务器之间的网络连接较快，则从属服务器I/O线程会非常接近主服务器，所以本字段能够十分近似地指示，从属服务器SQL线程比主服务器落后多少。如果网络较慢，则这种指示不准确；从属SQL线程经常会赶上读取速度较慢地从属服务器I/O线程，因此，Seconds_Behind_Master经常显示值为0。即使I/O线程落后于主服务器时，也是如此。换句话说，本列只对速度快的网络有用。\n\n即使主服务器和从属服务器不具有相同的时钟，时间差计算也会起作用（当从属服务器I/O线程启动时，计算时间差。并假定从此时以后，时间差保持不变）。如果从属SQL线程不运行，或者如果从属服务器I/O线程不运行或未与主服务器连接，则Seconds_Behind_Master为NULL（意义为“未知”）。举例说明，如果在重新连接之前，从属服务器I/O线程休眠了master-connect-retry秒，则显示NULL，因为从属服务器不知道主服务器正在做什么，也不能有把握地说落后多少。\n```\n","tags":["mysql"],"categories":["数据库"]},{"title":"percona-toolkit工具（数据一致性监测、延迟监控）使用梳理","url":"/2021/05/07/tools/percona-toolkit工具（数据一致性监测、延迟监控）使用梳理/","content":"[原文链接: MySQL 主从同步(3)-percona-toolkit工具（数据一致性监测、延迟监控）使用梳理\n](https://www.cnblogs.com/kevingrace/p/6261091.html)\n","tags":["percona-toolkit","监控","监测","一致性"],"categories":["工具"]},{"title":"Django的Model中不创建表格，并设为基类方法","url":"/2021/05/07/django/Django的Model中不创建表格，并设为基类方法/","content":"\n\n```\nclass UserInfo(models.Model):\n    \"\"\"用户表\"\"\"\n    name = models.CharField(verbose_name='用户名', max_length=32)\n    ...\n\n    class Meta:\n        # 此类可以当做父类，被其他model继承。字段自动过度给，继承的model\n        abstract = True  # 【django以后做数据库迁移时， 不再为UserInfo类创建相关的表以及表结构了】\n\n\n# app01/models.py\nclass UserInfo(RbacUserInfo):  # 继承上面那个userinfo\n    \"\"\"用户表\"\"\"\n    phone = models.CharField(verbose_name='联系方式', max_length=32)\n    depart = models.ForeignKey(verbose_name='部门', to='Department', on_delete=models.CASCADE)\n```\n首先介绍下django的模型有哪些属性：\n\n先看例子：\n\nDjango 模型类的Meta是一个内部类，它用于定义一些Django模型类的行为特性。以下对此作一总结：\n\nabstract\n 这个属性是定义当前的模型类是不是一个抽象类。所谓抽象类是不会对应数据库表的。一般我们用它来归纳一些公共属性字段，然后继承它的子类可以继承这些字段。比如下面的代码中Human是一个抽象类，Employee是一个继承了Human的子类，那么在运行syncdb命令时，不会生成Human表，但是会生成一个Employee表，它包含了Human中继承来的字段，以后如果再添加一个Customer模型类，它可以同样继承Human的公共属性：\n <!--more-->\n```\nclass Human(models.Model):\n    name=models.CharField(max_length=100)\n    GENDER_CHOICE=((u'M',u'Male'),(u'F',u'Female'),)\n    gender=models.CharField(max_length=2,choices=GENDER_CHOICE,null=True)\n    class Meta:\n        abstract=True\nclass Employee(Human):\n    joint_date=models.DateField()\nclass Customer(Human):\n    first_name=models.CharField(max_length=100)\n    birth_day=models.DateField()\n```\n\n上面的代码，执行python manage.py syncdb 后的输出结果入下，可以看出Human表并没有被创建:\n```\n$ python manage.py syncdb\nCreating tables ...\nCreating table myapp_employee\nCreating table myapp_customer\nInstalling custom SQL ...\nInstalling indexes ...\nNo fixtures found.\n•app_label\n```\n\napp_label这个选项只在一种情况下使用，就是你的模型类不在默认的应用程序包下的models.py文件中，这时候你需要指定你这个模型类是那个应用程序的。比如你在其他地方写了一个模型类，而这个模型类是属于myapp的，那么你这是需要指定为：\n```\napp_label='myapp'\n•db_table\n```\ndb_table是用于指定自定义数据库表名的。Django有一套默认的按照一定规则生成数据模型对应的数据库表名，如果你想使用自定义的表名，就通过这个属性指定，比如：\n```\ntable_name='my_owner_table'\n•db_tablespace\n```\n有些数据库有数据库表空间，比如Oracle。你可以通过db_tablespace来指定这个模型对应的数据库表放在哪个数据库表空间。\n```\n•get_latest_by\n```\n由于Django的管理方法中有个lastest()方法，就是得到最近一行记录。如果你的数据模型中有 DateField 或 DateTimeField 类型的字段，你可以通过这个选项来指定lastest()是按照哪个字段进行选取的。\n```\n•managed\n```\n由于Django会自动根据模型类生成映射的数据库表，如果你不希望Django这么做，可以把managed的值设置为False。\n```\n•order_with_respect_to\n```\n这个选项一般用于多对多的关系中，它指向一个关联对象。就是说关联对象找到这个对象后它是经过排序的。指定这个属性后你会得到一个get_XXX_order()和set_XXX_order（）的方法,通过它们你可以设置或者回去排序的对象。\n```\n•ordering\n```\n这个字段是告诉Django模型对象返回的记录结果集是按照哪个字段排序的。比如下面的代码：\n```\nordering=['order_date'] # 按订单升序排列\nordering=['-order_date'] # 按订单降序排列，-表示降序\nordering=['?order_date'] # 随机排序，？表示随机\n•permissions\npermissions主要是为了在Django Admin管理模块下使用的，如果你设置了这个属性可以让指定的方法权限描述更清晰可读。\n•proxy\n这是为了实现代理模型使用的，这里先不讲随后的文章介绍。\n•unique_together\n```\n```\nunique_together这个选项用于：当你需要通过两个字段保持唯一性时使用。比如假设你希望，一个Person的FirstName和LastName两者的组合必须是唯一的，那么需要这样设置：\nunique_together = ((\"first_name\", \"last_name\"),)\n•verbose_name\nverbose_name的意思很简单，就是给你的模型类起一个更可读的名字：\nverbose_name = \"pizza\"\n•verbose_name_plural\n这个选项是指定，模型的复数形式是什么，比如：\nverbose_name_plural = \"stories\"\n如果不指定Django会自动在模型名称后加一个’s’\n```\n```\n1.class Register(models.Model):\n2.    id = models.IntegerField(primary_key = True, db_column=\"ID\")\n3.    mid = models.IntegerField(db_column = \"MID\")\n4.    name = models.CharField(max_length = 10 , db_column = \"NAME\")\n5.    nickName = models.CharField(max_length = 100 ,db_column = \"NICK_NAME\")\n6.    slo = models.CharField(max_length = 50, db_column = \"SLOGAN\")\n7.    status = models.SmallIntegerField(db_column = \"STATUS\")\n8.    cnt = models.IntegerField(db_column = \"CNT\")\n9.    createdDate = models.DateTimeField(db_column = \"CREATED_DATE\")\n10.\n11.    class Meta:\n12.        db_table = \"A111208FACTIONVOTETOP10_REGISTER\"\n13.        managed = False\n```\n\n\n原文：[django模型中的抽象类（abstract）](https://www.cnblogs.com/xuchunlin/p/5920545.html)\n","tags":["抽象类","abstract"],"categories":["django"]},{"title":"supervisor安装、配置及常用命令","url":"/2021/05/07/Linux web/supervisor安装、配置及常用命令/","content":"\n\n\n\n# **前言**\n\n在 web 应用部署到线上后，需要保证应用一直处于运行状态，在遇到程序异常、报错等情况，导致 web 应用终止时，需要保证程序可以立刻重启，继续提供服务。\n\n而Supervisor 就是解决这种问题的工具，可以提供程序崩溃后，重新把程序启动起来等功能。\n\n<!--more-->\n\n------\n\n# **简介**\n\nSupervisor 是一个用 Python 写的进程管理工具，可以很方便的用来在 UNIX-like 系统（不支持 Windows）下启动、重启（自动重启程序）、关闭进程（不仅仅是 Python 进程）。\n\n> Supervisor is a client/server system that allows its users to control a number of processes on UNIX-like operating systems.\n\n------\n\n# **安装**\n\n1、redhat/centos系统\n\n安装命令：yum install supervisor，通过这种方式安装后，自动设置为开机启动\n\n2、Ubuntu系统：\n\n安装命令：apt-get install supervisor，通过这种方式安装后，自动设置为开机启动\n\n3、pip命令（不推荐）\n\n通过 pip install supervisor 进行安装，但是需要手动启动，然后设置为开机启动。\n\n------\n\n# **Supervisor 配置**\n\nSupervisor 是一个 C/S 模型的程序，supervisord 是 server 端，supervisorctl 是 client 端。\n\n**supervisord**\n\n下面介绍 supervisord 配置方法。supervisord 的配置文件默认位于 /etc/supervisord.conf，内容如下（;后面为注释）：\n\n```\n[unix_http_server]\nfile=/tmp/supervisor.sock ;UNIX socket 文件，supervisorctl 会使用\n;chmod=0700 ;socket文件的mode，默认是0700\n;chown=nobody:nogroup ;socket文件的owner，格式：uid:gid\n;[inet_http_server] ;HTTP服务器，提供web管理界面\n;port=127.0.0.1:9001 ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性\n;username=user ;登录管理后台的用户名\n;password=123 ;登录管理后台的密码\n[supervisord]\nlogfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.log\nlogfile_maxbytes=50MB ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小\nlogfile_backups=10 ;日志文件保留备份数量默认10，设为0表示不备份\nloglevel=info ;日志级别，默认info，其它: debug,warn,trace\npidfile=/tmp/supervisord.pid ;pid 文件\nnodaemon=false ;是否在前台启动，默认是false，即以 daemon 的方式启动\nminfds=1024 ;可以打开的文件描述符的最小值，默认 1024\nminprocs=200 ;可以打开的进程数的最小值，默认 200\n[supervisorctl]\nserverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致\n;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord\n; [program:xx]是被管理的进程配置参数，xx是进程的名称\n[program:xx]\ncommand=/opt/apache-tomcat-8.0.35/bin/catalina.sh run ; 程序启动命令\nautostart=true ; 在supervisord启动的时候也自动启动\nstartsecs=10 ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒\nautorestart=true ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启\nstartretries=3 ; 启动失败自动重试次数，默认是3\nuser=tomcat ; 用哪个用户启动进程，默认是root\npriority=999 ; 进程启动优先级，默认999，值小的优先启动\nredirect_stderr=true ; 把stderr重定向到stdout，默认false\nstdout_logfile_maxbytes=20MB ; stdout 日志文件大小，默认50MB\nstdout_logfile_backups = 20 ; stdout 日志文件备份数，默认是10\n; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）\nstdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out\nstopasgroup=false ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程\nkillasgroup=false ;默认为false，向进程组发送kill信号，包括子进程\n;包含其它配置文件\n[include]\nfiles = relative/directory/*.ini ;可以指定一个或多个以.ini结束的配置文件\n```\n\n------\n\n# **配置管理进程**\n\n进程管理配置参数，不建议全都写在supervisord.conf文件中，应该每个进程写一个配置文件放在include指定的目录下包含进supervisord.conf文件中。\n\n1> 创建/etc/supervisor/config.d目录，用于存放进程管理的配置文件\n\n2> 修改/etc/supervisor/supervisord.conf中的include参数，将/etc/supervisor/conf.d目录添加到include\n\n下面是配置Tomcat进程的一个例子：\n\n```\n[program:tomcat]\ncommand=/opt/apache-tomcat-8.0.35/bin/catalina.sh run\nstdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out\nautostart=true\nautorestart=true\nstartsecs=5\npriority=1\nstopasgroup=true\nkillasgroup=true\n```\n\n------\n\n# **启动Supervisor服务**\n\n```\nsupervisord -c /etc/supervisor/supervisord.conf\n```\n\n------\n\n# Web管理界面\n\n出于安全考虑，默认配置是没有开启web管理界面，需要修改supervisord.conf配置文件打开http访权限，将下面的配置：\n\n```\n;[inet_http_server] ; inet (TCP) server disabled by default\n;port=127.0.0.1:9001 ; (ip_address:port specifier, *:port for all iface)\n;username=user ; (default is no username (open server))\n;password=123 ; (default is no password (open server))\n```\n\n修改成：\n\n```\n[inet_http_server] ; inet (TCP) server disabled by default\nport=0.0.0.0:9001 ; (ip_address:port specifier, *:port for all iface)\nusername=user ; (default is no username (open server))\npassword=123 ; (default is no password (open server))\n```\n\n\n# 注意：一定要重启supervisord服务配置才会生效\n![image](https://user-images.githubusercontent.com/28568478/117405693-98200300-af3e-11eb-9d60-ad2de6f7cf8f.png)\n重启后访问 ip:9001 (账号密码为user/123)\n\n![image](https://user-images.githubusercontent.com/28568478/117405729-a8d07900-af3e-11eb-9b65-92e32c697a91.png)\n![image](https://user-images.githubusercontent.com/28568478/117405738-ad952d00-af3e-11eb-97bd-952990e6d59e.png)\n\n\n\n\n------\n\n# **supervisorctl 操作**\n\nsupervisorctl 是 supervisord 的命令行客户端工具，使用的配置和 supervisord 一样，这里就不再说了。下面，主要介绍 supervisorctl 操作的常用命令：\n\n输入命令 supervisorctl 进入 supervisorctl 的 shell 交互界面（还是纯命令行），就可以在下面输入命令了。：\n\n- help # 查看帮助\n- status # 查看程序状态\n- stop program_name # 关闭 指定的程序\n- start program_name # 启动 指定的程序\n- restart program_name # 重启 指定的程序\n- tail -f program_name # 查看 该程序的日志\n- update # 重启配置文件修改过的程序（修改了配置，通过这个命令加载新的配置)\n\n也可以直接通过 shell 命令操作：\n\n- supervisorctl status\n- supervisorctl update\n- .....\n\n![image](https://user-images.githubusercontent.com/28568478/117405782-bdad0c80-af3e-11eb-8c93-59c6b3998e66.png)\n\n# 配置详情\n```\n[unix_http_server]\nfile=/tmp/supervisor.sock   ; socket文件的路径，supervisorctl用XML_RPC和supervisord通信就是通过它进行\n                              的。如果不设置的话，supervisorctl也就不能用了\n                              不设置的话，默认为none。 非必须设置\n;chmod=0700                 ; 这个简单，就是修改上面的那个socket文件的权限为0700\n                              不设置的话，默认为0700。 非必须设置\n;chown=nobody:nogroup       ; 这个一样，修改上面的那个socket文件的属组为user.group\n                              不设置的话，默认为启动supervisord进程的用户及属组。非必须设置\n;username=user              ; 使用supervisorctl连接的时候，认证的用户\n                               不设置的话，默认为不需要用户。 非必须设置\n;password=123               ; 和上面的用户名对应的密码，可以直接使用明码，也可以使用SHA加密\n                              如：{SHA}82ab876d1387bfafe46cc1c8a2ef074eae50cb1d\n                              默认不设置。。。非必须设置\n\n;[inet_http_server]         ; 侦听在TCP上的socket，Web Server和远程的supervisorctl都要用到他\n                              不设置的话，默认为不开启。非必须设置\n;port=127.0.0.1:9001        ; 这个是侦听的IP和端口，侦听所有IP用 :9001或*:9001。\n                              这个必须设置，只要上面的[inet_http_server]开启了，就必须设置它\n;username=user              ; 这个和上面的uinx_http_server一个样。非必须设置\n;password=123               ; 这个也一个样。非必须设置\n\n[supervisord]                ;这个主要是定义supervisord这个服务端进程的一些参数的\n                              这个必须设置，不设置，supervisor就不用干活了\nlogfile=/tmp/supervisord.log ; 这个是supervisord这个主进程的日志路径，注意和子进程的日志不搭嘎。\n                               默认路径$CWD/supervisord.log，$CWD是当前目录。。非必须设置\nlogfile_maxbytes=50MB        ; 这个是上面那个日志文件的最大的大小，当超过50M的时候，会生成一个新的日\n                               志文件。当设置为0时，表示不限制文件大小\n                               默认值是50M，非必须设置。\nlogfile_backups=10           ; 日志文件保持的数量，supervisor在启动程序时，会自动创建10个buckup文件，用于log rotate\n                               当设置为0时，表示不限制文件的数量。\n                               默认情况下为10。。。非必须设置\nloglevel=info                ; 日志级别，有critical, error, warn, info, debug, trace, or blather等\n                               默认为info。。。非必须设置项\npidfile=/tmp/supervisord.pid ; supervisord的pid文件路径。\n                               默认为$CWD/supervisord.pid。。。非必须设置\nnodaemon=false               ; 如果是true，supervisord进程将在前台运行\n                               默认为false，也就是后台以守护进程运行。。。非必须设置\nminfds=1024                  ; 这个是最少系统空闲的文件描述符，低于这个值supervisor将不会启动。\n                               系统的文件描述符在这里设置cat /proc/sys/fs/file-max\n                               默认情况下为1024。。。非必须设置\nminprocs=200                 ; 最小可用的进程描述符，低于这个值supervisor也将不会正常启动。\n                              ulimit  -u这个命令，可以查看linux下面用户的最大进程数\n                              默认为200。。。非必须设置\n;umask=022                   ; 进程创建文件的掩码\n                               默认为022。。非必须设置项\n;user=chrism                 ; 这个参数可以设置一个非root用户，当我们以root用户启动supervisord之后。\n                               我这里面设置的这个用户，也可以对supervisord进行管理\n                               默认情况是不设置。。。非必须设置项\n;identifier=supervisor       ; 这个参数是supervisord的标识符，主要是给XML_RPC用的。当你有多个\n                               supervisor的时候，而且想调用XML_RPC统一管理，就需要为每个\n                               supervisor设置不同的标识符了\n                               默认是supervisord。。。非必需设置\n;directory=/tmp              ; 这个参数是当supervisord作为守护进程运行的时候，设置这个参数的话，启动\n                               supervisord进程之前，会先切换到这个目录\n                               默认不设置。。。非必须设置\n;nocleanup=true              ; 这个参数当为false的时候，会在supervisord进程启动的时候，把以前子进程\n                               产生的日志文件(路径为AUTO的情况下)清除掉。有时候咱们想要看历史日志，当\n                               然不想日志被清除了。所以可以设置为true\n                               默认是false，有调试需求的同学可以设置为true。。。非必须设置\n;childlogdir=/tmp            ; 当子进程日志路径为AUTO的时候，子进程日志文件的存放路径。\n                               默认路径是这个东西，执行下面的这个命令看看就OK了，处理的东西就默认路径\n                               python -c \"import tempfile;print tempfile.gettempdir()\"\n                               非必须设置\n;environment=KEY=\"value\"     ; 这个是用来设置环境变量的，supervisord在linux中启动默认继承了linux的\n                               环境变量，在这里可以设置supervisord进程特有的其他环境变量。\n                               supervisord启动子进程时，子进程会拷贝父进程的内存空间内容。 所以设置的\n                               这些环境变量也会被子进程继承。\n                               小例子：environment=name=\"haha\",age=\"hehe\"\n                               默认为不设置。。。非必须设置\n;strip_ansi=false            ; 这个选项如果设置为true，会清除子进程日志中的所有ANSI 序列。什么是ANSI\n                               序列呢？就是我们的\\n,\\t这些东西。\n                               默认为false。。。非必须设置\n\n; the below section must remain in the config file for RPC\n; (supervisorctl/web interface) to work, additional interfaces may be\n; added by defining them in separate rpcinterface: sections\n[rpcinterface:supervisor]    ;这个选项是给XML_RPC用的，当然你如果想使用supervisord或者web server 这\n                              个选项必须要开启的\nsupervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface\n\n[supervisorctl]              ;这个主要是针对supervisorctl的一些配置\nserverurl=unix:///tmp/supervisor.sock ; 这个是supervisorctl本地连接supervisord的时候，本地UNIX socket\n                                        路径，注意这个是和前面的[unix_http_server]对应的\n                                        默认值就是unix:///tmp/supervisor.sock。。非必须设置\n;serverurl=http://127.0.0.1:9001 ; 这个是supervisorctl远程连接supervisord的时候，用到的TCP socket路径\n                                   注意这个和前面的[inet_http_server]对应\n                                   默认就是http://127.0.0.1:9001。。。非必须项\n\n;username=chris              ; 用户名\n                               默认空。。非必须设置\n;password=123                ; 密码\n                              默认空。。非必须设置\n;prompt=mysupervisor         ; 输入用户名密码时候的提示符\n                               默认supervisor。。非必须设置\n;history_file=~/.sc_history  ; 这个参数和shell中的history类似，我们可以用上下键来查找前面执行过的命令\n                               默认是no file的。。所以我们想要有这种功能，必须指定一个文件。。。非\n                               必须设置\n\n; The below sample program section shows all possible program subsection values,\n; create one or more 'real' program: sections to be able to control them under\n; supervisor.\n\n;[program:theprogramname]      ;这个就是咱们要管理的子进程了，\":\"后面的是名字，最好别乱写和实际进程\n                                有点关联最好。这样的program我们可以设置一个或多个，一个program就是\n                                要被管理的一个进程\n;command=/bin/cat              ; 这个就是我们的要启动进程的命令路径了，可以带参数\n                                例子：/home/test.py -a 'hehe'\n                                有一点需要注意的是，我们的command只能是那种在终端运行的进程，不能是\n                                守护进程。这个想想也知道了，比如说command=service httpd start。\n                                httpd这个进程被linux的service管理了，我们的supervisor再去启动这个命令\n                                这已经不是严格意义的子进程了。\n                                这个是个必须设置的项\n;process_name=%(program_name)s ; 这个是进程名，如果我们下面的numprocs参数为1的话，就不用管这个参数\n                                 了，它默认值%(program_name)s也就是上面的那个program冒号后面的名字，\n                                 但是如果numprocs为多个的话，那就不能这么干了。想想也知道，不可能每个\n                                 进程都用同一个进程名吧。\n\n\n;numprocs=1                    ; 启动进程的数目。当不为1时，就是进程池的概念，注意process_name的设置\n                                 默认为1    。。非必须设置\n;directory=/tmp                ; 进程运行前，会前切换到这个目录\n                                 默认不设置。。。非必须设置\n;umask=022                     ; 进程掩码，默认none，非必须\n;priority=999                  ; 子进程启动关闭优先级，优先级低的，最先启动，关闭的时候最后关闭\n                                 默认值为999 。。非必须设置\n;autostart=true                ; 如果是true的话，子进程将在supervisord启动后被自动启动\n                                 默认就是true   。。非必须设置\n;autorestart=unexpected        ; 这个是设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected\n                                 和true。如果为false的时候，无论什么情况下，都不会被重新启动，\n                                 如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的退\n                                 出码的时候，才会被自动重启。当为true的时候，只要子进程挂掉，将会被无\n                                 条件的重启\n;startsecs=1                   ; 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启\n                                 动成功了\n                                 默认值为1 。。非必须设置\n;startretries=3                ; 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把\n                                 此进程的状态置为FAIL\n                                 默认值为3 。。非必须设置\n;exitcodes=0,2                 ; 注意和上面的的autorestart=unexpected对应。。exitcodes里面的定义的\n                                 退出码是expected的。\n;stopsignal=QUIT               ; 进程停止信号，可以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2等信号\n                                  默认为TERM 。。当用设定的信号去干掉进程，退出码会被认为是expected\n                                  非必须设置\n;stopwaitsecs=10               ; 这个是当我们向子进程发送stopsignal信号后，到系统返回信息\n                                 给supervisord，所等待的最大时间。 超过这个时间，supervisord会向该\n                                 子进程发送一个强制kill的信号。\n                                 默认为10秒。。非必须设置\n;stopasgroup=false             ; 这个东西主要用于，supervisord管理的子进程，这个子进程本身还有\n                                 子进程。那么我们如果仅仅干掉supervisord的子进程的话，子进程的子进程\n                                 有可能会变成孤儿进程。所以咱们可以设置可个选项，把整个该子进程的\n                                 整个进程组都干掉。 设置为true的话，一般killasgroup也会被设置为true。\n                                 需要注意的是，该选项发送的是stop信号\n                                 默认为false。。非必须设置。。\n;killasgroup=false             ; 这个和上面的stopasgroup类似，不过发送的是kill信号\n;user=chrism                   ; 如果supervisord是root启动，我们在这里设置这个非root用户，可以用来\n                                 管理该program\n                                 默认不设置。。。非必须设置项\n;redirect_stderr=true          ; 如果为true，则stderr的日志会被写入stdout日志文件中\n                                 默认为false，非必须设置\n;stdout_logfile=/a/path        ; 子进程的stdout的日志路径，可以指定路径，AUTO，none等三个选项。\n                                 设置为none的话，将没有日志产生。设置为AUTO的话，将随机找一个地方\n                                 生成日志文件，而且当supervisord重新启动的时候，以前的日志文件会被\n                                 清空。当 redirect_stderr=true的时候，sterr也会写进这个日志文件\n;stdout_logfile_maxbytes=1MB   ; 日志文件最大大小，和[supervisord]中定义的一样。默认为50\n;stdout_logfile_backups=10     ; 和[supervisord]定义的一样。默认10\n;stdout_capture_maxbytes=1MB   ; 这个东西是设定capture管道的大小，当值不为0的时候，子进程可以从stdout\n                                 发送信息，而supervisor可以根据信息，发送相应的event。\n                                 默认为0，为0的时候表达关闭管道。。。非必须项\n;stdout_events_enabled=false   ; 当设置为ture的时候，当子进程由stdout向文件描述符中写日志的时候，将\n                                 触发supervisord发送PROCESS_LOG_STDOUT类型的event\n                                 默认为false。。。非必须设置\n;stderr_logfile=/a/path        ; 这个东西是设置stderr写的日志路径，当redirect_stderr=true。这个就不用\n                                 设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中\n                                 默认为AUTO，也就是随便找个地存，supervisord重启被清空。。非必须设置\n;stderr_logfile_maxbytes=1MB   ; 这个出现好几次了，就不重复了\n;stderr_logfile_backups=10     ; 这个也是\n;stderr_capture_maxbytes=1MB   ; 这个一样，和stdout_capture一样。 默认为0，关闭状态\n;stderr_events_enabled=false   ; 这个也是一样，默认为false\n;environment=A=\"1\",B=\"2\"       ; 这个是该子进程的环境变量，和别的子进程是不共享的\n;serverurl=AUTO                ;\n\n; The below sample eventlistener section shows all possible\n; eventlistener subsection values, create one or more 'real'\n; eventlistener: sections to be able to handle event notifications\n; sent by supervisor.\n\n;[eventlistener:theeventlistenername] ;这个东西其实和program的地位是一样的，也是suopervisor启动的子进\n                                       程，不过它干的活是订阅supervisord发送的event。他的名字就叫\n                                       listener了。我们可以在listener里面做一系列处理，比如报警等等\n                                       楼主这两天干的活，就是弄的这玩意\n;command=/bin/eventlistener    ; 这个和上面的program一样，表示listener的可执行文件的路径\n;process_name=%(program_name)s ; 这个也一样，进程名，当下面的numprocs为多个的时候，才需要。否则默认就\n                                 OK了\n;numprocs=1                    ; 相同的listener启动的个数\n;events=EVENT                  ; event事件的类型，也就是说，只有写在这个地方的事件类型。才会被发送\n\n\n;buffer_size=10                ; 这个是event队列缓存大小，单位不太清楚，楼主猜测应该是个吧。当buffer\n                                 超过10的时候，最旧的event将会被清除，并把新的event放进去。\n                                 默认值为10。。非必须选项\n;directory=/tmp                ; 进程执行前，会切换到这个目录下执行\n                                 默认为不切换。。。非必须\n;umask=022                     ; 淹没，默认为none，不说了\n;priority=-1                   ; 启动优先级，默认-1，也不扯了\n;autostart=true                ; 是否随supervisord启动一起启动，默认true\n;autorestart=unexpected        ; 是否自动重启，和program一个样，分true,false,unexpected等，注意\n                                  unexpected和exitcodes的关系\n;startsecs=1                   ; 也是一样，进程启动后跑了几秒钟，才被认定为成功启动，默认1\n;startretries=3                ; 失败最大尝试次数，默认3\n;exitcodes=0,2                 ; 期望或者说预料中的进程退出码，\n;stopsignal=QUIT               ; 干掉进程的信号，默认为TERM，比如设置为QUIT，那么如果QUIT来干这个进程\n                                 那么会被认为是正常维护，退出码也被认为是expected中的\n;stopwaitsecs=10               ; max num secs to wait b4 SIGKILL (default 10)\n;stopasgroup=false             ; send stop signal to the UNIX process group (default false)\n;killasgroup=false             ; SIGKILL the UNIX process group (def false)\n;user=chrism                   ;设置普通用户，可以用来管理该listener进程。\n                                默认为空。。非必须设置\n;redirect_stderr=true          ; 为true的话，stderr的log会并入stdout的log里面\n                                默认为false。。。非必须设置\n;stdout_logfile=/a/path        ; 这个不说了，好几遍了\n;stdout_logfile_maxbytes=1MB   ; 这个也是\n;stdout_logfile_backups=10     ; 这个也是\n;stdout_events_enabled=false   ; 这个其实是错的，listener是不能发送event\n;stderr_logfile=/a/path        ; 这个也是\n;stderr_logfile_maxbytes=1MB   ; 这个也是\n;stderr_logfile_backups        ; 这个不说了\n;stderr_events_enabled=false   ; 这个也是错的，listener不能发送event\n;environment=A=\"1\",B=\"2\"       ; 这个是该子进程的环境变量\n                                 默认为空。。。非必须设置\n;serverurl=AUTO                ; override serverurl computation (childutils)\n\n; The below sample group section shows all possible group values,\n; create one or more 'real' group: sections to create \"heterogeneous\"\n; process groups.\n\n;[group:thegroupname]  ;这个东西就是给programs分组，划分到组里面的program。我们就不用一个一个去操作了\n                         我们可以对组名进行统一的操作。 注意：program被划分到组里面之后，就相当于原来\n                         的配置从supervisor的配置文件里消失了。。。supervisor只会对组进行管理，而不再\n                         会对组里面的单个program进行管理了\n;programs=progname1,progname2  ; 组成员，用逗号分开\n                                 这个是个必须的设置项\n;priority=999                  ; 优先级，相对于组和组之间说的\n                                 默认999。。非必须选项\n\n; The [include] section can just contain the \"files\" setting.  This\n; setting can list multiple files (separated by whitespace or\n; newlines).  It can also contain wildcards.  The filenames are\n; interpreted as relative to this file.  Included files *cannot*\n; include files themselves.\n\n;[include]                         ;这个东西挺有用的，当我们要管理的进程很多的时候，写在一个文件里面\n                                    就有点大了。我们可以把配置信息写到多个文件中，然后include过来\n;files = relative/directory/*.ini\n\n\nOK,上面提到的非必须设置项，一般来说，都是有默认值的，可以根据自己的需要去设置。。。如果不设置的，supervisor也能用起来\n\n这一篇先总结到这里了，下一篇搞搞event和xml_rpc\n\n```\n[原文链接](https://www.toutiao.com/a6714650171180843524/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1563958876&app=news_article&utm_source=weixin&utm_medium=toutiao_android&req_id=201907241701150100230730859727DA2&group_id=6714650171180843524)\n","tags":["supervisor"],"categories":["Linux web"]},{"title":"apache 代理转发","url":"/2021/05/07/Linux web/apache 代理转发/","content":"## 一、转发时需开启如下：\n```\nsudo a2enmod proxy\nsudo a2enmod proxy_http\nsudo a2enmod proxy_ajp\nsudo a2enmod proxy_balancer\nsudo a2enmod proxy_connect\nsudo a2enmod proxy_html\n```\n[参考链接](https://superuser.com/questions/1287647/apache2-not-starting-error-invalid-command-proxyrequests)\n\n<!--more-->\n\n## 二、相关代码：\n#### 80端口转发其他多个项目端口\n```\n<VirtualHost *:80>\n        ServerAdmin webmaster@localhost\n        DocumentRoot /var/www/html/xunke\n        ErrorLog /etc/apache2/error.log\n        CustomLog /etc/apache2/access.log combined\n        #ProxyPassMatch  /xunke/  http://localhost:8003/   # 匹配带有xunke的url 不适用\n        ProxyPass  /xunke  http://localhost:8003/\n        ProxyPassReverse /xunke  http://localhost:8003/\n</VirtualHost>\n<VirtualHost *:80>\n        ServerAdmin webmaster@localhost\n        DocumentRoot /var/www/html/topmps\n        ErrorLog /etc/apache2/error.log\n        CustomLog /etc/apache2/access.log combined\n        #ProxyPassMatch  /topmps/  http://localhost:8002/\n        ProxyPass  /topmps/  http://localhost:8002/\n        ProxyPassReverse  /topmps/  http://localhost:8002/\n</VirtualHost>\n```\n[参考链接1](https://blog.csdn.net/xiaokui_wingfly/article/details/51481653)\n[参考链接2](https://blog.csdn.net/u011277123/article/details/77165137)\n\n#### apache 监听多个端口\n- 目录：/etc/apache2/ports.conf\n```\nListen 80\nListen 8003\nListen 8004\n\n<IfModule ssl_module>\n        Listen 443\n</IfModule>\n\n<IfModule mod_gnutls.c>\n        Listen 443\n</IfModule>\n```\n\n- 目录：/etc/apache2/sites-available/000-default.conf\n```\n<VirtualHost *:8003>\n        ServerAdmin webmaster@localhost\n        DocumentRoot /var/www/html/xunke\n        ErrorLog /etc/apache2/error.log\n        CustomLog /etc/apache2/access.log combined\n</VirtualHost>\n\n<VirtualHost *:8004>\n        ServerAdmin webmaster@localhost\n        DocumentRoot /var/www/html/qibo\n        ErrorLog /etc/apache2/error.log\n        CustomLog /etc/apache2/access.log combined\n</VirtualHost>\n```\n\n","tags":["apache"],"categories":["Linux web"]},{"title":"nginx 只配置了一个域名，结果另一个域名也能访问","url":"/2021/05/07/Linux web/nginx 只配置了一个域名，结果另一个域名也能访问/","content":"今天自己在部署业务的时候， 一个同事说他用另一个域名访问到了我这个域名下的网页, 看来我自己的Nginx的配置，感觉没什么问题！\n```\nserver {\n           listen 80;\n           server_name www.hehe.com;\n           root /data1/htdocs/kaixuan.hehe.com/;\n           location ~ \\.php$ {\n                fastcgi_pass   127.0.0.1:9000;\n                fastcgi_index  index.php;\n                fastcgi_param  SCRIPT_FILENAME  $document_root/$fastcgi_script_name;\n                include        fastcgi_params;\n           }\n           location / {\n                 index index.html;\n           }\n}\n```\n\n后来网上查了一下，发现如果当所有server的规则都不匹配时，nginx会采用第一条server配置，所以一般第一条server会使用阻止页面。这样的话，就需要在server上边再加一条server，加一条默认的阻挡。\n```\nserver {\n    listen  80 default;\n    listen  [::]:80 default;\n    server_name  _;\n\n    return 403;\n}\n\nserver {\n           listen 80;\n           server_name www.hehe.com;\n           root /data1/htdocs/kaixuan.hehe.com/;\n           location ~ \\.php$ {\n                fastcgi_pass   127.0.0.1:9000;\n                fastcgi_index  index.php;\n                fastcgi_param  SCRIPT_FILENAME  $document_root/$fastcgi_script_name;\n                include        fastcgi_params;\n           }\n           location / {\n                 index index.html;\n           }\n}\n```\n","tags":["nginx"],"categories":["Linux web"]},{"title":"netstat 参数 及常用命令","url":"/2021/05/07/Linux/netstat 参数 及常用命令/","content":"### netstat 中参数选项\n```\n-a或--all：显示所有连线中的Socket；\n-A<网络类型>或--<网络类型>：列出该网络类型连线中的相关地址；\n-c或--continuous：持续列出网络状态；\n-C或--cache：显示路由器配置的快取信息；\n-e或--extend：显示网络其他相关信息；\n-F或--fib：显示FIB；\n-g或--groups：显示多重广播功能群组组员名单；\n-h或--help：在线帮助；\n-i或--interfaces：显示网络界面信息表单；\n-l或--listening：显示监控中的服务器的Socket；\n-M或--masquerade：显示伪装的网络连线；\n-n或--numeric：直接使用ip地址，而不通过域名服务器；\n-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称；\n-o或--timers：显示计时器；\n-p或--programs：显示正在使用Socket的程序识别码和程序名称；\n-r或--route：显示Routing Table；\n-s或--statistice：显示网络工作信息统计表；\n-t或--tcp：显示TCP传输协议的连线状况；\n-u或--udp：显示UDP传输协议的连线状况；\n-v或--verbose：显示指令执行过程；\n-V或--version：显示版本信息；\n-w或--raw：显示RAW传输协议的连线状况；\n-x或--unix：此参数的效果和指定\"-A unix\"参数相同；\n--ip或--inet：此参数的效果和指定\"-A inet\"参数相同。\n```\n<!--more-->\n\n## 常用命令\n###查看linux的连接数，输出每个ip的连接数，以及总的各个状态的连接数\n```\nnetstat -n | awk '/^tcp/ {n=split($(NF-1),array,\":\");if(n<=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\"%-20s %s\\n\", a, S[a]);++I}printf(\"%-20s %s\\n\",\"TOTAL_IP\",I);for(a in s) printf(\"%-20s %s\\n\",a, s[a]);printf(\"%-20s %s\\n\",\"TOTAL_LINK\",N);}'\n```\n###查看日志中不同端口对应的连接数\n```\ncat /home/ubuntu/log/gears-proxy-error.log |  egrep ':922[6-9]' | awk -F \"upstream\\\": \" '{print $2}' | awk -F, '{print $1}' |sort | uniq -c | sort -rn\n```\n###查看某些端口 有哪些ip链接  并且连接数有多少\n```\nnetstat -ntu |  egrep ':922[6-9]' | awk '{print $5}' | cut -d: -f1 | awk '{++ip[$1]} END {for(i in ip) print ip[i],\"\\t\",i}' | sort -nr\n```\n###如果发现某个端口被占用后，可以用命令查看，该端口到底是被哪个进程所占用。命令如下：\n```\nnetstat -pan | grep 5623\n```\n###查看进程程序名称\n```\nps -aux | grep pid\n```\n###查看tcp连接数量\n```\nnetstat -anptl | wc -l\n```\n###查看每个ip跟服务器建立的连接数\n```\nnetstat -nat|awk '{print$5}'|awk -F : '{print$1}'|sort|uniq -c|sort -rn\n```\n[netstat监控大量ESTABLISHED连接数和TIME_WAIT连接数题解决](https://blog.csdn.net/bluetjs/article/details/80965967\n)\n###查看每个ip跟服务器建立的连接数\n--（PS：正则解析：显示第5列，-F : 以：分割，显示列，sort 排序，uniq -c统计排序过程中的重复行，sort -rn 按纯数字进行逆序排序）\n```\nnetstat -nat|awk '{print$5}'|awk -F : '{print$1}'|sort|uniq -c|sort -rn\n```\n###查看每个ip建立的ESTABLISHED/TIME_OUT状态的连接数\n```\nnetstat -nat|grep ESTABLISHED|awk '{print$5}'|awk -F : '{print$1}'|sort|uniq -c|sort -rn\n```\n###查看不同状态的连接数数量\n```\nnetstat -an | awk '/^tcp/ {++y[$NF]} END {for(w in y) print w, y[w]}'\n```\n","tags":["netstat"],"categories":["Linux"]},{"title":"ubuntu 16.04 忘记root密码","url":"/2021/05/07/Linux/ubuntu 16.04 忘记root密码/","content":"\n**阅读目录**\n\n虚拟机中安装的ubuntu 16.04。\n\n## 方法一 \n\n如果用户具有sudo权限，那么直接可以运行如下命令： \n\n```\nsudo su root\n#输入当前用户的密码\npasswd\n#输入密码\n#再次输入密码\n```\n\n![image](https://user-images.githubusercontent.com/28568478/117405988-0a90e300-af3f-11eb-90d1-041c5b6914de.png)\n\n<!--more-->\n\n##  方法二\n\n如果用户不具备sudo权限，则方法一不能用，并需进入GRUB修改kernel镜像启动参数。 \n\n1、重启，按住shift键，出现如下界面，选中如下选项\n\n![image](https://user-images.githubusercontent.com/28568478/117406054-1aa8c280-af3f-11eb-9231-aac4431727a4.png)\n\n2、按回车键进入如下界面，然后选中有recovery mode的选项\n\n![image](https://user-images.githubusercontent.com/28568478/117406070-1f6d7680-af3f-11eb-88f2-f5bbaab55246.png)\n\n\n3、按e进入如下界面，找到图中红色框的recovery nomodeset并将其删掉，再在这一行的后面输入\n\n```\nquiet splash rw init=/bin/bash\n```\n![image](https://user-images.githubusercontent.com/28568478/117406078-23999400-af3f-11eb-9bb5-b42fb14bcefb.png)\n![image](https://user-images.githubusercontent.com/28568478/117406095-27c5b180-af3f-11eb-8b34-75af15a47672.png)\n\n\n4、接着按F10或者Ctrl+x 后出现如下界面，在命令行内输入passwd后进行修改密码即可\n\n![image](https://user-images.githubusercontent.com/28568478/117406109-2b593880-af3f-11eb-8ae9-fe7af949ff5d.png)\n\n\n修改完之后重启系统。\n\n---\n\n#修改某个用户目录下的sudo密码：\n\n1、进入root目录下\n2：输入命令 passwd david，(david是系统中已有的username)\n![image](https://user-images.githubusercontent.com/28568478/117406121-301dec80-af3f-11eb-98e6-bd744bc54431.png)\n\n3、重新定义密码即可\n\n#### [原文链接:  ubuntu 16.04 忘记root密码](https://www.cnblogs.com/xiaojianliu/p/8520313.html)\n","tags":["root","密码"],"categories":["Linux"]},{"title":"Linux增加开机启动项","url":"/2021/05/07/Linux web/Linux增加开机启动项/","content":"* vi /etc/rc.local\n* 按i键进入编辑模式，然后在最后一行加入需要开机启动的命令  例如:\n* ssserver -c /etc/shadowsocks/config.json -d start  --log-file /etc/shadowsocks/ss.log --pid-file /etc/shadowsocks/ss.pid\n","tags":["开机"],"categories":["Linux web"]},{"title":"linux下free命令详解","url":"/2021/05/07/Linux/linux下free命令详解/","content":"\nfree 命令显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。\n\n![image](https://user-images.githubusercontent.com/28568478/117406270-6e1b1080-af3f-11eb-82b0-07b44528dcc8.png)\n\n\n如果加上 -h 选项，输出的结果会友好很多：\n\n![image](https://user-images.githubusercontent.com/28568478/117406278-71ae9780-af3f-11eb-8dc8-937a2f08fb00.png)\n\n\n<!--more-->\n\n有时我们需要持续的观察内存的状况，此时可以使用 -s 选项并指定间隔的秒数， -c选项指定展示次数：\n\n```\n$ free -h -c 100 -s 3\n```\n![image](https://user-images.githubusercontent.com/28568478/117406294-75421e80-af3f-11eb-9093-97ddd1dc614f.png)\n\n\n上面的命令每隔 3 秒输出一次内存的使用情况，直到你按下 ctrl + c。\n\n由于 free 命令本身比较简单，所以本文的重点会放在如何通过 free 命令了解系统当前的内存使用状况。\n\n# 输出简介\n\n下面先解释一下输出的内容：\n**Mem** 行(第二行)是内存的使用情况。\n**Swap** 行(第三行)是交换空间的使用情况。\n**total** 列显示系统总的可用物理内存和交换空间大小。\n**used** 列显示已经被使用的物理内存和交换空间。\n**free** 列显示还有多少物理内存和交换空间可用使用。\n**shared** 列显示被共享使用的物理内存大小。\n**buff/cache** 列显示被 buffer 和 cache 使用的物理内存大小。\n**available** 列显示还可以被应用程序使用的物理内存大小。\n\n我想只有在理解了一些基本概念之后，上面的输出才能帮助我们了解系统的内存状况。\n\n# buff/cache\n\n先来提一个问题： buffer 和 cache 应该是两种类型的内存，但是 free 命令为什么会把它们放在一起呢？要回答这个问题需要我们做些准备工作。让我们先来搞清楚 buffer 与 cache 的含义。\n\n**buffer** 在操作系统中指 buffer cache， 中文一般翻译为 \"缓冲区\"。要理解缓冲区，必须明确另外两个概念：\"扇区\" 和 \"块\"。扇区是设备的最小寻址单元，也叫 \"硬扇区\" 或 \"设备块\"。块是操作系统中文件系统的最小寻址单元，也叫 \"文件块\" 或 \"I/O 块\"。每个块包含一个或多个扇区，但大小不能超过一个页面，所以一个页可以容纳一个或多个内存中的块。当一个块被调入内存时，它要存储在一个缓冲区中。每个缓冲区与一个块对应，它相当于是磁盘块在内存中的表示(下图来自互联网)：\n\n![image](https://user-images.githubusercontent.com/28568478/117406319-7a9f6900-af3f-11eb-846f-4047421d5435.png)\n\n\n注意，buffer cache 只有块的概念而没有文件的概念，它只是把磁盘上的块直接搬到内存中而不关心块中究竟存放的是什么格式的文件。\n\n**cache** 在操作系统中指 page cache，中文一般翻译为 \"页高速缓存\"。页高速缓存是内核实现的磁盘缓存。它主要用来减少对磁盘的 I/O 操作。具体地讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。页高速缓存缓存的是内存页面。**缓存中的页来自对普通文件、块设备文件(这个指的就是 buffer cache 呀)和内存映射文件的读写**。\n页高速缓存对普通文件的缓存我们可以这样理解：当内核要读一个文件(比如 /etc/hosts)时，它会先检查这个文件的数据是不是已经在页高速缓存中了。如果在，就放弃访问磁盘，直接从内存中读取。这个行为称为缓存命中。如果数据不在缓存中，就是未命中缓存，此时内核就要调度块 I/O 操作从磁盘去读取数据。然后内核将读来的数据放入页高速缓存中。这种缓存的目标是文件系统可以识别的文件(比如 /etc/hosts)。\n页高速缓存对块设备文件的缓存就是我们在前面介绍的 buffer cahce。因为独立的磁盘块通过缓冲区也被存入了页高速缓存(缓冲区最终是由页高速缓存来承载的)。\n\n到这里我们应该搞清楚了：无论是缓冲区还是页高速缓存，它们的实现方式都是一样的。缓冲区只不过是一种概念上比较特殊的页高速缓存罢了。\n那么为什么 free 命令不直接称为 cache 而非要写成 buff/cache？ 这是因为缓冲区和页高速缓存的实现并非天生就是统一的。在 linux 内核 2.4 中才将它们统一。更早的内核中有两个独立的磁盘缓存：页高速缓存和缓冲区高速缓存。前者缓存页面，后者缓存缓冲区。当你知道了这些故事之后，输出中列的名称可能已经不再重要了。\n\n# free 与 available\n\n在 free 命令的输出中，有一个 free 列，同时还有一个 available 列。这二者到底有何区别？\nfree 是真正尚未被使用的物理内存数量。至于 available 就比较有意思了，它是从应用程序的角度看到的可用内存数量。Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache。所以对于内核来说，buffer 和 cache 都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，**available  = free + buffer + cache**。请注意，这只是一个很理想的计算方式，实际中的数据往往有较大的误差。\n\n# 交换空间(swap space)\n\nswap space 是磁盘上的一块区域，可以是一个分区，也可以是一个文件。所以具体的实现可以是 swap 分区也可以是 swap 文件。当系统物理内存吃紧时，Linux 会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中，这就是常说的换出和换入。交换空间可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。\n\n现在的机器一般都不太缺内存，如果系统默认还是使用了 swap 是不是会拖累系统的性能？理论上是的，但实际上可能性并不是很大。并且内核提供了一个叫做 swappiness 的参数，用于配置需要将内存中不常用的数据移到 swap 中去的紧迫程度。这个参数的取值范围是 0～100，0 告诉内核尽可能的不要将内存数据移到 swap 中，也即只有在迫不得已的情况下才这么做，而 100 告诉内核只要有可能，尽量的将内存中不常访问的数据移到 swap 中。在 ubuntu 系统中，swappiness 的默认值是 60。如果我们觉着内存充足，可以在 /etc/sysctl.conf 文件中设置 swappiness：\n\n```\nvm.swappiness=10\n```\n如果系统的内存不足，则需要根据物理内存的大小来设置交换空间的大小。具体的策略网上有很丰富的资料，这里笔者不再赘述。\n\n# /proc/meminfo 文件\n\n其实 free 命令中的信息都来自于 /proc/meminfo 文件。/proc/meminfo 文件包含了更多更原始的信息，只是看起来不太直观：\n```\n$ cat /proc/meminfo\n```\n![image](https://user-images.githubusercontent.com/28568478/117406335-7ffcb380-af3f-11eb-84d7-8e6fadde9dcb.png)\n\n\n有兴趣的同学可以直接查看这个文件。\n\n# 总结\n\nfree 命令是一个既简单又复杂的命令。简单是因为这个命令的参数少，输出结果清晰。说它复杂则是因为它背后是比较晦涩的操作系统中的概念，如果不清楚这些概念，即便看了 free 命令的输出也 get 不到多少有价值的信息。\n\n#### [原文：linux下free命令详解](https://www.cnblogs.com/ultranms/p/9254160.html)\n","tags":["free"],"categories":["Linux"]},{"title":"批量关闭linux进程","url":"/2021/05/07/Linux web/批量关闭linux进程/","content":"# 批量关闭linux进程\n\n你是否经常遇到需要批量杀死很多进程的情况？而你是否还在一个一个的`kill`。\n\n接下来我教你一个小秘诀吧。\n\n1、首先我们查看当前的进程列表。\n\n我们以查看`nginx`进程为例，通过`ps -ef`显示当前机器运行的所有进程，再通过`grep nginx`过滤出包含`nginx`字符串的进程。完成命令为`ps -ef|grep nginx`。\n![image](https://user-images.githubusercontent.com/28568478/117406501-ba665080-af3f-11eb-8030-bf89ef6e6b26.png)\n\n<!--more-->\n2、获取进程ID\n采用`awk`工具提取进程ID。`awk`是一种很棒的语言，适合文本处理和报表生成。在这里我们通过`awk`处理第一步中得到的进程列表，提取进程ID。完成命令为`ps -ef|grep nginx|awk '{print $2}'`\n![image](https://user-images.githubusercontent.com/28568478/117406514-bf2b0480-af3f-11eb-86ae-0c8dfd059eaf.png)\n\n\n3、批量kill\n`xargs` 是一条 Unix 和类 Unix 操作系统的常用命令；它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。接下来将使用`xargs`把第二步中得到的进程ID列表传递给`kill`命令。完成命令为`ps -ef|grep nginx|awk '{print $2}'|xargs kill -9`。\n![image](https://user-images.githubusercontent.com/28568478/117406622-e4b80e00-af3f-11eb-980b-64844240af0b.png)\n\n\nOK。大功告成，现在可以批量\b`kill`进程了。\n","tags":["进程"],"categories":["Linux web"]},{"title":"nohup详解 Python不挂断运行后台程序","url":"/2021/05/07/Linux web/nohup 详解 Python不挂断运行后台程序/","content":"# nohup 详解\n\n## nohup\n\nnohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 & （ 表示“and”的符号）到命令的尾部。\n\nnohup 是 no hang up 的缩写，就是不挂断的意思。\n\nnohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。\n\n在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。\n\n<!--more-->\n\n## 案例\n\n1. nohup command > myout.file 2>&1 &   \n\n在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ；\n\n2>&1是将标准错误（2）重定向到标准输出（&1），标准输出（&1）再被重定向输入到myout.file文件中。\n\n2. 0 22 * * * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py > /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2>&1\n\n这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中\n\n\n## nohup和&的区别\n\n& ： 指在后台运行\n\nnohup ： 不挂断的运行，注意并没有后台运行的功能，，就是指，用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；&才是后台运行\n\n* * *\n\n&是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出\n\n那么，我们可以巧妙的吧他们结合起来用就是\nnohup COMMAND &\n这样就能使命令永久的在后台执行\n\n例如：\n\n1\\. sh test.sh &  \n将sh test.sh任务放到后台 ，即使关闭xshell退出当前session依然继续运行，但**标准输出和标准错误信息会丢失（缺少的日志的输出）**\n\n将sh test.sh任务放到后台 ，关闭xshell，对应的任务也跟着停止。\n2\\. nohup sh test.sh  \n将sh test.sh任务放到后台，关闭标准输入，**终端不再能够接收任何输入（标准输入）**，重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。\n3\\. nohup sh test.sh  & \n将sh test.sh任务放到后台，但是依然可以使用标准输入，**终端能够接收任何输入**，重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。\n\n\n## 参考链接\n\nhttps://blog.csdn.net/u011095110/article/details/78666833\n\nhttps://baike.baidu.com/item/nohup/5683841\n\n[原文链接](https://www.cnblogs.com/jinxiao-pu/p/9131057.html)\n","tags":["nohup"],"categories":["Linux web"]},{"title":"linux服务器搭建 shadowsocks","url":"/2021/05/07/proxy/linux服务器搭建 shadowsocks/","content":"\n```\nsudo apt-get update    # 更新软件源列表\nsudo apt-get -y install python-gevent python-pip  # 安装所需服务\nsudo apt-get -y install python-m2crypto\nsudo pip install shadowsocks   # 安装影梭\n```\n\nshadowsocks安装完毕后，可以查看使用ssserver命令进行查看。如下：\nssserver -h\n\n在 /etc/shadowsocks/ 下写入以 .json结尾的配置文件 如下:\n```\n{\n    \"server\":\"0.0.0.0\",\n    \"server_port\":443,  #普通用户目录下 采用大于1024的端口 root目录下可以使用443\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"你的密码\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\":false,\n    \"workers\": 1\n}\n```\n\n常用命令\n\n```\n# 启动\nssserver -c /etc/shadowsocks/ss.json -d start\n# 停止\nssserver -c /etc/shadowsocks/ss.json -d stop\n# 重启\nssserver -c /etc/shadowsocks/ss.json -d restart\n-d  后台启动  及日志记录\nssserver -c /etc/shadowsocks/config.json -d start  --log-file ./ss.log --pid-file ./ss.pid\n\nnetstat -tunlp 查看服务是否启动\n\nvi /etc/rc.local\n按i键进入编辑模式，然后在最后一行加入\nssserver -c /etc/shadowsocks/config.json -d start  --log-file /etc/shadowsocks/ss.log --pid-file /etc/shadowsocks/ss.pid\n```\n","tags":["代理"],"categories":["proxy"]},{"title":"Vue.js - Day5","url":"/2021/05/04/vue/vue2.0基础课程/day5/","content":"\n# Vue.js - Day5 - Webpack\n\n## 在网页中会引用哪些常见的静态资源？\n+ JS\n - .js  .jsx  .coffee  .ts（TypeScript  类 C# 语言）\n+ CSS\n - .css  .less   .sass  .scss\n+ Images\n - .jpg   .png   .gif   .bmp   .svg\n+ 字体文件（Fonts）\n - .svg   .ttf   .eot   .woff   .woff2\n+ 模板文件\n - .ejs   .jade  .vue【这是在webpack中定义组件的方式，推荐这么用】\n\n\n## 网页中引入的静态资源多了以后有什么问题？？？\n1. 网页加载速度慢， 因为 我们要发起很多的二次请求；\n2. 要处理错综复杂的依赖关系\n\n\n## 如何解决上述两个问题\n1. 合并、压缩、精灵图、图片的Base64编码\n2. 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系；\n\n## 什么是webpack?\nwebpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；\n\n\n## 如何完美实现上述的2种解决方案\n1. 使用Gulp， 是基于 task 任务的；\n2. 使用Webpack， 是基于整个项目进行构建的；\n+ 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。\n+ 根据官网的图片介绍webpack打包的过程\n+ [webpack官网](http://webpack.github.io/)\n+ [webpack中文文档](https://webpack.docschina.org/)\n\n## webpack安装的两种方式\n1. 运行`npm i webpack -g`全局安装webpack，这样就能在全局使用webpack的命令\n2. 在项目根目录中运行`npm i webpack --save-dev`安装到项目依赖中\n\n## 初步使用webpack打包构建列表隔行变色案例\n1. 运行`npm init`初始化项目，使用npm管理项目中的依赖包 (npm init -y 一键初始化) 自动生成package.json文件\n2. 创建项目基本的目录结构 src:存放源代码  dist: 项目发布后的文件存放目录\n3. 使用`cnpm i jquery --save`安装jquery类库 （npm i jquery -s） 安装包后自动生成node_modules文件夹，并把包安装到这个文件夹\n4. 创建`main.js`并书写各行变色的代码逻辑：\n```\n\t// 导入jquery类库\n    import $ from 'jquery'\n\n    // 设置偶数行背景色，索引从0开始，0是偶数\n    $('#list li:even').css('backgroundColor','lightblue');\n    // 设置奇数行背景色\n    $('#list li:odd').css('backgroundColor','pink');\n```\n5. 直接在页面上引用`main.js`会报错，因为浏览器不认识`import`这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；\n6. 运行`webpack 入口文件路径 输出文件路径`对`main.js`进行处理：\n```\nwebpack src/js/main.js dist/bundle.js\n```\n\n## 使用webpack的配置文件简化打包时候的命令\n1. 在项目根目录中创建`webpack.config.js`\n2. 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在`webpack.config.js`中配置这两个路径：\n```\n    // 导入处理路径的模块\n    var path = require('path');\n\n    // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理\n    module.exports = {\n        entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件\n        output: { // 配置输出选项\n            path: path.resolve(__dirname, 'dist'), // 配置输出的路径\n            filename: 'bundle.js' // 配置输出的文件名\n        }\n    }\n```\n\n## 实现webpack的实时打包构建\n1. 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用`webpack-dev-server`来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。\n2. 运行`cnpm i webpack-dev-server --save-dev`安装到开发依赖\n3. 安装完成之后，在命令行直接运行`webpack-dev-server`来进行打包，发现报错，此时需要借助于`package.json`文件中的指令，来进行运行`webpack-dev-server`命令，在`scripts`节点下新增`\"dev\": \"webpack-dev-server\"`指令，发现可以进行实时打包，但是dist目录下并没有生成`bundle.js`文件，这是因为`webpack-dev-server`将打包好的文件放在了内存中\n + 把`bundle.js`放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快\n + 这个时候访问webpack-dev-server启动的`http://localhost:8080/`网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:`<script src=\"../bundle.js\"></script>`\n + 为了能在访问`http://localhost:8080/`的时候直接访问到index首页，可以使用`--contentBase src`指令来修改dev指令，指定启动的根目录：\n ```\n \"dev\": \"webpack-dev-server --contentBase src\"\n ```\n 同时修改index页面中script的src属性为`<script src=\"bundle.js\"></script>`\n\n## 使用`html-webpack-plugin`插件配置启动页面\n由于使用`--contentBase`指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用`html-webpack-plugin`插件配置启动页面.\n1. 运行`cnpm i html-webpack-plugin --save-dev`安装到开发依赖\n2. 修改`webpack.config.js`配置文件如下：\n```\n    // 导入处理路径的模块\n    var path = require('path');\n    // 导入自动生成HTMl文件的插件\n    var htmlWebpackPlugin = require('html-webpack-plugin');\n\n    module.exports = {\n        entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件\n        output: { // 配置输出选项\n            path: path.resolve(__dirname, 'dist'), // 配置输出的路径\n            filename: 'bundle.js' // 配置输出的文件名\n        },\n        plugins:[ // 添加plugins节点配置插件\n            new htmlWebpackPlugin({\n                template:path.resolve(__dirname, 'src/index.html'),//模板路径\n                filename:'index.html'//自动生成的HTML文件的名称\n            })\n        ]\n    }\n```\n3. 修改`package.json`中`script`节点中的dev指令如下：\n```\n\"dev\": \"webpack-dev-server\"\n```\n4. 将index.html中script标签注释掉，因为`html-webpack-plugin`插件会自动把bundle.js注入到index.html页面中！\n\n## 实现自动打开浏览器、热更新和配置浏览器的默认端口号\n**注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！**\n### 方式1：\n+ 修改`package.json`的script节点如下，其中`--open`表示自动打开浏览器，`--port 4321`表示打开的端口号为4321，`--hot`表示启用浏览器热更新：\n```\n\"dev\": \"webpack-dev-server --hot --port 4321 --open\"\n```\n\n### 方式2：\n1. 修改`webpack.config.js`文件，新增`devServer`节点如下：\n```\ndevServer:{\n        hot:true,\n        open:true,\n        port:4321\n    }\n```\n2. 在头部引入`webpack`模块：\n```\nvar webpack = require('webpack');\n```\n3. 在`plugins`节点下新增：\n```\nnew webpack.HotModuleReplacementPlugin()\n```\n\n## 使用webpack打包css文件\n1. 运行`cnpm i style-loader css-loader --save-dev`\n2. 修改`webpack.config.js`这个配置文件：\n```\nmodule: { // 用来配置第三方loader模块的\n        rules: [ // 文件的匹配规则\n            { test: /\\.css$/, use: ['style-loader', 'css-loader'] }//处理css文件的规则\n        ]\n    }\n```\n3. 注意：`use`表示使用哪些模块来处理`test`所匹配到的文件；`use`中相关loader模块的调用顺序是从后向前调用的；\n\n## 使用webpack打包less文件\n1. 运行`cnpm i less-loader less -D`\n2. 修改`webpack.config.js`这个配置文件：\n```\n{ test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] },\n```\n\n## 使用webpack打包sass文件\n1. 运行`cnpm i sass-loader node-sass --save-dev`\n2. 在`webpack.config.js`中添加处理sass文件的loader模块：\n```\n{ test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] }\n```\n\n## 使用webpack处理css中的路径\n1. 运行`cnpm i url-loader file-loader --save-dev`\n2. 在`webpack.config.js`中添加处理url路径的loader模块：\n```\n{ test: /\\.(png|jpg|gif)$/, use: 'url-loader' }\n```\n3. 可以通过`limit`指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：\n```\n{ test: /\\.(png|jpg|gif)$/, use: 'url-loader?limit=43960' },\n```\n\n## 使用babel处理高级JS语法\n1. 运行`cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev`安装babel的相关loader包\n2. 运行`cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev`安装babel转换的语法\n3. 在`webpack.config.js`中添加相关loader模块，其中需要注意的是，一定要把`node_modules`文件夹添加到排除项：\n```\n{ test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ }\n```\n4. 在项目根目录中添加`.babelrc`文件，并修改这个配置文件如下：\n```\n{\n    \"presets\":[\"es2015\", \"stage-0\"],\n    \"plugins\":[\"transform-runtime\"]\n}\n```\n5. **注意：语法插件`babel-preset-es2015`可以更新为`babel-preset-env`，它包含了所有的ES相关的语法；**\n\n## 相关文章\n[babel-preset-env：你需要的唯一Babel插件](https://segmentfault.com/p/1210000008466178)\n[Runtime transform 运行时编译es6](https://segmentfault.com/a/1190000009065987)\n","tags":["vue2.0基础课程","Webpack"],"categories":["vue2.0基础课程"]},{"title":"安装Python","url":"/2021/05/04/python/安装Python/","content":"\n### [How to Install Python](https://linuxize.com/post/how-to-install-python-3-7-on-ubuntu-18-04/)\n```\napt-get install zlib1g-dev libbz2-dev libssl-dev libncurses5-dev  libsqlite3-dev libreadline-dev tk-dev libgdbm-dev libdb-dev libpcap-dev xz-utils libexpat1-dev   liblzma-dev libffi-dev  libc6-dev\n\n1. 下载源码包\n     wget   https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz\n2. mkdir -p /usr/local/python3\n3. mv Python-3.7.3.tgz /usr/local/python3\n4. tar -zxf Python-3.7.3.tgz\n5. cd python3.7.3\n6. ./configure --prefix=/usr/local/python3 --with-ssl  --enable-optimizations\n7. make\n8. make install\n```\n\n```\nln -s /usr/local/python3/bin/python3 /usr/bin/python3 [#确认是否是需要的版本]\nln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip3\n\n安装pip3 apt-get install python3-pip\n```\n\n### mac 安装python\n```\nbrew install python\nbrew install python@3.9 # 安装指定版本\n```\n","categories":["python"]},{"title":"python 列表加法\"+\"和\"extend\"的区别","url":"/2021/05/04/python/python 列表加法\"+\"和\"extend\"的区别/","content":"\n### 相同点:　　\n -  \"+\"和\"extend\"都能将两个列表成员拼接到到一起\n\n\n\n### 不同点:　　\n -  \\+ : 生成的是一个新列表(id改变)\n\n - extend : 是将一个列表的成员一个个取出添加到原列表中 , 改变的是原列表的值 , id不变\n\n<!--more-->\n\n![image](https://user-images.githubusercontent.com/28568478/117003180-21ed8780-ad17-11eb-97fc-fedcf041db5d.png)\n\n","tags":["list"],"categories":["python"]},{"title":"浅析深拷贝浅拷贝","url":"/2021/05/04/python/浅析深拷贝浅拷贝/","content":"\n本文主要介绍python中的深拷贝和浅拷贝究竟从底层ID来看是怎么回事\n\n<!--more-->\n![](https://user-images.githubusercontent.com/28568478/117002717-80663600-ad16-11eb-9151-ccd5e05a538b.png)\n\n\n![image](https://user-images.githubusercontent.com/28568478/117002786-94119c80-ad16-11eb-9c19-dd44d0494db8.png)\n![image](https://user-images.githubusercontent.com/28568478/117002798-996ee700-ad16-11eb-9a72-4cbcdd780596.png)\n![image](https://user-images.githubusercontent.com/28568478/117002811-9e339b00-ad16-11eb-9c55-2555f7bfc671.png)\n![image](https://user-images.githubusercontent.com/28568478/117002821-a2f84f00-ad16-11eb-8d56-7d4aa3dde512.png)\n![image](https://user-images.githubusercontent.com/28568478/117002835-a7246c80-ad16-11eb-8ce6-85764cfff7fe.png)\n![image](https://user-images.githubusercontent.com/28568478/117002847-abe92080-ad16-11eb-95f5-a8381a3042f4.png)\n\n","tags":["python 深拷贝浅拷贝"],"categories":["python"]},{"title":"Python中字典的键为什么要是不可变类型","url":"/2021/05/04/python/Python中字典的键为什么要是不可变类型/","content":"\n\n很多python初学者经常会有这样的疑问，为什么Python有tuple（元组）和list（列表）两种类型？为什么tuple可以作为字典的key，list不可以？要理解这个问题，首先要明白python的字典工作原理。\n\n<!--more-->\n\nPython的字典是如何工作的\n\n在Python中，字典也就是一个个的“映射”，将key映射到value：\n\n对一个特定的key可以得到一个value value = d[key]\n\n为了实现这个功能，Python必须能够做到，给出一个key，找到哪一个value与这个key对应。先来考虑一种比较简单的实现，将所有的key-value键值对存放到一个list中，每当需要的时候，就去遍历这个list，用key去和键值对的key匹配，如果相等，就拿到value。但是这种实现在数据量很大的时候就变得很低效。它的算法复杂度是O(n)，n是存放键值对的数量。\n\n为此，Python使用了hash（哈希）的方法来实现，要求每一个存放到字典中的对象都要实现hash函数，这个函数可以产生一个int值，叫做hash value（哈希值），通过这个int值，就可以快速确定对象在字典中的位置。\n\n这个查询的大致过程如下：\n\ndef lookup(d, key): '''字典的查询过程概括为下面3步: 1. 通过hash函数将key计算为哈希值. 2. 通过hash值确定一个位置，这个位置是一个存放着 可能存在冲突的元素的数组（很多地方叫做“桶”，bucket）， 每一个元素都是一个键值对，理想情况下，这个数组里只有1个元素. 3. 遍历这个数组，找到目标key，返回对应的value. ''' h = hash(key)# step 1 cl = d.data[h]# step 2 for pairin cl:# step 3 if key == pair[0]: return pair[1] else: raise KeyError, \"Key %s not found.\" % key\n\n要使这个查找过程正常工作，hash函数必须满足条件： 如果两个key产生了不同的hash value，那么这两个key对象是不想等的。 即\n\nfor alli1, i2, if hash(i1) != hash(i2), then i1 != i2\n\n否则的话，hash value不同，对象却相同，那么相同的对象产生不同的hash value，查找的时候就会进错桶（step 2），在错误的桶里永远也找不到你要找的value。\n\n另外，要让字典保持高查找效率，还要保证： 当两个key产生相同的hash value，那么他们是相等的。\n\nfor alli1, i2, if hash(i1) == hash(i2), then i1 == i2\n\n这样做的目的是，尽量满足每个hash桶只有一个元素。为什么要这样呢？ 考虑下面这个hash函数。\n\ndef hash(obj): return 1\n\n这个hash函数是满足上面我们谈的第一个条件的：如果两个key的hash value不同，那么两个key对象不相同。因为所有的对象产生的hash value都是1，所以不存在能产生不同hash value的key，也就不存在不满足的情况。但是这样做的坏处是，因为所有的hash value都相同，所以就把所有的对象分到了同一个地方。查找的时候，进行到第三步，遍历的效率就变成了O(n).\n\nHash函数应该保证所有的元素平均的分配到每一个桶中，理想的情况是，每一个位置只有一个元素。\n\n字典Key要满足的要求\n\n经过上面的讨论，我们应该明白Python为什么对字典的key有这样的要求了：\n\n要作为字典的key，对象必须要支持hash函数（即__hash__），相等比较(__eq__或__cmp__），并且满足上面我们讨论过的条件。\n\nList为什么不能作为key\n\n至于这个问题，最直接的答案就是：list没有支持__hash__方法，那么为什么呢？\n\n对于list的hash函数，我们可能有下面两种实现的方式：\n\n第一种，基于id。这满足条件，“如果hash值不同，那么他们的id当然不同”。但考虑到list一般是作为容器，基于id来hash可能会导致下面两种情况：\n\n用相同的list作为key去字典中找某个元素可能会得到不同的结果，因为是基于id hash的，所以即使他们的内容相同，字典依然将他们作为不同的元素对待。 创建一个一模一样的list用字典查找永远会得到一个KeyError。\n\n第二种，基于内容。tuple就是这样做的，但是要注意一点，list是可以修改的。当list修改之后，你就永远别想再从字典中拿回来了。见下面的代码。\n```\n>>> l = [1, 2]\n>>> d = {}\n>>> d[l] = 42\n>>> l.append(3)\n>>> d[l]\n# 原来的hash值是基于[1, 2]hash的，\n# 现在是基于[1, 2, 3]，所以找不到 Traceback (mostrecentcalllast): File \"\", line 1, in ? KeyError: [1, 2, 3]\n>>> d[[1, 2]] # 基于hash [1, 2]\n# 但是遍历的时候找不到key相等的键值对\n#（因为字典里的key变成了[1, 2, 3] Traceback (mostrecentcalllast): File \"\", line 1, in ? KeyError: [1, 2]\n```\n鉴于两种实现的方式都存在一定的副作用，所以Python规定：\n\n内置的list不能作为字典的key.\n\n但tuple是不可变，所以tuple可以作为字典的key。\n\n自定义的类型作为字典的Key\n\n用户自定义的类型就可以作为key了，默认的 hash(object) 是 id(object) , 默认的 cmp(object1,object2) 是 cmp(id(object1),id(object2))， 同样是可以修改的对象，为什么这里就没有上面说的问题呢？\n\n一般来说，在映射中比较常见的需求是用一个object替换掉原来的，所以id比内容更重要，就可以基于id来hash 如果内容重要的话，自定义的类型可以通过覆盖__hash__函数和__cmp__函数或__eq__函数来实现\n\n值得注意的是：将对象和一个value关联起来，更好的做法是将value设置为对象的一个属性。\n","tags":["不可变类型","字典"],"categories":["python"]},{"title":"python 生成器和迭代器","url":"/2021/05/04/python/python 生成器和迭代器/","content":"\n本节主要记录一下列表生成式，生成器和迭代器的知识点\n\n### **列表生成器**\n\n**首先举个例子**\n\n现在有个需求，看列表 [0，1，2，3，4，5，6，7，8，9]，要求你把列表里面的每个值加1，你怎么实现呢？\n\n方法一（简单）：\n```\ninfo = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nb = []\n# for index,i in enumerate(info):\n#     print(i+1)\n#     b.append(i+1)\n# print(b)\nfor index,i in enumerate(info):\n    info[index] +=1\nprint(info)\n```\n<!--more-->\n\n方法二（一般）：\n\n```\ninfo = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\na = map(lambda x:x+1,info)\nprint(a)\nfor i in a:\n    print(i)\n```\n\n方法三（高级）：\n```\ninfo = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\na = [i+1 for i in range(10)]\nprint(a)\n```\n### 　　生成器\n\n#### 什么是生成器？\n\n　　通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。\n\n　　所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，**在Python中，这种一边循环一边计算的机制，称为生成器：generator**\n\n　　生成器是一个特殊的程序，可以被用作控制循环的迭代行为，**python中生成器是迭代器的一种**，使用yield返回值函数，每次调用yield会暂停，而可以使用next()函数和send()函数恢复生成器。\n\n　　生成器类似于返回值为数组的一个函数，这个函数可以接受参数，可以被调用，但是，不同于一般的函数会一次性返回包括了所有数值的数组，生成器一次只能产生一个值，这样消耗的内存数量将大大减小，而且允许调用函数可以很快的处理前几个返回值，因此生成器看起来像是一个函数，但是表现得却像是迭代器\n\n#### python中的生成器\n\n　　要创建一个generator，有很多种方法，第一种方法很简单，**只有把一个列表生成式的[]中括号改为（）小括号，就创建一个generator**\n\n举例如下：\n```\n#列表生成式\nlis = [x*x for x in range(10)]\nprint(lis)\n#生成器\ngenerator_ex = (x*x for x in range(10))\nprint(generator_ex)\n\n结果：\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n<generator object <genexpr> at 0x000002A4CBF9EBA0>\n```\n　　那么创建list和generator_ex，的区别是什么呢？从表面看就是[  ]和（）,但是结果却不一样，一个打印出来是列表（因为是列表生成式），而第二个打印出来却是<generator object <genexpr> at 0x000002A4CBF9EBA0>，那么如何打印出来generator_ex的每一个元素呢？\n\n　　如果要一个个打印出来，可以通过next（）函数获得generator的下一个返回值：\n```\n#生成器\ngenerator_ex = (x*x for x in range(10))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\n结果：\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\nTraceback (most recent call last):\n\n  File \"列表生成式.py\", line 42, in <module>\n\n    print(next(generator_ex))\n\nStopIteration\n```\n　　大家可以看到，generator保存的是算法，每次调用next(generaotr_ex)就计算出他的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出StopIteration的错误，而且上面这样不断调用是一个不好的习惯，正确的方法是使用for循环，因为generator也是可迭代对象：\n```\n#生成器\ngenerator_ex = (x*x for x in range(10))\nfor i in generator_ex:\n    print(i)\n\n结果：\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\n```\n　　所以我们创建一个generator后，基本上永远不会调用next()，而是通过for循环来迭代，并且不需要关心StopIteration的错误，generator非常强大，如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。\n\n比如著名的斐波那契数列，除第一个和第二个数外，任何一个数都可以由前两个相加得到：\n\n1，1，2，3，5，8，12，21，34.....\n\n斐波那契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：\n\n```\n#fibonacci数列\ndef fib(max):\n    n,a,b =0,0,1\n    while n < max:\n        a,b =b,a+b\n        n = n+1\n        print(a)\n    return 'done'\n\na = fib(10)\nprint(fib(10))\n```\n\n　　a,b = b ,a+b  其实相当于 t =a+b ,a =b ,b =t  ，所以不必写显示写出临时变量t，就可以输出斐波那契数列的前N个数字。上面输出的结果如下：\n\n```\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\ndone\n```\n　　仔细观察，可以看出，`fib`函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。\n\n　　也就是说上面的函数也可以用generator来实现，上面我们发现，print(b)每次函数运行都要打印，占内存，所以为了不占内存，我们也可以使用生成器，这里叫yield。如下：\n```\ndef fib(max):\n    n,a,b =0,0,1\n    while n < max:\n        yield b\n        a,b =b,a+b\n        n = n+1\n    return 'done'\n\na = fib(10)\nprint(fib(10))\n```\n　　但是返回的不再是一个值，而是一个生成器，和上面的例子一样，大家可以看一下结果：\n\n```\n<generator object fib at 0x000001C03AC34FC0>\n\n```\n　　那么这样就不占内存了，这里说一下generator和函数的执行流程，函数是顺序执行的，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次被next（）调用时候从上次的返回yield语句处急需执行，也就是用多少，取多少，不占内存。\n```\ndef fib(max):\n    n,a,b =0,0,1\n    while n < max:\n        yield b\n        a,b =b,a+b\n        n = n+1\n    return 'done'\n\na = fib(10)\nprint(fib(10))\nprint(a.__next__())\nprint(a.__next__())\nprint(a.__next__())\nprint(\"可以顺便干其他事情\")\nprint(a.__next__())\nprint(a.__next__())\n\n结果：\n<generator object fib at 0x0000023A21A34FC0>\n1\n1\n2\n可以顺便干其他事情\n3\n5\n```\n　　在上面fib的例子，我们在循环过程中不断调用`yield`，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。同样的，把函数改成generator后，我们基本上从来不会用`next()`来获取下一个返回值，而是直接使用`for`循环来迭代：\n```\ndef fib(max):\n    n,a,b =0,0,1\n    while n < max:\n        yield b\n        a,b =b,a+b\n        n = n+1\n    return 'done'\nfor i in fib(6):\n    print(i)\n\n结果：\n1\n1\n2\n3\n5\n8\n```\n　　但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果拿不到返回值，那么就会报错，所以为了不让报错，就要进行异常处理，拿到返回值，如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：\n```\ndef fib(max):\n    n,a,b =0,0,1\n    while n < max:\n        yield b\n        a,b =b,a+b\n        n = n+1\n    return 'done'\ng = fib(6)\nwhile True:\n    try:\n        x = next(g)\n        print('generator: ',x)\n    except StopIteration as e:\n        print(\"生成器返回值：\",e.value)\n        break\n\n\n结果：\ngenerator:  1\ngenerator:  1\ngenerator:  2\ngenerator:  3\ngenerator:  5\ngenerator:  8\n生成器返回值： done\n```\n**还可以通过yield实现在单线程的情况下实现并发运算的效果**\n\n```\nimport time\ndef consumer(name):\n    print(\"%s 准备学习啦!\" %name)\n    while True:\n       lesson = yield\n\n       print(\"开始[%s]了,[%s]老师来讲课了!\" %(lesson,name))\n\n\ndef producer(name):\n    c = consumer('A')\n    c2 = consumer('B')\n    c.__next__()\n    c2.__next__()\n    print(\"同学们开始上课 了!\")\n    for i in range(10):\n        time.sleep(1)\n        print(\"到了两个同学!\")\n        c.send(i)\n        c2.send(i)\n\n结果：\nA 准备学习啦!\nB 准备学习啦!\n同学们开始上课 了!\n到了两个同学!\n开始[0]了,[A]老师来讲课了!\n开始[0]了,[B]老师来讲课了!\n到了两个同学!\n开始[1]了,[A]老师来讲课了!\n开始[1]了,[B]老师来讲课了!\n到了两个同学!\n开始[2]了,[A]老师来讲课了!\n开始[2]了,[B]老师来讲课了!\n到了两个同学!\n开始[3]了,[A]老师来讲课了!\n开始[3]了,[B]老师来讲课了!\n到了两个同学!\n开始[4]了,[A]老师来讲课了!\n开始[4]了,[B]老师来讲课了!\n到了两个同学!\n开始[5]了,[A]老师来讲课了!\n开始[5]了,[B]老师来讲课了!\n到了两个同学!\n开始[6]了,[A]老师来讲课了!\n开始[6]了,[B]老师来讲课了!\n到了两个同学!\n```\n　　由上面的例子我么可以发现，python提供了两种基本的方式\n\n**生成器函数：也是用def定义的，利用关键字yield一次性返回一个结果，阻塞，重新开始**\n\n**生成器表达式：返回一个对象，这个对象只有在需要的时候才产生结果**\n\n#### ——生成器函数\n\n为什么叫生成器函数？因为它随着时间的推移生成了一个数值队列。一般的函数在执行完毕之后会返回一个值然后退出，但是生成器函数会自动挂起，然后重新拾起急需执行，他会利用yield关键字关起函数，给调用者返回一个值，同时保留了当前的足够多的状态，可以使函数继续执行，生成器和迭代协议是密切相关的，**迭代器都有一个__next__()__成员方法，**这个方法要么返回迭代的下一项，要买引起异常结束迭代。\n\n```\n# 函数有了yield之后，函数名+（）就变成了生成器\n# return在生成器中代表生成器的中止，直接报错\n# next的作用是唤醒并继续执行\n# send的作用是唤醒并继续执行，发送一个信息到生成器内部\n'''生成器'''\n\ndef create_counter(n):\n    print(\"create_counter\")\n    while True:\n        yield n\n        print(\"increment n\")\n        n +=1\n\ngen = create_counter(2)\nprint(gen)\nprint(next(gen))\nprint(next(gen))\n\n结果：\n<generator object create_counter at 0x0000023A1694A938>\ncreate_counter\n2\nincrement n\n3\nProcess finished with exit code 0\n```\n\n#### ——生成器表达式\n生成器表达式来源于迭代和列表解析的组合，生成器和列表解析类似，但是它使用尖括号而不是方括号\n```\n>>> # 列表解析生成列表\n>>> [ x ** 3 for x in range(5)]\n[0, 1, 8, 27, 64]\n>>>\n>>> # 生成器表达式\n>>> (x ** 3 for x in range(5))\n<generator object <genexpr> at 0x000000000315F678>\n>>> # 两者之间转换\n>>> list(x ** 3 for x in range(5))\n[0, 1, 8, 27, 64]\n```\n\n　　**一个迭代既可以被写成生成器函数，也可以被协程生成器表达式，均支持自动和手动迭代。而且这些生成器只支持一个active迭代，也就是说生成器的迭代器就是生成器本身。**\n\n### 迭代器（迭代就是循环）\n\n**　　迭代器包含有next方法的实现，在正确的范围内返回期待的数据以及超出范围后能够抛出StopIteration的错误停止迭代。**\n\n　　我们已经知道，可以直接作用于for循环的数据类型有以下几种：\n\n一类是集合数据类型，如list,tuple,dict,set,str等\n\n一类是generator，包括生成器和带yield的generator function\n\n这些可以直接作用于for 循环的对象统称为可迭代对象：Iterable\n\n可以使用isinstance()判断一个对象是否为可**Iterable**对象\n\n```\n>>> from collections import Iterable\n>>> isinstance([], Iterable)\nTrue\n>>> isinstance({}, Iterable)\nTrue\n>>> isinstance('abc', Iterable)\nTrue\n>>> isinstance((x for x in range(10)), Iterable)\nTrue\n>>> isinstance(100, Iterable)\nFalse\n```\n　　而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。\n\n所以这里讲一下迭代器\n\n**一个实现了iter方法的对象时可迭代的，一个实现next方法的对象是迭代器**\n\n**可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。**\n\n可以使用isinstance()判断一个对象是否是**Iterator**对象：\n\n```\n>>> from collections import Iterator\n>>> isinstance((x for x in range(10)), Iterator)\nTrue\n>>> isinstance([], Iterator)\nFalse\n>>> isinstance({}, Iterator)\nFalse\n>>> isinstance('abc', Iterator)\nFalse\n\n```\n生成器都是`Iterator`对象，但`list`、`dict`、`str`虽然是`Iterable（可迭代对象）`，却不是`Iterator（迭代器）`。\n\n**把`list`、`dict`、`str`等`Iterable`变成`Iterator`**可以使用`iter()`函数**：**\n\n```\n>>> isinstance(iter([]), Iterator)\nTrue\n>>> isinstance(iter('abc'), Iterator)\nTrue\n```\n你可能会问，为什么`list`、`dict`、`str`等数据类型不是`Iterator`？\n\n这是因为Python的`Iterator`对象表示的是一个**数据流**，Iterator对象可以被`next()`函数调用并不断返回下一个数据，直到没有数据时抛出`StopIteration`错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过`next()`函数实现按需计算下一个数据，所以`Iterator`的计算是惰性的，只有在需要返回下一个数据时它才会计算。\n\n`Iterator`甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。\n\n**判断下列数据类型是可迭代对象or迭代器**\n\n```\ns='hello'\nl=[1,2,3,4]\nt=(1,2,3)\nd={'a':1}\nset={1,2,3}\nf=open('a.txt')\n\ns='hello'     #字符串是可迭代对象，但不是迭代器\nl=[1,2,3,4]     #列表是可迭代对象，但不是迭代器\nt=(1,2,3)       #元组是可迭代对象，但不是迭代器\nd={'a':1}        #字典是可迭代对象，但不是迭代器\nset={1,2,3}     #集合是可迭代对象，但不是迭代器\n# *************************************\nf=open('test.txt') #文件是可迭代对象，是迭代器\n\n#如何判断是可迭代对象，只有__iter__方法，执行该方法得到的迭代器对象。\n# 及可迭代对象通过__iter__转成迭代器对象\nfrom collections import Iterator  #迭代器\nfrom collections import Iterable  #可迭代对象\n\nprint(isinstance(s,Iterator))     #判断是不是迭代器\nprint(isinstance(s,Iterable))       #判断是不是可迭代对象\n\n#把可迭代对象转换为迭代器\nprint(isinstance(iter(s),Iterator))\n```\n**　注意：文件的判断**\n```\nf = open('housing.csv')\nfrom collections import Iterator\nfrom collections import Iterable\n\nprint(isinstance(f,Iterator))\nprint(isinstance(f,Iterable))\n\nTrue\nTrue\n```\n\n　　**结论：文件是可迭代对象，也是迭代器**\n\n**小结：**\n\n*   凡是可作用于`for`循环的对象都是`Iterable`类型；\n*   凡是可作用于`next()`函数的对象都是`Iterator`类型，它们表示一个惰性计算的序列；\n*   集合数据类型如`list`、`dict`、`str`等是`Iterable`但不是`Iterator`，不过可以通过`iter()`函数获得一个`Iterator`对象。\n\nPython3的`for`循环本质上就是通过不断调用`next()`函数实现的，例如：\n\n```\nfor x in [1, 2, 3, 4, 5]:\n    pass\n```\n\n　实际上完全等价于\n```\n# 首先获得Iterator对象:\nit = iter([1, 2, 3, 4, 5])\n# 循环:\nwhile True:\n    try:\n        # 获得下一个值:\n        x = next(it)\n    except StopIteration:\n        # 遇到StopIteration就退出循环\n        break\n```\n### 对yield的总结\n\n　　（1）通常的for..in...循环中，in后面是一个数组，这个数组就是一个可迭代对象，类似的还有链表，字符串，文件。他可以是a = [1,2,3]，也可以是a = [x*x for x in range(3)]。\n\n它的缺点也很明显，就是所有数据都在内存里面，如果有海量的数据，将会非常耗内存。\n\n　　（2）生成器是可以迭代的，但是只可以读取它一次。因为用的时候才生成，比如a = (x*x for x in range(3))。!!!!注意这里是小括号而不是方括号。\n\n　　（3）生成器（generator）能够迭代的关键是他有next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。\n\n　　（4）带有yield的函数不再是一个普通的函数，而是一个生成器generator，可用于迭代\n\n　　（5）yield是一个类似return 的关键字，迭代一次遇到yield的时候就返回yield后面或者右面的值。而且下一次迭代的时候，从上一次迭代遇到的yield后面的代码开始执行\n\n　　（6）yield就是return返回的一个值，并且记住这个返回的位置。下一次迭代就从这个位置开始。\n\n　　（7）带有yield的函数不仅仅是只用于for循环，而且可用于某个函数的参数，只要这个函数的参数也允许迭代参数。\n\n　　（8）send()和next()的区别就在于send可传递参数给yield表达式，这时候传递的参数就会作为yield表达式的值，而yield的参数是返回给调用者的值，也就是说send可以强行修改上一个yield表达式值。\n\n　　（9）send()和next()都有返回值，他们的返回值是当前迭代遇到的yield的时候，yield后面表达式的值，其实就是当前迭代yield后面的参数。\n\n　　（10）第一次调用时候必须先next（）或send（）,否则会报错，send后之所以为None是因为这时候没有上一个yield，所以也可以认为next（）等同于send(None)\n\n\n##### [原文：python 生成器和迭代器有这篇就够了](https://www.cnblogs.com/wj-1314/p/8490822.html)\n","tags":["python生成器","python迭代器"],"categories":["python"]},{"title":"Python中tuple+=赋值的四个问题","url":"/2021/05/04/python/Python中tuple+=赋值的四个问题/","content":"\n## 问题\n\n首先看第一个问题, 如下面的代码段:\n\n```\n\n>>> t = (1,2, [30,40])\n\n>>> t[2] += [50,60]\n\n```\n会产生什么结果呢？ 给出了四个选项:\n1. `t` 变成 `[1,2, [30,40,50,60]` \n2. `TypeError is raised with the message 'tuple' object does not support item assignment` \n3\\. Neither 1 nor 2\n4\\. Both 1 and 2\n\n按照之前的理解, `tuple`里面的元素是不能被修改的，因此会选`2`. 如果真是这样的话，这篇笔记就没必要了，Fluent Python中也就不会拿出一节来讲了。 正确答案是`4`\n\n\n<!--more-->\n\n\n```\n\n>>> t = (1,2,[30,40])\n\n>>> t[2] += [50,60]\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: 'tuple' object does not support item assignment\n\n>>> t\n\n(1, 2, [30, 40, 50, 60])\n\n```\n\n问题来了，为什么异常都出来了， `t`还是变了? 再看第二种情况，稍微变化一下,将`+=`变为`=`:\n\n```\n>>> t = (1,2, [30,40])\n\n>>> t[2] = [50,60]\n\n```\n结果就成酱紫了:\n\n```\n>>> t = (1,2, [30,40])\n\n>>> t[2] = [50,60]\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: 'tuple' object does not support item assignment\n\n>>> t\n\n(1, 2, [30, 40])\n```\n\n再看第三种情况,只把`+=`换为`extend`或者`append`,:\n\n```\n>>> t = (1, 2, [30,40])\n\n>>> t[2].extend([50,60])\n\n>>> t\n\n(1, 2, [30, 40, 50, 60])\n\n>>> t[2].append(70)\n\n>>> t\n\n(1, 2, [30, 40, 50, 60, 70])\n\n```\n又正常了,没抛出异常?\n\n最后第四种情况, 用变量的形式:\n\n```\n>>> a = [30,40]\n\n>>> t = (1, 2, a)\n\n>>> a+=[50,60]\n\n>>> a\n\n[30, 40, 50, 60]\n\n>>> t\n\n(1, 2, [30, 40, 50, 60])\n\n>>> t[2] += [70,80]\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: 'tuple' object does not support item assignment\n\n>>> t\n\n(1, 2, [30, 40, 50, 60, 70, 80])\n\n```\n又是一种情况, 下面就探究一下其中的原因.\n\n## 原因\n\n首先需要重温`+=`这个运算符,如`a+=b`:\n\n*   对于可变对象(mutable object)如`list`, `+=`操作的结果会直接在`a`对应的变量进行修改，而`a`对应的地址不变.\n*   对于不可变对象(imutable object)如`tuple`, `+=`则是等价于`a = a+b` 会产生新的变量，然后绑定到`a`上而已.\n\n如下代码段, 可以看出来:\n\n```\n>>> a = [1,2,3]\n\n>>> id(a)\n\n53430752\n\n>>> a+=[4,5]\n\n>>> a\n\n[1, 2, 3, 4, 5]\n\n>>> id(a)\n\n53430752 # 地址没有变化\n\n>>> b = (1,2,3)\n\n>>> id(b)\n\n49134888\n\n>>> b += (4,5)\n\n>>> b\n\n(1, 2, 3, 4, 5)\n\n>>> id(b)\n\n48560912 # 地址变化了\n\n```\n\n此外还需要注意的是, python中的`tuple`作为不可变对象, 也就是我们平时说的元素不能改变, 实际上从报错信息`TypeError: 'tuple' object does not support item assignment`来看, 更准确的说法是指其中的元素不支持赋值操作`=`(**assignment**).\n\n先看最简单的第二种情况, 它的结果是符合我们的预期, 因为`=`产生了`assign`的操作.(在[由一个例子到python的名字空间](http://shomy.top/2016/03/01/python-namespace-1/) 中指出了赋值操作`=`就是创建新的变量), 因此`s[2]=[50,60]`就会抛出异常.\n\n再看第三种情况,包含`extend/append`的, 结果tuple中的列表值发生了变化,但是没有异常抛出. 这个其实也相对容易理解. 因为我们知道`tuple`中存储的其实是元素所对应的地址(id), 因此如果没有赋值操作且tuple中的元素的`id`不变,即可,而`list.extend/append`只是修改了列表的元素,而列表本身id并没有变化,看看下面的例子:\n\n```\n>>> a=(1,2,[30,40])\n\n>>> id(a[2])\n\n140628739513736\n\n>>> a[2].extend([50,60])\n\n>>> a\n\n(1, 2, [30, 40, 50, 60])\n\n>>> id(a[2])\n\n140628739513736\n```\n目前解决了第二个和第三个问题, 先梳理一下, 其实就是两点:\n\n*   tuple内部的元素不支持赋值操作\n*   在第一条的基础上, 如果元素的`id`没有变化, 元素其实是可以改变的.\n\n现在再来看最初的第一个问题: `t[2] += [50,60]` 按照上面的结论, 不应该抛异常啊,因为在我们看来`+=` 对于可变对象`t[2]`来说, 属于`in-place`操作,也就是直接修改自身的内容, `id`并不变, 确认下id并没有变化:\n\n```\n>>> a=(1,2,[30,40])\n\n>>> id(a[2])\n\n140628739587392\n\n>>> a[2]+=[50,60]\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: 'tuple' object does not support item assignment\n\n>>> a\n\n(1, 2, [30, 40, 50, 60])\n\n>>> id(a[2]) # ID 并没有发生改变\n\n140628739587392\n\n```\n跟第三个问题仅仅从`t[2].extend`改成了`t[2]+=`, 就抛出异常了,所以问题应该是出在`+=`上了. 下面用`dis`模块看看它俩执行的步骤: 对下面的代码块执行`dis`:\n\n```\nt = (1,2, [30,40])\n\nt[2] += [50,60]\n\nt[2].extend([70, 80])\n\n```\n执行`python -m dis test.py`,结果如下，下面只保留第2,3行代码的执行过程，以及关键步骤的注释如下:\n\n```\n2          21 LOAD_NAME                0 (t)\n\n           24 LOAD_CONST               1 (2)\n\n           27 DUP_TOPX                 2\n\n           30 BINARY_SUBSCR\n\n           31 LOAD_CONST               4 (50)\n\n           34 LOAD_CONST               5 (60)\n\n           37 BUILD_LIST               2\n\n           40 INPLACE_ADD\n\n           41 ROT_THREE\n\n           42 STORE_SUBSCR\n\n3          43 LOAD_NAME                0 (t)\n\n           46 LOAD_CONST               1 (2)\n\n           49 BINARY_SUBSCR\n\n           50 LOAD_ATTR                1 (extend)\n\n           53 LOAD_CONST               6 (70)\n\n           56 LOAD_CONST               7 (80)\n\n           59 BUILD_LIST               2\n\n           62 CALL_FUNCTION            1\n\n           65 POP_TOP\n\n           66 LOAD_CONST               8 (None)\n\n           69 RETURN_VALUE\n\n```\n解释一下关键的语句:\n\n*   `30 BINARY_SUBSCR`: 表示将`t[2]`的值放在TOS(Top of Stack)，这里是指`[30, 40]`这个列表\n*   `40 INPLACE_ADD`: 表示`TOS += [50,60]` 执行这一步是可以成功的，修改了TOS的列表为`[30,40,50,60]`\n*   `42 STORE_SUBSCR`: 表示`s[2] = TOS` 问题就出在这里了，这里产生了一个**赋值操作**，因此会抛异常！但是上述对列表的修改已经完成, 这也就解释了开篇的第一个问题。\n\n再看`extend`的过程，前面都一样，只有这一行:\n\n*   `62 CALL_FUNCTION`: 这个直接调用内置extend函数完成了对原列表的修改，其中并没有`assign`操作，因此可以正常执行。\n\n现在逐渐清晰了， 换句话说，`+=`**并不是原子操作**，相当于下面的两步:\n\n```\nt[2].extend([50,60])\n\nt[2] = t[2]\n\n```\n第一步可以正确执行，但是第二步有了`=`，肯定会抛异常的。 同样这也可以解释在使用`+=`的时候，为何`t[2]`的`id`明明没有变化，但是仍然抛出异常了。\n\n现在用一句话总结下:\n\n> tuple中元素不支持`assign`操作，但是对于那些是可变对象的元素如列表，字典等，在没有`assign`操作的基础上，比如一些`in-place`操作，是可以修改内容的\n\n可以用第四个问题来简单验证一下，使用一个指向`[30,40]`的名称`a`来作为元素的值，然后对`a`做`in-place`的修改，其中并没有涉及到对tuple的`assign`操作，那肯定是正常执行的。\n\n## 总结\n\n这个问题其实以前也就遇到过，但是没想过具体的原理，后来翻书的时候又看到了， 于是花了点时间把这一个系列查了部分资料以及结合自己的理解都整理了出来, 算是饭后茶点吧, 不严谨的地方烦请指出.\n\n部分参考如下:\n\n*   [python bugs](http://bugs.python.org/issue11562)\n*   [python faq](https://docs.python.org/2/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works)\n*   [stackoverflow](https://stackoverflow.com/questions/10397121/why-does-of-a-list-within-a-python-tuple-raise-typeerror-but-modify-the-list)\n*   Fluent Python\n\n\n本文链接: [http://shomy.top/2017/08/17/python-tuple-assign/](http://shomy.top/2017/08/17/python-tuple-assign/)\n","tags":["tuple"],"categories":["python"]},{"title":"Python3 利用string模块生成密码","url":"/2021/05/04/python/Python3 利用string模块生成密码/","content":"\n\nstring模块中定义了一些常用的属性，包含所有数字、字母、可打印的所有ascii码等\n\n实例\n\n1. ascii_letters 生成所有大小写字母（a-z A-Z）\n```\nimport string\n\nletters = string.ascii_letters\nprint(letters)\n\n>>> abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n<!--more-->\n\n2. ascii_lowercase 生成所有小写字母（a-z）\n```\nimport string\n\nlowercase = string.asscii_lowercase\nprint(lowercase)\n\n>>> abcdefghijklmnopqrstuvwxyz\n ```\n\n3. ascii_uppercase 生成所有大写字母（A-Z）\n```\nimport string\n\nuppercase = string.ascii_uppercase\nprint(uppercase)\n\n>>> ABCDEFGHIJKLMNOPQRSTUVWXYZ\n ```\n\n4. digits 生成所有数字（0-9）\n```\nimport string\n\ndigits = string.digits\nprint(digits)\n\n>>> 0123456789\n ```\n\n5. punctuation 生成所有标点符号\n```\nimport string\n\npunctuation = string.punctuation\nprint(punctuotion)\n\n>>> !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\n```\n\n#密码生成器\n ```\ndef main():\n    \"\"\"密码生成器\"\"\"\n    a = string.ascii_letters + string.digits + string.punctuation\n    key = random.sample(a, 16)\n    keys = \"\".join(key)\n    print(keys)\n```\n","tags":["密码","gen-secret"],"categories":["python"]},{"title":"paramiko 远程执行命令","url":"/2021/05/04/python/paramiko 远程执行命令/","content":"\n# [Python学习总结 06 paramiko 远程执行命令](https://www.cnblogs.com/wangshuo1/p/6265360.html)\n\n  有时会需要在远程的机器上执行一个命令，并获得其返回结果。对于这种情况，python 可以很容易的实现。\n\n# 1 工具\n\nPython paramiko\n\n1) Paramiko模块安装\n\n　　在Linux的Terminal中，直接输入pip install paramiko 命令安装。\n\n2）确定paramiko安装成功\n\n　　在python命令行输入import paramiko，确认是否安装成功，没报错就没问题。\n\n<!--more-->\n\n# 2 步骤\n\n1 导入 paramiko 模块\n\n```\n#!/usr/bin/python\nimport paramiko\n```\n\n2 创建 ssh 连接函数\n\n```\ndef ssh_connect( _host, _username, _password ):\n    try:\n        _ssh_fd = paramiko.SSHClient()\n        _ssh_fd.set_missing_host_key_policy( paramiko.AutoAddPolicy() )\n        _ssh_fd.connect( _host, username = _username, password = _password )\n    except Exception, e:\n        print( 'ssh %s@%s: %s' % (_username, _host, e) )\n        exit()\n    return _ssh_fd\n```\n\n3 创建命令执行函数\n\n```\ndef ssh_exec_cmd( _ssh_fd, _cmd ):\n    return _ssh_fd.exec_command( _cmd )\n```\n4 创建关闭 ssh 函数\n\n```\ndef ssh_close( _ssh_fd ):\n    _ssh_fd.close()\n```\n\n5 使用示例\n\n```def main():\n    hostname = '192.168.55.243'\n    port = 22\n    username = 'root'\n    password = 'P@ssw0rd'\n    cmd = \"ps -ef|grep java\"\n\n    sshd = ssh_connect( hostname , username , password )\n    stdin, stdout, stderr = ssh_exec_cmd( sshd, cmd )\n    err_list = stderr.readlines()\n\n    if len( err_list ) > 0:\n        print 'ERROR:' + err_list[0]\n        exit()\n\n    for item in stdout.readlines():\n        print item,\n    ssh_close( sshd )\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n　　如果执行脚本成功，会成功返回以下结果。\n\n```\nroot      2540  2536  2 14:13 pts/4    00:01:21 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.resource.App\nroot      3442  3387  0  2016 ?        01:09:00 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.product.App\nroot      3451  3390  0  2016 ?        01:04:54 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.report.App\nroot      3452  3388  0  2016 ?        00:51:00 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.workflow.launcher.App\nroot      3892  3886  0  2016 ?        00:29:59 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.charge.App\nroot      4509  4507  0 15:09 ?        00:00:00 bash -c ps -ef|grep java\nroot      4519  4509  0 15:09 ?        00:00:00 grep java\nroot     12861 12857  0 Jan06 ?        00:09:06 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.workorder.App\nroot     16484 16480  0  2016 ?        00:45:27 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.billing.App\nroot     18699 18694  0 Jan06 ?        00:09:30 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.order.App\nroot     21902 21898  0 Jan05 ?        00:18:46 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.user.launcher.App\n ```\n\n 　　在实际的开发中，每次更新模块的jar包时，都需要使用 ps -ef | grep java, 查看模块的进程号，然后使用使用命令 kill -9 进程号，处理掉进程，然后重新启动 模块。\n\n下面尝试使用python脚本来代替手工输入代码。\n\n# 3 实例\n\n1） 启动模块\n\n```\n# -*- coding: utf-8 -*-\n\nimport paramiko\nssh = paramiko.SSHClient()\nssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nssh.connect('192.168.55.243', username = 'root', password = 'P@ssw0rd', timeout = 5)\ncmd = 'nohup /csdp/charge_launcher-1.0-release/bin/run.sh > /csdp/charge_launcher-1.0-release/bin/nohup.out 2>&1 & \\r\\n'\n\npassword= 'P@ssw0rd'\n\nstdin, stdout, stderr = ssh.exec_command( cmd )\n##stdin, stdout, stderr = ssh.exec_command('sudo -S %s\\n' % cmd )\n##stdin.write('%s\\r\\n' % password)\n##stdin.flush()\nprint \"------------------------\"\n##print stdout.readlines()\n##print stderr.read()\n\n\nprint \"------------------------\"\ncmd = 'pwd'\nstdin, stdout, stderr = ssh.exec_command(cmd )\nprint stdout.readlines()\n\nssh.close()\n```\n2） 远程上传文件\n\n```\n# -*- coding: utf-8 -*-\nimport paramiko\n\nserverIp = '192.168.55.243'\nserverUser = 'root'\nserverPwd = 'P@ssw0rd'\n\nlocalFile = 'user-1.0-release.jar'\nlocalpath = r'D:\\workspace\\csdp201512041\\csdp-ningxia\\csdp_user\\user\\target' + os.sep + localFile\n\nremotepath = '/csdp/user_launcher-1.0-dev/lib/' + localFile\n\ndef ftpModuleFile():\n    t = paramiko.Transport(( serverIp ,22))\n    t.connect(username = serverUser , password = serverPwd)\n    sftp = paramiko.SFTPClient.from_transport(t)\n   # remotepath='/csdp/user_launcher-1.0-dev/user-1.0-release.jar'\n   # localpath= r'D:\\workspace\\csdp201512041\\csdp-ningxia\\csdp_user\\user\\target\\user-1.0-release.jar'\n    sftp.put(localpath,remotepath)\n    t.close()\n    print(\"：） 成功上传%s文件。\" % remotepath)\n\nif __name__ == '__main__':\n   ftpModuleFile()\n```\n3) 执行远程linux命令\n\n```\n# -*- coding: utf-8 -*-\nimport paramiko\n\n\nif __name__ == \"__main__\":\n    hostname = '192.168.55.243'\n    port = 22\n    username = 'root'\n    password = 'P@ssw0rd'\n    cmd = \"ps -ef|grep java\"\n\n    ssh = paramiko.SSHClient()\n    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    #ssh.connect( hostname ,22, username , password )\n    ssh.connect(hostname,username=username,password=password,allow_agent=False,look_for_keys=False)\n    stdin, stdout, stderr = ssh.exec_command(cmd )\n    list = stdout.readlines()\n    print( list )\n\n    ssh.close()\n```\n","tags":["paramiko"],"categories":["python"]},{"title":"python内置函数-排列组合函数","url":"/2021/05/04/python/python内置函数-排列组合函数/","content":"\nproduct 笛卡尔积　　（有放回抽样排列）\n\npermutations 排列　　（不放回抽样排列）\n\ncombinations 组合,没有重复　　（不放回抽样组合）\n\ncombinations_with_replacement 组合,有重复　　（有放回抽样组合）\n\n<!--more-->\n\n详细的参见[官网](https://docs.python.org/2/library/itertools.html)。\n```\n>>> for i in itertools.product('ABCD', repeat = 2):\n...     print(i)\n...\n('A', 'A') ('A', 'B') ('A', 'C') ('A', 'D') ('B', 'A') ('B', 'B') ('B', 'C') ('B', 'D') ('C', 'A') ('C', 'B') ('C', 'C') ('C', 'D') ('D', 'A') ('D', 'B') ('D', 'C') ('D', 'D')\n>>> for i in itertools.permutations('ABCD', 2):\n...     print(i)\n...\n('A', 'B') ('A', 'C') ('A', 'D') ('B', 'A') ('B', 'C') ('B', 'D') ('C', 'A') ('C', 'B') ('C', 'D') ('D', 'A') ('D', 'B') ('D', 'C')\n>>> for i in itertools.combinations('ABCD', 2):\n...     print(i)\n...\n('A', 'B') ('A', 'C') ('A', 'D') ('B', 'C') ('B', 'D') ('C', 'D')\n>>> for i in itertools.combinations_with_replacement('ABCD', 2):\n...     print(i)\n...\n('A', 'A') ('A', 'B') ('A', 'C') ('A', 'D') ('B', 'B') ('B', 'C') ('B', 'D') ('C', 'C') ('C', 'D') ('D', 'D')</pre>\n```\n\n还有就是，combinations和permutations返回的是对象地址，原因是在python3里面，返回值已经不再是list,而是iterators（迭代器）, 所以想要使用，只用将iterator 转换成list 即可， 还有其他一些函数返回的也是一个对象，需要list转换，比如 list(map())等\n\n","tags":["python内置函数"],"categories":["python"]},{"title":"Vue.js - Day4","url":"/2021/05/04/vue/vue2.0基础课程/day4/","content":"\n# Vue.js - Day4\n\n## 父组件向子组件传值\n1. 组件实例定义方式，注意：一定要使用`props`属性来定义父组件传递过来的数据\n```\n<script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        msg: '这是父组件中的消息'\n      },\n      components: {\n        son: {\n          template: '<h1>这是子组件 --- {{finfo}}</h1>',\n          props: ['finfo']\n        }\n      }\n    });\n  </script>\n```\n2. 使用`v-bind`或简化指令，将数据传递到子组件中：\n```\n<div id=\"app\">\n    <son :finfo=\"msg\"></son>\n  </div>\n```\n\n## 子组件向父组件传值\n1. 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；\n2. 父组件将方法的引用传递给子组件，其中，`getMsg`是父组件中`methods`中定义的方法名称，`func`是子组件调用传递过来方法时候的方法名称\n```\n<son @func=\"getMsg\"></son>\n```\n3. 子组件内部通过`this.$emit('方法名', 要传递的数据)`方式，来调用父组件中的方法，同时把数据传递给父组件使用\n```\n<div id=\"app\">\n    <!-- 引用父组件 -->\n    <son @func=\"getMsg\"></son>\n\n    <!-- 组件模板定义 -->\n    <script type=\"x-template\" id=\"son\">\n      <div>\n        <input type=\"button\" value=\"向父组件传值\" @click=\"sendMsg\" />\n      </div>\n    </script>\n  </div>\n\n  <script>\n    // 子组件的定义方式\n    Vue.component('son', {\n      template: '#son', // 组件模板Id\n      methods: {\n        sendMsg() { // 按钮的点击事件\n          this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去\n        }\n      }\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {\n        getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义\n          alert(val);\n        }\n      }\n    });\n  </script>\n```\n\n## 组件中data和props的区别\n\n## 评论列表案例\n目标：主要练习父子组件之间传值\n\n## 使用 `this.$refs` 来获取元素和组件\n```\n  <div id=\"app\">\n    <div>\n      <input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" />\n      <!-- 使用 ref 获取元素 -->\n      <h1 ref=\"myh1\">这是一个大大的H1</h1>\n\n      <hr>\n      <!-- 使用 ref 获取子组件 -->\n      <my-com ref=\"mycom\"></my-com>\n    </div>\n  </div>\n\n  <script>\n    Vue.component('my-com', {\n      template: '<h5>这是一个子组件</h5>',\n      data() {\n        return {\n          name: '子组件'\n        }\n      }\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {\n        getElement() {\n          // 通过 this.$refs 来获取元素\n          console.log(this.$refs.myh1.innerText);\n          // 通过 this.$refs 来获取组件\n          console.log(this.$refs.mycom.name);\n        }\n      }\n    });\n  </script>\n```\n\n## 什么是路由\n1. **后端路由：**对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；\n\n2. **前端路由：**对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；\n\n3. 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；\n\n## 在 vue 中使用 vue-router\n1. 导入 vue-router 组件类库：\n```\n<!-- 1. 导入 vue-router 组件类库 -->\n  <script src=\"./lib/vue-router-2.7.0.js\"></script>\n```\n2. 使用 router-link 组件来导航\n```\n<!-- 2. 使用 router-link 组件来导航 -->\n<router-link to=\"/login\">登录</router-link>\n<router-link to=\"/register\">注册</router-link>\n```\n3. 使用 router-view 组件来显示匹配到的组件\n```\n<!-- 3. 使用 router-view 组件来显示匹配到的组件 -->\n<router-view></router-view>\n```\n4. 创建使用`Vue.extend`创建组件\n```\n    // 4.1 使用 Vue.extend 来创建登录组件\n    var login = Vue.extend({\n      template: '<h1>登录组件</h1>'\n    });\n\n    // 4.2 使用 Vue.extend 来创建注册组件\n    var register = Vue.extend({\n      template: '<h1>注册组件</h1>'\n    });\n```\n5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则\n```\n// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则\n    var router = new VueRouter({\n      routes: [\n        { path: '/login', component: login },\n        { path: '/register', component: register }\n      ]\n    });\n```\n6. 使用 router 属性来使用路由规则\n```\n// 6. 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      router: router // 使用 router 属性来使用路由规则\n    });\n```\n\n## 使用tag属性指定router-link渲染的标签类型\n\n## 设置路由重定向\n\n## 设置路由高亮\n\n## 设置路由切换动效\n\n## 在路由规则中定义参数\n1. 在规则中定义参数：\n```\n{ path: '/register/:id', component: register }\n```\n2. 通过 `this.$route.params`来获取路由中的参数：\n```\nvar register = Vue.extend({\n      template: '<h1>注册组件 --- {{this.$route.params.id}}</h1>'\n    });\n```\n\n## 使用 `children` 属性实现路由嵌套\n```\n  <div id=\"app\">\n    <router-link to=\"/account\">Account</router-link>\n\n    <router-view></router-view>\n  </div>\n\n  <script>\n    // 父路由中的组件\n    const account = Vue.extend({\n      template: `<div>\n        这是account组件\n        <router-link to=\"/account/login\">login</router-link> |\n        <router-link to=\"/account/register\">register</router-link>\n        <router-view></router-view>\n      </div>`\n    });\n\n    // 子路由中的 login 组件\n    const login = Vue.extend({\n      template: '<div>登录组件</div>'\n    });\n\n    // 子路由中的 register 组件\n    const register = Vue.extend({\n      template: '<div>注册组件</div>'\n    });\n\n    // 路由实例\n    var router = new VueRouter({\n      routes: [\n        { path: '/', redirect: '/account/login' }, // 使用 redirect 实现路由重定向\n        {\n          path: '/account',\n          component: account,\n          children: [ // 通过 children 数组属性，来实现路由的嵌套\n            { path: 'login', component: login }, // 注意，子路由的开头位置，不要加 / 路径符\n            { path: 'register', component: register }\n          ]\n        }\n      ]\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      components: {\n        account\n      },\n      router: router\n    });\n  </script>\n```\n\n## 命名视图实现经典布局\n1. 标签代码结构：\n```\n<div id=\"app\">\n    <router-view></router-view>\n    <div class=\"content\">\n      <router-view name=\"a\"></router-view>\n      <router-view name=\"b\"></router-view>\n    </div>\n  </div>\n```\n2. JS代码：\n```\n<script>\n    var header = Vue.component('header', {\n      template: '<div class=\"header\">header</div>'\n    });\n\n    var sidebar = Vue.component('sidebar', {\n      template: '<div class=\"sidebar\">sidebar</div>'\n    });\n\n    var mainbox = Vue.component('mainbox', {\n      template: '<div class=\"mainbox\">mainbox</div>'\n    });\n\n    // 创建路由对象\n    var router = new VueRouter({\n      routes: [\n        {\n          path: '/', components: {\n            default: header,\n            a: sidebar,\n            b: mainbox\n          }\n        }\n      ]\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      router\n    });\n  </script>\n```\n3. CSS 样式：\n```\n  <style>\n    .header {\n      border: 1px solid red;\n    }\n\n    .content{\n      display: flex;\n    }\n    .sidebar {\n      flex: 2;\n      border: 1px solid green;\n      height: 500px;\n    }\n    .mainbox{\n      flex: 8;\n      border: 1px solid blue;\n      height: 500px;\n    }\n  </style>\n```\n\n## `watch`属性的使用\n考虑一个问题：想要实现 `名` 和 `姓` 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）\n\n1. 监听`data`中属性的改变：\n```\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\"> +\n    <input type=\"text\" v-model=\"lastName\"> =\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen',\n        fullName: 'jack - chen'\n      },\n      methods: {},\n      watch: {\n        'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据\n          this.fullName = newVal + ' - ' + this.lastName;\n        },\n        'lastName': function (newVal, oldVal) {\n          this.fullName = this.firstName + ' - ' + newVal;\n        }\n      }\n    });\n  </script>\n```\n2. 监听路由对象的改变：\n```\n<div id=\"app\">\n    <router-link to=\"/login\">登录</router-link>\n    <router-link to=\"/register\">注册</router-link>\n\n    <router-view></router-view>\n  </div>\n\n  <script>\n    var login = Vue.extend({\n      template: '<h1>登录组件</h1>'\n    });\n\n    var register = Vue.extend({\n      template: '<h1>注册组件</h1>'\n    });\n\n    var router = new VueRouter({\n      routes: [\n        { path: \"/login\", component: login },\n        { path: \"/register\", component: register }\n      ]\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      router: router,\n      watch: {\n        '$route': function (newVal, oldVal) {\n          if (newVal.path === '/login') {\n            console.log('这是登录组件');\n          }\n        }\n      }\n    });\n  </script>\n```\n\n## `computed`计算属性的使用\n1. 默认只有`getter`的计算属性：\n```\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\"> +\n    <input type=\"text\" v-model=\"lastName\"> =\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen'\n      },\n      methods: {},\n      computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值\n        fullName() {\n          return this.firstName + ' - ' + this.lastName;\n        }\n      }\n    });\n  </script>\n```\n2. 定义有`getter`和`setter`的计算属性：\n```\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\">\n    <input type=\"text\" v-model=\"lastName\">\n    <!-- 点击按钮重新为 计算属性 fullName 赋值 -->\n    <input type=\"button\" value=\"修改fullName\" @click=\"changeName\">\n\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen'\n      },\n      methods: {\n        changeName() {\n          this.fullName = 'TOM - chen2';\n        }\n      },\n      computed: {\n        fullName: {\n          get: function () {\n            return this.firstName + ' - ' + this.lastName;\n          },\n          set: function (newVal) {\n            var parts = newVal.split(' - ');\n            this.firstName = parts[0];\n            this.lastName = parts[1];\n          }\n        }\n      }\n    });\n  </script>\n```\n\n## `watch`、`computed`和`methods`之间的对比\n1. `computed`属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；\n2. `methods`方法表示一个具体的操作，主要书写业务逻辑；\n3. `watch`一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是`computed`和`methods`的结合体；\n\n## `nrm`的安装使用\n作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；\n什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；\n1. 运行`npm i nrm -g`全局安装`nrm`包；\n2. 使用`nrm ls`查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；\n3. 使用`nrm use npm`或`nrm use taobao`切换不同的镜像源地址；\n\n> 注意： nrm 只是单纯的提供了几个常用的 下载包的 URL地址，并能够让我们在 这几个 地址之间，很方便的进行切换，但是，我们每次装包的时候，使用的 装包工具，都是  npm\n\n> npm i cnpm -g\n[npm 和 cnpm 的区别，你真的搞懂了嘛](https://www.cnblogs.com/chase-star/p/10455703.html)\n\n## 相关文件\n1. [URL中的hash（井号）](http://www.cnblogs.com/joyho/articles/4430148.html)\n","tags":["vue","vue2.0基础课程"],"categories":["vue2.0基础课程"]},{"title":"Vue.js - Day3","url":"/2021/05/04/vue/vue2.0基础课程/day3/","content":"\n# Vue.js - Day3\n\n## 定义Vue组件\n什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；\n组件化和模块化的不同：\n + 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；\n + 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；\n### 全局组件定义的三种方式\n1. 使用 Vue.extend 配合 Vue.component 方法：\n```\nvar login = Vue.extend({\n      template: '<h1>登录</h1>'\n    });\n    Vue.component('login', login);\n```\n2. 直接使用 Vue.component 方法：\n```\nVue.component('register', {\n      template: '<h1>注册</h1>'\n    });\n```\n3. 将模板字符串，定义到script标签种：\n```\n<script id=\"tmpl\" type=\"x-template\">\n      <div><a href=\"#\">登录</a> | <a href=\"#\">注册</a></div>\n    </script>\n```\n同时，需要使用 Vue.component 来定义组件：\n```\nVue.component('account', {\n      template: '#tmpl'\n    });\n```\n\n> 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！\n\n### 组件中展示数据和响应事件\n1. 在组件中，`data`需要被定义为一个方法，例如：\n```\nVue.component('account', {\n      template: '#tmpl',\n      data() {\n        return {\n          msg: '大家好！'\n        }\n      },\n      methods:{\n        login(){\n          alert('点击了登录按钮');\n        }\n      }\n    });\n```\n2. 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的`data`属性中的值，需要使用`this`来访问；\n\n### 【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象\n1. 通过计数器案例演示\n\n### 使用`components`属性定义局部子组件\n1. 组件实例定义方式：\n```\n<script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      components: { // 定义子组件\n        account: { // account 组件\n          template: '<div><h1>这是Account组件{{name}}</h1><login></login></div>', // 在这里使用定义的子组件\n          components: { // 定义子组件的子组件\n            login: { // login 组件\n              template: \"<h3>这是登录组件</h3>\"\n            }\n          }\n        }\n      }\n    });\n  </script>\n```\n2. 引用组件：\n```\n<div id=\"app\">\n    <account></account>\n  </div>\n```\n\n## 使用`flag`标识符结合`v-if`和`v-else`切换组件\n1. 页面结构：\n```\n<div id=\"app\">\n    <input type=\"button\" value=\"toggle\" @click=\"flag=!flag\">\n    <my-com1 v-if=\"flag\"></my-com1>\n    <my-com2 v-else=\"flag\"></my-com2>\n  </div>\n```\n2. Vue实例定义：\n```\n<script>\n    Vue.component('myCom1', {\n      template: '<h3>奔波霸</h3>'\n    })\n\n    Vue.component('myCom2', {\n      template: '<h3>霸波奔</h3>'\n    })\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        flag: true\n      },\n      methods: {}\n    });\n  </script>\n```\n\n## 使用`:is`属性来切换不同的子组件,并添加切换动画\n1. 组件实例定义方式：\n```\n  // 登录组件\n    const login = Vue.extend({\n      template: `<div>\n        <h3>登录组件</h3>\n      </div>`\n    });\n    Vue.component('login', login);\n\n    // 注册组件\n    const register = Vue.extend({\n      template: `<div>\n        <h3>注册组件</h3>\n      </div>`\n    });\n    Vue.component('register', register);\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: { comName: 'login' },\n      methods: {}\n    });\n```\n2. 使用`component`标签，来引用组件，并通过`:is`属性来指定要加载的组件：\n```\n  <div id=\"app\">\n    <a href=\"#\" @click.prevent=\"comName='login'\">登录</a>\n    <a href=\"#\" @click.prevent=\"comName='register'\">注册</a>\n    <hr>\n    <transition mode=\"out-in\">\n      <component :is=\"comName\"></component>\n    </transition>\n  </div>\n```\n3. 添加切换样式：\n```\n  <style>\n    .v-enter,\n    .v-leave-to {\n      opacity: 0;\n      transform: translateX(30px);\n    }\n\n    .v-enter-active,\n    .v-leave-active {\n      position: absolute;\n      transition: all 0.3s ease;\n    }\n\n    h3{\n      margin: 0;\n    }\n  </style>\n```\n\n## 父组件向子组件传值\n1. 组件实例定义方式，注意：一定要使用`props`属性来定义父组件传递过来的数据\n```\n<script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        msg: '这是父组件中的消息'\n      },\n      components: {\n        son: {\n          template: '<h1>这是子组件 --- {{finfo}}</h1>',\n          props: ['finfo']\n        }\n      }\n    });\n  </script>\n```\n2. 使用`v-bind`或简化指令，将数据传递到子组件中：\n```\n<div id=\"app\">\n    <son :finfo=\"msg\"></son>\n  </div>\n```\n\n## 子组件向父组件传值\n1. 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；\n2. 父组件将方法的引用传递给子组件，其中，`getMsg`是父组件中`methods`中定义的方法名称，`func`是子组件调用传递过来方法时候的方法名称\n```\n<son @func=\"getMsg\"></son>\n```\n3. 子组件内部通过`this.$emit('方法名', 要传递的数据)`方式，来调用父组件中的方法，同时把数据传递给父组件使用\n```\n<div id=\"app\">\n    <!-- 引用父组件 -->\n    <son @func=\"getMsg\"></son>\n\n    <!-- 组件模板定义 -->\n    <script type=\"x-template\" id=\"son\">\n      <div>\n        <input type=\"button\" value=\"向父组件传值\" @click=\"sendMsg\" />\n      </div>\n    </script>\n  </div>\n\n  <script>\n    // 子组件的定义方式\n    Vue.component('son', {\n      template: '#son', // 组件模板Id\n      methods: {\n        sendMsg() { // 按钮的点击事件\n          this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去\n        }\n      }\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {\n        getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义\n          alert(val);\n        }\n      }\n    });\n  </script>\n```\n\n## 评论列表案例\n目标：主要练习父子组件之间传值\n\n## 使用 `this.$refs` 来获取元素和组件\n```\n  <div id=\"app\">\n    <div>\n      <input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" />\n      <!-- 使用 ref 获取元素 -->\n      <h1 ref=\"myh1\">这是一个大大的H1</h1>\n\n      <hr>\n      <!-- 使用 ref 获取子组件 -->\n      <my-com ref=\"mycom\"></my-com>\n    </div>\n  </div>\n\n  <script>\n    Vue.component('my-com', {\n      template: '<h5>这是一个子组件</h5>',\n      data() {\n        return {\n          name: '子组件'\n        }\n      }\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {\n        getElement() {\n          // 通过 this.$refs 来获取元素\n          console.log(this.$refs.myh1.innerText);\n          // 通过 this.$refs 来获取组件\n          console.log(this.$refs.mycom.name);\n        }\n      }\n    });\n  </script>\n```\n\n## 什么是路由\n1. 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；\n\n2. 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；\n\n3. 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；\n\n## 在 vue 中使用 vue-router\n1. 导入 vue-router 组件类库：\n```\n<!-- 1. 导入 vue-router 组件类库 -->\n  <script src=\"./lib/vue-router-2.7.0.js\"></script>\n```\n2. 使用 router-link 组件来导航\n```\n<!-- 2. 使用 router-link 组件来导航 -->\n<router-link to=\"/login\">登录</router-link>\n<router-link to=\"/register\">注册</router-link>\n```\n3. 使用 router-view 组件来显示匹配到的组件\n```\n<!-- 3. 使用 router-view 组件来显示匹配到的组件 -->\n<router-view></router-view>\n```\n4. 创建使用`Vue.extend`创建组件\n```\n    // 4.1 使用 Vue.extend 来创建登录组件\n    var login = Vue.extend({\n      template: '<h1>登录组件</h1>'\n    });\n\n    // 4.2 使用 Vue.extend 来创建注册组件\n    var register = Vue.extend({\n      template: '<h1>注册组件</h1>'\n    });\n```\n5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则\n```\n// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则\n    var router = new VueRouter({\n      routes: [\n        { path: '/login', component: login },\n        { path: '/register', component: register }\n      ]\n    });\n```\n6. 使用 router 属性来使用路由规则\n```\n// 6. 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      router: router // 使用 router 属性来使用路由规则\n    });\n```\n\n## 设置路由高亮\n\n## 设置路由切换动效\n\n## 在路由规则中定义参数\n1. 在规则中定义参数：\n```\n{ path: '/register/:id', component: register }\n```\n2. 通过 `this.$route.params`来获取路由中的参数：\n```\nvar register = Vue.extend({\n      template: '<h1>注册组件 --- {{this.$route.params.id}}</h1>'\n    });\n```\n\n## 使用 `children` 属性实现路由嵌套\n```\n  <div id=\"app\">\n    <router-link to=\"/account\">Account</router-link>\n\n    <router-view></router-view>\n  </div>\n\n  <script>\n    // 父路由中的组件\n    const account = Vue.extend({\n      template: `<div>\n        这是account组件\n        <router-link to=\"/account/login\">login</router-link> |\n        <router-link to=\"/account/register\">register</router-link>\n        <router-view></router-view>\n      </div>`\n    });\n\n    // 子路由中的 login 组件\n    const login = Vue.extend({\n      template: '<div>登录组件</div>'\n    });\n\n    // 子路由中的 register 组件\n    const register = Vue.extend({\n      template: '<div>注册组件</div>'\n    });\n\n    // 路由实例\n    var router = new VueRouter({\n      routes: [\n        { path: '/', redirect: '/account/login' }, // 使用 redirect 实现路由重定向\n        {\n          path: '/account',\n          component: account,\n          children: [ // 通过 children 数组属性，来实现路由的嵌套\n            { path: 'login', component: login }, // 注意，子路由的开头位置，不要加 / 路径符\n            { path: 'register', component: register }\n          ]\n        }\n      ]\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      components: {\n        account\n      },\n      router: router\n    });\n  </script>\n```\n\n## 命名视图实现经典布局\n1. 标签代码结构：\n```\n<div id=\"app\">\n    <router-view></router-view>\n    <div class=\"content\">\n      <router-view name=\"a\"></router-view>\n      <router-view name=\"b\"></router-view>\n    </div>\n  </div>\n```\n2. JS代码：\n```\n<script>\n    var header = Vue.component('header', {\n      template: '<div class=\"header\">header</div>'\n    });\n\n    var sidebar = Vue.component('sidebar', {\n      template: '<div class=\"sidebar\">sidebar</div>'\n    });\n\n    var mainbox = Vue.component('mainbox', {\n      template: '<div class=\"mainbox\">mainbox</div>'\n    });\n\n    // 创建路由对象\n    var router = new VueRouter({\n      routes: [\n        {\n          path: '/', components: {\n            default: header,\n            a: sidebar,\n            b: mainbox\n          }\n        }\n      ]\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      router\n    });\n  </script>\n```\n3. CSS 样式：\n```\n  <style>\n    .header {\n      border: 1px solid red;\n    }\n\n    .content{\n      display: flex;\n    }\n    .sidebar {\n      flex: 2;\n      border: 1px solid green;\n      height: 500px;\n    }\n    .mainbox{\n      flex: 8;\n      border: 1px solid blue;\n      height: 500px;\n    }\n  </style>\n```\n\n## `watch`属性的使用\n考虑一个问题：想要实现 `名` 和 `姓` 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）\n\n1. 监听`data`中属性的改变：\n```\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\"> +\n    <input type=\"text\" v-model=\"lastName\"> =\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen',\n        fullName: 'jack - chen'\n      },\n      methods: {},\n      watch: {\n        'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据\n          this.fullName = newVal + ' - ' + this.lastName;\n        },\n        'lastName': function (newVal, oldVal) {\n          this.fullName = this.firstName + ' - ' + newVal;\n        }\n      }\n    });\n  </script>\n```\n2. 监听路由对象的改变：\n```\n<div id=\"app\">\n    <router-link to=\"/login\">登录</router-link>\n    <router-link to=\"/register\">注册</router-link>\n\n    <router-view></router-view>\n  </div>\n\n  <script>\n    var login = Vue.extend({\n      template: '<h1>登录组件</h1>'\n    });\n\n    var register = Vue.extend({\n      template: '<h1>注册组件</h1>'\n    });\n\n    var router = new VueRouter({\n      routes: [\n        { path: \"/login\", component: login },\n        { path: \"/register\", component: register }\n      ]\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      router: router,\n      watch: {\n        '$route': function (newVal, oldVal) {\n          if (newVal.path === '/login') {\n            console.log('这是登录组件');\n          }\n        }\n      }\n    });\n  </script>\n```\n\n## `computed`计算属性的使用\n1. 默认只有`getter`的计算属性：\n```\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\"> +\n    <input type=\"text\" v-model=\"lastName\"> =\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen'\n      },\n      methods: {},\n      computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值\n        fullName() {\n          return this.firstName + ' - ' + this.lastName;\n        }\n      }\n    });\n  </script>\n```\n2. 定义有`getter`和`setter`的计算属性：\n```\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\">\n    <input type=\"text\" v-model=\"lastName\">\n    <!-- 点击按钮重新为 计算属性 fullName 赋值 -->\n    <input type=\"button\" value=\"修改fullName\" @click=\"changeName\">\n\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen'\n      },\n      methods: {\n        changeName() {\n          this.fullName = 'TOM - chen2';\n        }\n      },\n      computed: {\n        fullName: {\n          get: function () {\n            return this.firstName + ' - ' + this.lastName;\n          },\n          set: function (newVal) {\n            var parts = newVal.split(' - ');\n            this.firstName = parts[0];\n            this.lastName = parts[1];\n          }\n        }\n      }\n    });\n  </script>\n```\n\n## `watch`、`computed`和`methods`之间的对比\n1. `computed`属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；\n2. `methods`方法表示一个具体的操作，主要书写业务逻辑；\n3. `watch`一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是`computed`和`methods`的结合体；\n\n## `nrm`的安装使用\n作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；\n什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；\n1. 运行`npm i nrm -g`全局安装`nrm`包；\n2. 使用`nrm ls`查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；\n3. 使用`nrm use npm`或`nrm use taobao`切换不同的镜像源地址；\n\n## 相关文件\n1. [URL中的hash（井号）](http://www.cnblogs.com/joyho/articles/4430148.html)\n","tags":["vue","vue2.0基础课程"],"categories":["vue2.0基础课程"]},{"title":"Vue.js - Day2","url":"/2021/05/02/vue/vue2.0基础课程/day2/","content":"\n# Vue.js - Day2\n\n## 品牌管理案例\n\n### 添加新品牌\n\n### 删除品牌\n\n### 根据条件筛选品牌\n\n1. 1.x 版本中的filterBy指令，在2.x中已经被废除：\n\n[filterBy - 指令](https://v1-cn.vuejs.org/api/#filterBy)\n\n```\n\n<tr v-for=\"item in list | filterBy searchName in 'name'\">\n\n  <td>{{item.id}}</td>\n\n  <td>{{item.name}}</td>\n\n  <td>{{item.ctime}}</td>\n\n  <td>\n\n    <a href=\"#\" @click.prevent=\"del(item.id)\">删除</a>\n\n  </td>\n\n</tr>\n\n```\n\n2. 在2.x版本中[手动实现筛选的方式](https://cn.vuejs.org/v2/guide/list.html#显示过滤-排序结果)：\n\n+ 筛选框绑定到 VM 实例中的 `searchName` 属性：\n\n```\n\n<hr> 输入筛选名称：\n\n<input type=\"text\" v-model=\"searchName\">\n\n```\n\n+ 在使用 `v-for` 指令循环每一行数据的时候，不再直接 `item in list`，而是 `in` 一个 过滤的methods 方法，同时，把过滤条件`searchName`传递进去：\n\n```\n\n<tbody>\n\n      <tr v-for=\"item in search(searchName)\">\n\n        <td>{{item.id}}</td>\n\n        <td>{{item.name}}</td>\n\n        <td>{{item.ctime}}</td>\n\n        <td>\n\n          <a href=\"#\" @click.prevent=\"del(item.id)\">删除</a>\n\n        </td>\n\n      </tr>\n\n    </tbody>\n\n```\n\n+ `search` 过滤方法中，使用 数组的 `filter` 方法进行过滤：\n\n```\n\nsearch(name) {\n\n  return this.list.filter(x => {\n\n    return x.name.indexOf(name) != -1;\n\n  });\n\n}\n\n```\n\n## Vue调试工具`vue-devtools`的安装步骤和使用\n\n[Vue.js devtools - 翻墙安装方式 - 推荐](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN)\n\n## 过滤器\n\n概念：Vue.js 允许你自定义过滤器，**可被用作一些常见的文本格式化**。过滤器可以用在两个地方：**mustache 插值和 v-bind 表达式**。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；\n\n### 私有过滤器\n\n1. HTML元素：\n\n```\n\n<td>{{item.ctime | dataFormat('yyyy-mm-dd')}}</td>\n\n```\n\n2. 私有 `filters` 定义方式：\n\n```\n\nfilters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用\n\n    dataFormat(input, pattern = \"\") { // 在参数列表中 通过 pattern=\"\" 来指定形参默认值，防止报错\n\n      var dt = new Date(input);\n\n      // 获取年月日\n\n      var y = dt.getFullYear();\n\n      var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n\n      var d = dt.getDate().toString().padStart(2, '0');\n\n\n\n      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日\n\n      // 否则，就返回  年-月-日 时：分：秒\n\n      if (pattern.toLowerCase() === 'yyyy-mm-dd') {\n\n        return `${y}-${m}-${d}`;\n\n      } else {\n\n        // 获取时分秒\n\n        var hh = dt.getHours().toString().padStart(2, '0');\n\n        var mm = dt.getMinutes().toString().padStart(2, '0');\n\n        var ss = dt.getSeconds().toString().padStart(2, '0');\n\n\n\n        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n\n      }\n\n    }\n\n  }\n\n```\n\n\n\n> 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString='') 或 String.prototype.padEnd(maxLength, fillString='')来填充字符串；\n\n\n\n\n\n### 全局过滤器\n\n```\n\n// 定义一个全局过滤器\n\nVue.filter('dataFormat', function (input, pattern = '') {\n\n  var dt = new Date(input);\n\n  // 获取年月日\n\n  var y = dt.getFullYear();\n\n  var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n\n  var d = dt.getDate().toString().padStart(2, '0');\n\n\n\n  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日\n\n  // 否则，就返回  年-月-日 时：分：秒\n\n  if (pattern.toLowerCase() === 'yyyy-mm-dd') {\n\n    return `${y}-${m}-${d}`;\n\n  } else {\n\n    // 获取时分秒\n\n    var hh = dt.getHours().toString().padStart(2, '0');\n\n    var mm = dt.getMinutes().toString().padStart(2, '0');\n\n    var ss = dt.getSeconds().toString().padStart(2, '0');\n\n\n\n    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n\n  }\n\n});\n\n```\n\n\n\n> 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！\n\n\n\n## 键盘修饰符以及自定义键盘修饰符\n\n### 1.x中自定义键盘修饰符【了解即可】\n\n```\n\nVue.directive('on').keyCodes.f2 = 113;\n\n```\n\n### [2.x中自定义键盘修饰符](https://cn.vuejs.org/v2/guide/events.html#键值修饰符)\n\n1. 通过`Vue.config.keyCodes.名称 = 按键值`来自定义案件修饰符的别名：\n\n```\n\nVue.config.keyCodes.f2 = 113;\n\n```\n\n2. 使用自定义的按键修饰符：\n\n```\n\n<input type=\"text\" v-model=\"name\" @keyup.f2=\"add\">\n\n```\n\n\n\n\n\n## [自定义指令](https://cn.vuejs.org/v2/guide/custom-directive.html)\n\n1. 自定义全局和局部的 自定义指令：\n\n```\n\n    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：\n\n    Vue.directive('focus', {\n\n      inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用\n\n        el.focus();\n\n      }\n\n    });\n\n\n\n    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：\n\n      directives: {\n\n        color: { // 为元素设置指定的字体颜色\n\n          bind(el, binding) {\n\n            el.style.color = binding.value;\n\n          }\n\n        },\n\n        'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数\n\n          el.style.fontWeight = binding2.value;\n\n        }\n\n      }\n\n```\n\n2. 自定义指令的使用方式：\n\n```\n\n<input type=\"text\" v-model=\"searchName\" v-focus v-color=\"'red'\" v-font-weight=\"900\">\n\n```\n\n\n\n## Vue 1.x 中 自定义元素指令【已废弃,了解即可】\n```\nVue.elementDirective('red-color', {\n  bind: function () {\n    this.el.style.color = 'red';\n  }\n});\n```\n使用方式：\n```\n<red-color>1232</red-color>\n```\n\n\n## [vue实例的生命周期](https://cn.vuejs.org/v2/guide/instance.html#实例生命周期)\n+ 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！\n+ [生命周期钩子](https://cn.vuejs.org/v2/api/#选项-生命周期钩子)：就是生命周期事件的别名而已；\n+ 生命周期钩子 = 生命周期函数 = 生命周期事件\n+ 主要的生命周期函数分类：\n - 创建期间的生命周期函数：\n  \t+ beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性\n  \t+ created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板\n  \t+ beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中\n  \t+ mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示\n - 运行期间的生命周期函数：\n \t+ beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点\n \t+ updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！\n - 销毁期间的生命周期函数：\n \t+ beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。\n \t+ destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。\n![lifecycle](https://user-images.githubusercontent.com/28568478/116815239-3b63c780-ab8f-11eb-9453-11e40b354c4e.png)\n\n\n## [vue-resource 实现 get, post, jsonp请求](https://github.com/pagekit/vue-resource)\n除了 vue-resource 之外，还可以使用 `axios` 的第三方包实现实现数据的请求\n1. 之前的学习中，如何发起数据请求？\n2. 常见的数据请求类型？  get  post jsonp\n3. 测试的URL请求资源地址：\n + get请求地址： http://vue.studyit.io/api/getlunbo\n + post请求地址：http://vue.studyit.io/api/post\n + jsonp请求地址：http://vue.studyit.io/api/jsonp\n4. JSONP的实现原理\n + 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；\n + 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；\n + 具体实现过程：\n \t- 先在客户端定义一个回调方法，预定义对数据的操作；\n \t- 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口；\n \t- 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行；\n \t- 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；\n + 带大家通过 Node.js ，来手动实现一个JSONP的请求例子；\n ```\n    const http = require('http');\n    // 导入解析 URL 地址的核心模块\n    const urlModule = require('url');\n\n    const server = http.createServer();\n    // 监听 服务器的 request 请求事件，处理每个请求\n    server.on('request', (req, res) => {\n      const url = req.url;\n\n      // 解析客户端请求的URL地址\n      var info = urlModule.parse(url, true);\n\n      // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据\n      if (info.pathname === '/getjsonp') {\n        // 获取客户端指定的回调函数的名称\n        var cbName = info.query.callback;\n        // 手动拼接要返回给客户端的数据对象\n        var data = {\n          name: 'zs',\n          age: 22,\n          gender: '男',\n          hobby: ['吃饭', '睡觉', '运动']\n        }\n        // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法：\n        var result = `${cbName}(${JSON.stringify(data)})`;\n        // 将拼接好的方法的调用，返回给客户端去解析执行\n        res.end(result);\n      } else {\n        res.end('404');\n      }\n    });\n\n    server.listen(3000, () => {\n      console.log('server running at http://127.0.0.1:3000');\n    });\n ```\n5. vue-resource 的配置步骤：\n + 直接在页面中，通过`script`标签，引入 `vue-resource` 的脚本文件；\n + 注意：引用的先后顺序是：先引用 `Vue` 的脚本文件，再引用 `vue-resource` 的脚本文件；\n6. 发送get请求：\n```\ngetInfo() { // get 方式获取数据\n  this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res => {\n    console.log(res.body);\n  })\n}\n```\n7. 发送post请求：\n```\npostInfo() {\n  var url = 'http://127.0.0.1:8899/api/post';\n  // post 方法接收三个参数：\n  // 参数1： 要请求的URL地址\n  // 参数2： 要发送的数据对象\n  // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded\n  this.$http.post(url, { name: 'zs' }, { emulateJSON: true }).then(res => {\n    console.log(res.body);\n  });\n}\n```\n8. 发送JSONP请求获取数据：\n```\njsonpInfo() { // JSONP形式从服务器获取数据\n  var url = 'http://127.0.0.1:8899/api/jsonp';\n  this.$http.jsonp(url).then(res => {\n    console.log(res.body);\n  });\n}\n```\n\n## 配置本地数据库和数据接口API\n1. 先解压安装 `PHPStudy`;\n2. 解压安装 `Navicat` 这个数据库可视化工具，并激活；\n3. 打开 `Navicat` 工具，新建空白数据库，名为 `dtcmsdb4`;\n4. 双击新建的数据库，连接上这个空白数据库，在新建的数据库上`右键` -> `运行SQL文件`，选择并执行 `dtcmsdb4.sql` 这个数据库脚本文件；如果执行不报错，则数据库导入完成；\n5. 进入文件夹 `vuecms3_nodejsapi` 内部，执行 `npm i` 安装所有的依赖项；\n6. 先确保本机安装了 `nodemon`, 没有安装，则运行 `npm i nodemon -g` 进行全局安装，安装完毕后，进入到 `vuecms3_nodejsapi`目录 -> `src`目录 -> 双击运行 `start.bat`\n7. 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 `app.js` 中第 `14行` 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root\n\n## 品牌管理改造\n### 展示品牌列表\n\n### 添加品牌数据\n\n### 删除品牌数据\n\n## [Vue中的动画](https://cn.vuejs.org/v2/guide/transitions.html)\n为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；\n\n### 使用过渡类名\n1. HTML结构：\n```\n<div id=\"app\">\n    <input type=\"button\" value=\"动起来\" @click=\"myAnimate\">\n    <!-- 使用 transition 将需要过渡的元素包裹起来 -->\n    <transition name=\"fade\">\n      <div v-show=\"isshow\">动画哦</div>\n    </transition>\n  </div>\n```\n2. VM 实例：\n```\n// 创建 Vue 实例，得到 ViewModel\nvar vm = new Vue({\n  el: '#app',\n  data: {\n    isshow: false\n  },\n  methods: {\n    myAnimate() {\n      this.isshow = !this.isshow;\n    }\n  }\n});\n```\n3. 定义两组类样式：\n```\n/* 定义进入和离开时候的过渡状态 */\n    .fade-enter-active,\n    .fade-leave-active {\n      transition: all 0.2s ease;\n      position: absolute;\n    }\n\n    /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */\n    .fade-enter,\n    .fade-leave-to {\n      opacity: 0;\n      transform: translateX(100px);\n    }\n```\n\n### [使用第三方 CSS 动画库](https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名)\n1. 导入动画类库：\n```\n<link rel=\"stylesheet\" type=\"text/css\" href=\"./lib/animate.css\">\n```\n2. 定义 transition 及属性：\n```\n<transition\n\tenter-active-class=\"fadeInRight\"\n    leave-active-class=\"fadeOutRight\"\n    :duration=\"{ enter: 500, leave: 800 }\">\n  \t<div class=\"animated\" v-show=\"isshow\">动画哦</div>\n</transition>\n```\n\n### 使用动画钩子函数\n1. 定义 transition 组件以及三个钩子函数：\n```\n<div id=\"app\">\n    <input type=\"button\" value=\"切换动画\" @click=\"isshow = !isshow\">\n    <transition\n    @before-enter=\"beforeEnter\"\n    @enter=\"enter\"\n    @after-enter=\"afterEnter\">\n      <div v-if=\"isshow\" class=\"show\">OK</div>\n    </transition>\n  </div>\n```\n2. 定义三个 methods 钩子方法：\n```\nmethods: {\n        beforeEnter(el) { // 动画进入之前的回调\n          el.style.transform = 'translateX(500px)';\n        },\n        enter(el, done) { // 动画进入完成时候的回调\n          el.offsetWidth;\n          el.style.transform = 'translateX(0px)';\n          done();\n        },\n        afterEnter(el) { // 动画进入完成之后的回调\n          this.isshow = !this.isshow;\n        }\n      }\n```\n3. 定义动画过渡时长和样式：\n```\n.show{\n      transition: all 0.4s ease;\n    }\n```\n\n\n### [v-for 的列表过渡](https://cn.vuejs.org/v2/guide/transitions.html#列表的进入和离开过渡)\n1. 定义过渡样式：\n```\n<style>\n    .list-enter,\n    .list-leave-to {\n      opacity: 0;\n      transform: translateY(10px);\n    }\n\n    .list-enter-active,\n    .list-leave-active {\n      transition: all 0.3s ease;\n    }\n</style>\n```\n2. 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：\n```\n  <div id=\"app\">\n    <input type=\"text\" v-model=\"txt\" @keyup.enter=\"add\">\n\n    <transition-group tag=\"ul\" name=\"list\">\n      <li v-for=\"(item, i) in list\" :key=\"i\">{{item}}</li>\n    </transition-group>\n  </div>\n```\n3. 定义 VM中的结构：\n```\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        txt: '',\n        list: [1, 2, 3, 4]\n      },\n      methods: {\n        add() {\n          this.list.push(this.txt);\n          this.txt = '';\n        }\n      }\n    });\n```\n\n\n### 列表的排序过渡\n`<transition-group>` 组件还有一个特殊之处。不仅可以进入和离开动画，**还可以改变定位**。要使用这个新功能只需了解新增的 `v-move` 特性，**它会在元素的改变定位的过程中应用**。\n+ `v-move` 和 `v-leave-active` 结合使用，能够让列表的过渡更加平缓柔和：\n```\n.v-move{\n  transition: all 0.8s ease;\n}\n.v-leave-active{\n  position: absolute;\n}\n```\n\n\n\n## 相关文章\n1. [vue.js 1.x 文档](https://v1-cn.vuejs.org/)\n2. [vue.js 2.x 文档](https://cn.vuejs.org/)\n3. [String.prototype.padStart(maxLength, fillString)](http://www.css88.com/archives/7715)\n4. [js 里面的键盘事件对应的键码](http://www.cnblogs.com/wuhua1/p/6686237.html)\n5. [pagekit/vue-resource](https://github.com/pagekit/vue-resource)\n6. [navicat如何导入sql文件和导出sql文件](https://jingyan.baidu.com/article/a65957f4976aad24e67f9b9b.html)\n7. [贝塞尔在线生成器](http://cubic-bezier.com/#.4,-0.3,1,.33)\n","tags":["vue","vue2.0基础课程"],"categories":["vue2.0基础课程"]},{"title":"Vue.js - Day1","url":"/2021/05/02/vue/vue2.0基础课程/day1/","content":"\n# Vue.js - Day1\n\n## 课程介绍\n前5天： 都在学习Vue基本的语法和概念；打包工具 Webpack , Gulp\n后5天： 以项目驱动教学；\n\n\n### 什么是Vue.js\n\n+ Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）\n\n+ Vue.js 是前端的**主流框架之一**，和Angular.js、React.js 一起，并成为前端三大主流框架！\n\n+ Vue.js 是一套构建用户界面的框架，**只关注视图层**，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）\n\n+ 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；\n\n\n\n\n\n## 为什么要学习流行框架\n + 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；\n  - 企业中，使用框架，能够提高开发的效率；\n\n\n\n + 提高开发效率的发展历程：原生JS -> Jquery之类的类库 -> 前端模板引擎 -> Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】）\n + 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑；\n\n\n\n + 增强自己就业时候的竞争力\n  - 人无我有，人有我优\n  - 你平时不忙的时候，都在干嘛？\n\n## 框架和库的区别\n\n\n\n + 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。\n\n  - node 中的 express；\n\n\n\n + 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。\n  - 1. 从Jquery 切换到 Zepto\n  - 2. 从 EJS 切换到 art-template\n\n\n\n\n\n\n\n## Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别\n\n + MVC 是后端的分层开发概念；\n + MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel\n\n + 为什么有了MVC还要有MVVM\n\n\n\n## Vue.js 基本代码 和 MVVM 之间的对应关系\n![01 MVC和MVVM的关系图解](https://user-images.githubusercontent.com/28568478/116802575-5b22cd80-ab46-11eb-8f55-8b75473b6d4a.png)\n\n## Vue之 - `基本的代码结构`和`插值表达式`、`v-cloak`\n\n## Vue指令之`v-text`和`v-html`\n\n## Vue指令之`v-bind`的三种用法\n\n1. 直接使用指令`v-bind`\n\n2. 使用简化指令`:`\n\n3. 在绑定的时候，拼接绑定内容：`:title=\"btnTitle + ', 这是追加的内容'\"`\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <!-- <script src=\"./lib/vue.js\"></script> -->\n    <style>\n        /* 默认加入v-cloak的元素 隐藏 */\n        [v-cloak] {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"app\">\n        <!-- 使用v-cloak能够解决插值表达式闪烁的问题 -->\n        <p v-cloak>{{msg}}</p>\n        <!-- 默认v-text是没有闪烁问题的\n            v-text 会覆盖元素中原本的内容，但是插值表达式 只会替换自己的这个占位符 不会吧扎鞥个元素内容清空\n        -->\n        <h4 v-text=\"msg\"></h4>\n\n        <!-- v-html会解析html格式字符串 -->\n        <div>{{msg2}}</div>\n        <div v-text=\"msg2\"></div>\n        <div v-html=\"msg2\"></div>\n\n         <!-- v-bind 是vue中提供用于绑定属性的指令 -->\n         <input type=\"button\" value=\"按钮\" title=\"123\">\n         <input type=\"button\" value=\"按钮\" title=\"mytitle\">\n         <input type=\"button\" value=\"按钮\" v-bind:title=\"mytitle\">\n         <input type=\"button\" value=\"按钮\" v-bind:title=\"mytitle+'123'\">\n         <!-- 简化写 -->\n         <input type=\"button\" value=\"按钮\" :title=\"mytitle+'456'\">\n\n\n         <!-- vue中 提供了v-on 事件绑定机制 -->\n         <!-- 这样写会报错 未定义alert方法 -->\n         <input type=\"button\" value=\"按钮\" :title=\"mytitle+' v-on'\" v-on:click=\"alert('报警')\">\n         <!-- 貌似v-bind:title不生效 -->\n         <input type=\"button\" value=\"按钮\" :title=\"show_title\" v-on:click=\"show\">\n         <input type=\"button\" value=\"按钮\" :title=\"show_title\" v-on:mouseover=\"show\">\n         <!-- v-on缩写 用@代替 v-on:-->\n         <input type=\"button\" value=\"按钮\" :title=\"show_title\" @mouseover=\"show\">\n\n\n    </div>\n\n\n\n    <!-- vue.js放在这里时 如果网速过慢 会导致 {{msg}} 展现在页面\n        需要加v-cloak 设置样式为none 这样在网速慢的时候加载出来不会出现{{msg}}\n        而是当msg数据返回时才会展示信息\n    -->\n    <script src=\"./lib/vue.js\"></script>\n    <script>\n        var vm = new Vue({\n            el: \"#app\",\n            data: {\n                msg:123,\n                msg2:'<h1>哈哈 我是一个大大的H1</h1>',\n                mytitle:\"这是一个自己定义的title\"\n            },\n            methods:{ // 这个methods 属性中国定义了当前vue实例所有可用的方法\n                show: function () {\n                    alert(\"报警\")\n                 }\n            }\n        })\n    </script>\n\n</body>\n</html>\n```\n\n\n## Vue指令之`v-on`和`跑马灯效果`\n\n\n\n### 跑马灯效果\n\n1. HTML结构：\n\n```\n\n<div id=\"app\">\n\n    <p>{{info}}</p>\n\n    <input type=\"button\" value=\"开启\" v-on:click=\"go\">\n\n    <input type=\"button\" value=\"停止\" v-on:click=\"stop\">\n\n  </div>\n\n```\n\n2. Vue实例：\n\n```\n\n\t// 创建 Vue 实例，得到 ViewModel\n\n    var vm = new Vue({\n\n      el: '#app',\n\n      data: {\n\n        info: '猥琐发育，别浪~！',\n\n        intervalId: null\n\n      },\n\n      methods: {\n\n        go() {\n\n          // 如果当前有定时器在运行，则直接return\n\n          if (this.intervalId != null) {\n\n            return;\n\n          }\n\n          // 开始定时器\n\n          this.intervalId = setInterval(() => {\n\n            this.info = this.info.substring(1) + this.info.substring(0, 1);\n\n          }, 500);\n\n        },\n\n        stop() {\n\n          clearInterval(this.intervalId);\n\n        }\n\n      }\n\n    });\n\n```\n\n\n\n\n\n\n\n## Vue指令之`v-on的缩写`和`事件修饰符`\n\n\n\n### 事件修饰符：\n\n+ .stop       阻止冒泡\n\n+ .prevent    阻止默认事件\n\n+ .capture    添加事件侦听器时使用事件捕获模式\n\n+ .self       只当事件在该元素本身（比如不是子元素）触发时触发回调\n\n+ .once       事件只触发一次\n\n\n\n\n\n\n\n## Vue指令之`v-model`和`双向数据绑定`\n\n\n\n\n\n\n\n## 简易计算器案例\n\n1. HTML 代码结构\n\n```\n\n  <div id=\"app\">\n\n    <input type=\"text\" v-model=\"n1\">\n\n    <select v-model=\"opt\">\n\n      <option value=\"0\">+</option>\n\n      <option value=\"1\">-</option>\n\n      <option value=\"2\">*</option>\n\n      <option value=\"3\">÷</option>\n\n    </select>\n\n    <input type=\"text\" v-model=\"n2\">\n\n    <input type=\"button\" value=\"=\" v-on:click=\"getResult\">\n\n    <input type=\"text\" v-model=\"result\">\n\n  </div>\n\n```\n\n2. Vue实例代码：\n\n```\n\n\t// 创建 Vue 实例，得到 ViewModel\n\n    var vm = new Vue({\n\n      el: '#app',\n\n      data: {\n\n        n1: 0,\n\n        n2: 0,\n\n        result: 0,\n\n        opt: '0'\n\n      },\n\n      methods: {\n\n        getResult() {\n\n          switch (this.opt) {\n\n            case '0':\n\n              this.result = parseInt(this.n1) + parseInt(this.n2);\n\n              break;\n\n            case '1':\n\n              this.result = parseInt(this.n1) - parseInt(this.n2);\n\n              break;\n\n            case '2':\n\n              this.result = parseInt(this.n1) * parseInt(this.n2);\n\n              break;\n\n            case '3':\n\n              this.result = parseInt(this.n1) / parseInt(this.n2);\n\n              break;\n\n          }\n\n        }\n\n      }\n\n    });\n\n```\n\n\n\n\n\n\n\n\n\n## 在Vue中使用样式\n\n\n\n### 使用class样式\n\n1. 数组\n```\n<h1 :class=\"['red', 'thin']\">这是一个邪恶的H1</h1>\n```\n\n2. 数组中使用三元表达式\n```\n<h1 :class=\"['red', 'thin', isactive?'active':'']\">这是一个邪恶的H1</h1>\n```\n\n3. 数组中嵌套对象\n```\n<h1 :class=\"['red', 'thin', {'active': isactive}]\">这是一个邪恶的H1</h1>\n```\n\n4. 直接使用对象\n```\n<h1 :class=\"{red:true, italic:true, active:true, thin:true}\">这是一个邪恶的H1</h1>\n```\n\n\n\n### 使用内联样式\n\n1. 直接在元素上通过 `:style` 的形式，书写样式对象\n```\n<h1 :style=\"{color: 'red', 'font-size': '40px'}\">这是一个善良的H1</h1>\n```\n\n2. 将样式对象，定义到 `data` 中，并直接引用到 `:style` 中\n + 在data上定义样式：\n```\ndata: {\n        h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }\n}\n```\n + 在元素中，通过属性绑定的形式，将样式对象应用到元素中：\n```\n<h1 :style=\"h1StyleObj\">这是一个善良的H1</h1>\n```\n\n3. 在 `:style` 中通过数组，引用多个 `data` 上的样式对象\n + 在data上定义样式：\n```\ndata: {\n        h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' },\n        h1StyleObj2: { fontStyle: 'italic' }\n}\n```\n + 在元素中，通过属性绑定的形式，将样式对象应用到元素中：\n```\n<h1 :style=\"[h1StyleObj, h1StyleObj2]\">这是一个善良的H1</h1>\n```\n\n\n\n## Vue指令之`v-for`和`key`属性\n\n1. 迭代数组\n\n```\n<ul>\n  <li v-for=\"(item, i) in list\">索引：{{i}} --- 姓名：{{item.name}} --- 年龄：{{item.age}}</li>\n</ul>\n```\n\n2. 迭代对象中的属性\n\n```\n\n\t<!-- 循环遍历对象身上的属性 -->\n\n    <div v-for=\"(val, key, i) in userInfo\">{{val}} --- {{key}} --- {{i}}</div>\n\n```\n\n3. 迭代数字\n\n```\n\n<p v-for=\"i in 10\">这是第 {{i}} 个P标签</p>\n\n```\n\n\n\n> 2.2.0+ 的版本里，**当在组件中使用** v-for 时，key 现在是必须的。\n\n\n\n当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “**就地复用**” 策略。如果数据项的顺序被改变，Vue将**不是移动 DOM 元素来匹配数据项的顺序**， 而是**简单复用此处每个元素**，并且确保它在特定索引下显示已被渲染过的每个元素。\n\n\n\n为了给 Vue 一个提示，**以便它能跟踪每个节点的身份，从而重用和重新排序现有元素**，你需要为每项提供一个唯一 key 属性。\n\n\n\n\n\n\n\n## Vue指令之`v-if`和`v-show`\n\n\n\n\n\n\n\n> 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。\n\n\n\n\n\n\n\n## 品牌管理案例\n\n\n\n### 添加新品牌\n\n\n\n### 删除品牌\n\n\n\n### 根据条件筛选品牌\n\n1. 1.x 版本中的filterBy指令，在2.x中已经被废除：\n\n[filterBy - 指令](https://v1-cn.vuejs.org/api/#filterBy)\n\n```\n\n<tr v-for=\"item in list | filterBy searchName in 'name'\">\n\n  <td>{{item.id}}</td>\n\n  <td>{{item.name}}</td>\n\n  <td>{{item.ctime}}</td>\n\n  <td>\n\n    <a href=\"#\" @click.prevent=\"del(item.id)\">删除</a>\n\n  </td>\n\n</tr>\n\n```\n\n2. 在2.x版本中[手动实现筛选的方式](https://cn.vuejs.org/v2/guide/list.html#显示过滤-排序结果)：\n\n+ 筛选框绑定到 VM 实例中的 `searchName` 属性：\n\n```\n\n<hr> 输入筛选名称：\n\n<input type=\"text\" v-model=\"searchName\">\n\n```\n\n+ 在使用 `v-for` 指令循环每一行数据的时候，不再直接 `item in list`，而是 `in` 一个 过滤的methods 方法，同时，把过滤条件`searchName`传递进去：\n\n```\n\n<tbody>\n\n      <tr v-for=\"item in search(searchName)\">\n\n        <td>{{item.id}}</td>\n\n        <td>{{item.name}}</td>\n\n        <td>{{item.ctime}}</td>\n\n        <td>\n\n          <a href=\"#\" @click.prevent=\"del(item.id)\">删除</a>\n\n        </td>\n\n      </tr>\n\n    </tbody>\n\n```\n\n+ `search` 过滤方法中，使用 数组的 `filter` 方法进行过滤：\n\n```\n\nsearch(name) {\n\n  return this.list.filter(x => {\n\n    return x.name.indexOf(name) != -1;\n\n  });\n\n}\n\n```\n\n\n\n\n\n\n\n## Vue调试工具`vue-devtools`的安装步骤和使用\n\n[Vue.js devtools - 翻墙安装方式 - 推荐](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN)\n\n\n\n\n\n## 过滤器\n\n概念：Vue.js 允许你自定义过滤器，**可被用作一些常见的文本格式化**。过滤器可以用在两个地方：**mustache 插值和 v-bind 表达式**。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；\n\n### 私有过滤器\n\n1. HTML元素：\n\n```\n\n<td>{{item.ctime | dataFormat('yyyy-mm-dd')}}</td>\n\n```\n\n2. 私有 `filters` 定义方式：\n\n```\n\nfilters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用\n\n    dataFormat(input, pattern = \"\") { // 在参数列表中 通过 pattern=\"\" 来指定形参默认值，防止报错\n\n      var dt = new Date(input);\n\n      // 获取年月日\n\n      var y = dt.getFullYear();\n\n      var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n\n      var d = dt.getDate().toString().padStart(2, '0');\n\n\n\n      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日\n\n      // 否则，就返回  年-月-日 时：分：秒\n\n      if (pattern.toLowerCase() === 'yyyy-mm-dd') {\n\n        return `${y}-${m}-${d}`;\n\n      } else {\n\n        // 获取时分秒\n\n        var hh = dt.getHours().toString().padStart(2, '0');\n\n        var mm = dt.getMinutes().toString().padStart(2, '0');\n\n        var ss = dt.getSeconds().toString().padStart(2, '0');\n\n\n\n        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n\n      }\n\n    }\n\n  }\n\n```\n\n\n\n> 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString='') 或 String.prototype.padEnd(maxLength, fillString='')来填充字符串；\n\n\n\n\n\n### 全局过滤器\n\n```\n\n// 定义一个全局过滤器\n\nVue.filter('dataFormat', function (input, pattern = '') {\n\n  var dt = new Date(input);\n\n  // 获取年月日\n\n  var y = dt.getFullYear();\n\n  var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n\n  var d = dt.getDate().toString().padStart(2, '0');\n\n\n\n  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日\n\n  // 否则，就返回  年-月-日 时：分：秒\n\n  if (pattern.toLowerCase() === 'yyyy-mm-dd') {\n\n    return `${y}-${m}-${d}`;\n\n  } else {\n\n    // 获取时分秒\n\n    var hh = dt.getHours().toString().padStart(2, '0');\n\n    var mm = dt.getMinutes().toString().padStart(2, '0');\n\n    var ss = dt.getSeconds().toString().padStart(2, '0');\n\n\n\n    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n\n  }\n\n});\n\n```\n\n\n\n> 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！\n\n\n\n## 键盘修饰符以及自定义键盘修饰符\n\n### 1.x中自定义键盘修饰符【了解即可】\n\n```\n\nVue.directive('on').keyCodes.f2 = 113;\n\n```\n\n### [2.x中自定义键盘修饰符](https://cn.vuejs.org/v2/guide/events.html#键值修饰符)\n\n1. 通过`Vue.config.keyCodes.名称 = 按键值`来自定义案件修饰符的别名：\n\n```\n\nVue.config.keyCodes.f2 = 113;\n\n```\n\n2. 使用自定义的按键修饰符：\n\n```\n\n<input type=\"text\" v-model=\"name\" @keyup.f2=\"add\">\n\n```\n\n\n\n\n\n## [自定义指令](https://cn.vuejs.org/v2/guide/custom-directive.html)\n\n1. 自定义全局和局部的 自定义指令：\n\n```\n\n    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：\n\n    Vue.directive('focus', {\n\n      inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用\n\n        el.focus();\n\n      }\n\n    });\n\n\n\n    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：\n\n      directives: {\n\n        color: { // 为元素设置指定的字体颜色\n\n          bind(el, binding) {\n\n            el.style.color = binding.value;\n\n          }\n\n        },\n\n        'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数\n\n          el.style.fontWeight = binding2.value;\n\n        }\n\n      }\n\n```\n\n2. 自定义指令的使用方式：\n\n```\n\n<input type=\"text\" v-model=\"searchName\" v-focus v-color=\"'red'\" v-font-weight=\"900\">\n\n```\n\n\n\n## Vue 1.x 中 自定义元素指令【已废弃,了解即可】\n```\nVue.elementDirective('red-color', {\n  bind: function () {\n    this.el.style.color = 'red';\n  }\n});\n```\n使用方式：\n```\n<red-color>1232</red-color>\n```\n\n## 相关文章\n1. [vue.js 1.x 文档](https://v1-cn.vuejs.org/)\n2. [vue.js 2.x 文档](https://cn.vuejs.org/)\n3. [String.prototype.padStart(maxLength, fillString)](http://www.css88.com/archives/7715)\n4. [js 里面的键盘事件对应的键码](http://www.cnblogs.com/wuhua1/p/6686237.html)\n5. [Vue.js双向绑定的实现原理](http://www.cnblogs.com/kidney/p/6052935.html)\n","tags":["vue","vue2.0基础课程"],"categories":["vue2.0基础课程"]}]