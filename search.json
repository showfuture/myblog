[{"title":"Vue.js - Day1","url":"/2021/05/02/vue/vue2.0基础课程/day1/","content":"\n# Vue.js - Day1\n\n## 课程介绍\n前5天： 都在学习Vue基本的语法和概念；打包工具 Webpack , Gulp\n后5天： 以项目驱动教学；\n\n\n### 什么是Vue.js\n\n+ Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）\n\n+ Vue.js 是前端的**主流框架之一**，和Angular.js、React.js 一起，并成为前端三大主流框架！\n\n+ Vue.js 是一套构建用户界面的框架，**只关注视图层**，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）\n\n+ 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；\n\n\n\n\n\n## 为什么要学习流行框架\n + 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；\n  - 企业中，使用框架，能够提高开发的效率；\n\n\n\n + 提高开发效率的发展历程：原生JS -> Jquery之类的类库 -> 前端模板引擎 -> Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】）\n + 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑；\n\n\n\n + 增强自己就业时候的竞争力\n  - 人无我有，人有我优\n  - 你平时不忙的时候，都在干嘛？\n\n## 框架和库的区别\n\n\n\n + 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。\n\n  - node 中的 express；\n\n\n\n + 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。\n  - 1. 从Jquery 切换到 Zepto\n  - 2. 从 EJS 切换到 art-template\n\n\n\n\n\n\n\n## Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别\n\n + MVC 是后端的分层开发概念；\n + MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel\n\n + 为什么有了MVC还要有MVVM\n\n\n\n## Vue.js 基本代码 和 MVVM 之间的对应关系\n![01 MVC和MVVM的关系图解](https://user-images.githubusercontent.com/28568478/116802575-5b22cd80-ab46-11eb-8f55-8b75473b6d4a.png)\n\n## Vue之 - `基本的代码结构`和`插值表达式`、`v-cloak`\n\n## Vue指令之`v-text`和`v-html`\n\n## Vue指令之`v-bind`的三种用法\n\n1. 直接使用指令`v-bind`\n\n2. 使用简化指令`:`\n\n3. 在绑定的时候，拼接绑定内容：`:title=\"btnTitle + ', 这是追加的内容'\"`\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <!-- <script src=\"./lib/vue.js\"></script> -->\n    <style>\n        /* 默认加入v-cloak的元素 隐藏 */\n        [v-cloak] {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"app\">\n        <!-- 使用v-cloak能够解决插值表达式闪烁的问题 -->\n        <p v-cloak>{{msg}}</p>\n        <!-- 默认v-text是没有闪烁问题的\n            v-text 会覆盖元素中原本的内容，但是插值表达式 只会替换自己的这个占位符 不会吧扎鞥个元素内容清空\n        -->\n        <h4 v-text=\"msg\"></h4>\n\n        <!-- v-html会解析html格式字符串 -->\n        <div>{{msg2}}</div>\n        <div v-text=\"msg2\"></div>\n        <div v-html=\"msg2\"></div>\n        \n         <!-- v-bind 是vue中提供用于绑定属性的指令 -->\n         <input type=\"button\" value=\"按钮\" title=\"123\">\n         <input type=\"button\" value=\"按钮\" title=\"mytitle\">\n         <input type=\"button\" value=\"按钮\" v-bind:title=\"mytitle\">\n         <input type=\"button\" value=\"按钮\" v-bind:title=\"mytitle+'123'\">\n         <!-- 简化写 -->\n         <input type=\"button\" value=\"按钮\" :title=\"mytitle+'456'\">\n\n\n         <!-- vue中 提供了v-on 事件绑定机制 -->\n         <!-- 这样写会报错 未定义alert方法 -->\n         <input type=\"button\" value=\"按钮\" :title=\"mytitle+' v-on'\" v-on:click=\"alert('报警')\">\n         <!-- 貌似v-bind:title不生效 -->\n         <input type=\"button\" value=\"按钮\" :title=\"show_title\" v-on:click=\"show\">\n         <input type=\"button\" value=\"按钮\" :title=\"show_title\" v-on:mouseover=\"show\">\n         <!-- v-on缩写 用@代替 v-on:-->\n         <input type=\"button\" value=\"按钮\" :title=\"show_title\" @mouseover=\"show\">\n       \n        \n    </div>\n\n    \n    \n    <!-- vue.js放在这里时 如果网速过慢 会导致 {{msg}} 展现在页面 \n        需要加v-cloak 设置样式为none 这样在网速慢的时候加载出来不会出现{{msg}} \n        而是当msg数据返回时才会展示信息\n    -->\n    <script src=\"./lib/vue.js\"></script>\n    <script>\n        var vm = new Vue({\n            el: \"#app\",\n            data: {\n                msg:123,\n                msg2:'<h1>哈哈 我是一个大大的H1</h1>',\n                mytitle:\"这是一个自己定义的title\"\n            },\n            methods:{ // 这个methods 属性中国定义了当前vue实例所有可用的方法\n                show: function () { \n                    alert(\"报警\")\n                 }\n            }\n        })\n    </script>\n    \n</body>\n</html>\n```\n\n\n## Vue指令之`v-on`和`跑马灯效果`\n\n\n\n### 跑马灯效果\n\n1. HTML结构：\n\n```\n\n<div id=\"app\">\n\n    <p>{{info}}</p>\n\n    <input type=\"button\" value=\"开启\" v-on:click=\"go\">\n\n    <input type=\"button\" value=\"停止\" v-on:click=\"stop\">\n\n  </div>\n\n```\n\n2. Vue实例：\n\n```\n\n\t// 创建 Vue 实例，得到 ViewModel\n\n    var vm = new Vue({\n\n      el: '#app',\n\n      data: {\n\n        info: '猥琐发育，别浪~！',\n\n        intervalId: null\n\n      },\n\n      methods: {\n\n        go() {\n\n          // 如果当前有定时器在运行，则直接return\n\n          if (this.intervalId != null) {\n\n            return;\n\n          }\n\n          // 开始定时器\n\n          this.intervalId = setInterval(() => {\n\n            this.info = this.info.substring(1) + this.info.substring(0, 1);\n\n          }, 500);\n\n        },\n\n        stop() {\n\n          clearInterval(this.intervalId);\n\n        }\n\n      }\n\n    });\n\n```\n\n\n\n\n\n\n\n## Vue指令之`v-on的缩写`和`事件修饰符`\n\n\n\n### 事件修饰符：\n\n+ .stop       阻止冒泡\n\n+ .prevent    阻止默认事件\n\n+ .capture    添加事件侦听器时使用事件捕获模式\n\n+ .self       只当事件在该元素本身（比如不是子元素）触发时触发回调\n\n+ .once       事件只触发一次\n\n\n\n\n\n\n\n## Vue指令之`v-model`和`双向数据绑定`\n\n\n\n\n\n\n\n## 简易计算器案例\n\n1. HTML 代码结构\n\n```\n\n  <div id=\"app\">\n\n    <input type=\"text\" v-model=\"n1\">\n\n    <select v-model=\"opt\">\n\n      <option value=\"0\">+</option>\n\n      <option value=\"1\">-</option>\n\n      <option value=\"2\">*</option>\n\n      <option value=\"3\">÷</option>\n\n    </select>\n\n    <input type=\"text\" v-model=\"n2\">\n\n    <input type=\"button\" value=\"=\" v-on:click=\"getResult\">\n\n    <input type=\"text\" v-model=\"result\">\n\n  </div>\n\n```\n\n2. Vue实例代码：\n\n```\n\n\t// 创建 Vue 实例，得到 ViewModel\n\n    var vm = new Vue({\n\n      el: '#app',\n\n      data: {\n\n        n1: 0,\n\n        n2: 0,\n\n        result: 0,\n\n        opt: '0'\n\n      },\n\n      methods: {\n\n        getResult() {\n\n          switch (this.opt) {\n\n            case '0':\n\n              this.result = parseInt(this.n1) + parseInt(this.n2);\n\n              break;\n\n            case '1':\n\n              this.result = parseInt(this.n1) - parseInt(this.n2);\n\n              break;\n\n            case '2':\n\n              this.result = parseInt(this.n1) * parseInt(this.n2);\n\n              break;\n\n            case '3':\n\n              this.result = parseInt(this.n1) / parseInt(this.n2);\n\n              break;\n\n          }\n\n        }\n\n      }\n\n    });\n\n```\n\n\n\n\n\n\n\n\n\n## 在Vue中使用样式\n\n\n\n### 使用class样式\n\n1. 数组\n```\n<h1 :class=\"['red', 'thin']\">这是一个邪恶的H1</h1>\n```\n\n2. 数组中使用三元表达式\n```\n<h1 :class=\"['red', 'thin', isactive?'active':'']\">这是一个邪恶的H1</h1>\n```\n\n3. 数组中嵌套对象\n```\n<h1 :class=\"['red', 'thin', {'active': isactive}]\">这是一个邪恶的H1</h1>\n```\n\n4. 直接使用对象\n```\n<h1 :class=\"{red:true, italic:true, active:true, thin:true}\">这是一个邪恶的H1</h1>\n```\n\n\n\n### 使用内联样式\n\n1. 直接在元素上通过 `:style` 的形式，书写样式对象\n```\n<h1 :style=\"{color: 'red', 'font-size': '40px'}\">这是一个善良的H1</h1>\n```\n\n2. 将样式对象，定义到 `data` 中，并直接引用到 `:style` 中\n + 在data上定义样式：\n```\ndata: {\n        h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }\n}\n```\n + 在元素中，通过属性绑定的形式，将样式对象应用到元素中：\n```\n<h1 :style=\"h1StyleObj\">这是一个善良的H1</h1>\n```\n\n3. 在 `:style` 中通过数组，引用多个 `data` 上的样式对象\n + 在data上定义样式：\n```\ndata: {\n        h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' },\n        h1StyleObj2: { fontStyle: 'italic' }\n}\n```\n + 在元素中，通过属性绑定的形式，将样式对象应用到元素中：\n```\n<h1 :style=\"[h1StyleObj, h1StyleObj2]\">这是一个善良的H1</h1>\n```\n\n\n\n## Vue指令之`v-for`和`key`属性\n\n1. 迭代数组\n\n```\n<ul>\n  <li v-for=\"(item, i) in list\">索引：{{i}} --- 姓名：{{item.name}} --- 年龄：{{item.age}}</li>\n</ul>\n```\n\n2. 迭代对象中的属性\n\n```\n\n\t<!-- 循环遍历对象身上的属性 -->\n\n    <div v-for=\"(val, key, i) in userInfo\">{{val}} --- {{key}} --- {{i}}</div>\n\n```\n\n3. 迭代数字\n\n```\n\n<p v-for=\"i in 10\">这是第 {{i}} 个P标签</p>\n\n```\n\n\n\n> 2.2.0+ 的版本里，**当在组件中使用** v-for 时，key 现在是必须的。\n\n\n\n当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “**就地复用**” 策略。如果数据项的顺序被改变，Vue将**不是移动 DOM 元素来匹配数据项的顺序**， 而是**简单复用此处每个元素**，并且确保它在特定索引下显示已被渲染过的每个元素。\n\n\n\n为了给 Vue 一个提示，**以便它能跟踪每个节点的身份，从而重用和重新排序现有元素**，你需要为每项提供一个唯一 key 属性。\n\n\n\n\n\n\n\n## Vue指令之`v-if`和`v-show`\n\n\n\n\n\n\n\n> 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。\n\n\n\n\n\n\n\n## 品牌管理案例\n\n\n\n### 添加新品牌\n\n\n\n### 删除品牌\n\n\n\n### 根据条件筛选品牌\n\n1. 1.x 版本中的filterBy指令，在2.x中已经被废除：\n\n[filterBy - 指令](https://v1-cn.vuejs.org/api/#filterBy)\n\n```\n\n<tr v-for=\"item in list | filterBy searchName in 'name'\">\n\n  <td>{{item.id}}</td>\n\n  <td>{{item.name}}</td>\n\n  <td>{{item.ctime}}</td>\n\n  <td>\n\n    <a href=\"#\" @click.prevent=\"del(item.id)\">删除</a>\n\n  </td>\n\n</tr>\n\n```\n\n2. 在2.x版本中[手动实现筛选的方式](https://cn.vuejs.org/v2/guide/list.html#显示过滤-排序结果)：\n\n+ 筛选框绑定到 VM 实例中的 `searchName` 属性：\n\n```\n\n<hr> 输入筛选名称：\n\n<input type=\"text\" v-model=\"searchName\">\n\n```\n\n+ 在使用 `v-for` 指令循环每一行数据的时候，不再直接 `item in list`，而是 `in` 一个 过滤的methods 方法，同时，把过滤条件`searchName`传递进去：\n\n```\n\n<tbody>\n\n      <tr v-for=\"item in search(searchName)\">\n\n        <td>{{item.id}}</td>\n\n        <td>{{item.name}}</td>\n\n        <td>{{item.ctime}}</td>\n\n        <td>\n\n          <a href=\"#\" @click.prevent=\"del(item.id)\">删除</a>\n\n        </td>\n\n      </tr>\n\n    </tbody>\n\n```\n\n+ `search` 过滤方法中，使用 数组的 `filter` 方法进行过滤：\n\n```\n\nsearch(name) {\n\n  return this.list.filter(x => {\n\n    return x.name.indexOf(name) != -1;\n\n  });\n\n}\n\n```\n\n\n\n\n\n\n\n## Vue调试工具`vue-devtools`的安装步骤和使用\n\n[Vue.js devtools - 翻墙安装方式 - 推荐](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN)\n\n\n\n\n\n## 过滤器\n\n概念：Vue.js 允许你自定义过滤器，**可被用作一些常见的文本格式化**。过滤器可以用在两个地方：**mustache 插值和 v-bind 表达式**。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；\n\n### 私有过滤器\n\n1. HTML元素：\n\n```\n\n<td>{{item.ctime | dataFormat('yyyy-mm-dd')}}</td>\n\n```\n\n2. 私有 `filters` 定义方式：\n\n```\n\nfilters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用\n\n    dataFormat(input, pattern = \"\") { // 在参数列表中 通过 pattern=\"\" 来指定形参默认值，防止报错\n\n      var dt = new Date(input);\n\n      // 获取年月日\n\n      var y = dt.getFullYear();\n\n      var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n\n      var d = dt.getDate().toString().padStart(2, '0');\n\n\n\n      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日\n\n      // 否则，就返回  年-月-日 时：分：秒\n\n      if (pattern.toLowerCase() === 'yyyy-mm-dd') {\n\n        return `${y}-${m}-${d}`;\n\n      } else {\n\n        // 获取时分秒\n\n        var hh = dt.getHours().toString().padStart(2, '0');\n\n        var mm = dt.getMinutes().toString().padStart(2, '0');\n\n        var ss = dt.getSeconds().toString().padStart(2, '0');\n\n\n\n        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n\n      }\n\n    }\n\n  }\n\n```\n\n\n\n> 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString='') 或 String.prototype.padEnd(maxLength, fillString='')来填充字符串；\n\n\n\n\n\n### 全局过滤器\n\n```\n\n// 定义一个全局过滤器\n\nVue.filter('dataFormat', function (input, pattern = '') {\n\n  var dt = new Date(input);\n\n  // 获取年月日\n\n  var y = dt.getFullYear();\n\n  var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n\n  var d = dt.getDate().toString().padStart(2, '0');\n\n\n\n  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日\n\n  // 否则，就返回  年-月-日 时：分：秒\n\n  if (pattern.toLowerCase() === 'yyyy-mm-dd') {\n\n    return `${y}-${m}-${d}`;\n\n  } else {\n\n    // 获取时分秒\n\n    var hh = dt.getHours().toString().padStart(2, '0');\n\n    var mm = dt.getMinutes().toString().padStart(2, '0');\n\n    var ss = dt.getSeconds().toString().padStart(2, '0');\n\n\n\n    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n\n  }\n\n});\n\n```\n\n\n\n> 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！\n\n\n\n## 键盘修饰符以及自定义键盘修饰符\n\n### 1.x中自定义键盘修饰符【了解即可】\n\n```\n\nVue.directive('on').keyCodes.f2 = 113;\n\n```\n\n### [2.x中自定义键盘修饰符](https://cn.vuejs.org/v2/guide/events.html#键值修饰符)\n\n1. 通过`Vue.config.keyCodes.名称 = 按键值`来自定义案件修饰符的别名：\n\n```\n\nVue.config.keyCodes.f2 = 113;\n\n```\n\n2. 使用自定义的按键修饰符：\n\n```\n\n<input type=\"text\" v-model=\"name\" @keyup.f2=\"add\">\n\n```\n\n\n\n\n\n## [自定义指令](https://cn.vuejs.org/v2/guide/custom-directive.html)\n\n1. 自定义全局和局部的 自定义指令：\n\n```\n\n    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：\n\n    Vue.directive('focus', {\n\n      inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用\n\n        el.focus();\n\n      }\n\n    });\n\n\n\n    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：\n\n      directives: {\n\n        color: { // 为元素设置指定的字体颜色\n\n          bind(el, binding) {\n\n            el.style.color = binding.value;\n\n          }\n\n        },\n\n        'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数\n\n          el.style.fontWeight = binding2.value;\n\n        }\n\n      }\n\n```\n\n2. 自定义指令的使用方式：\n\n```\n\n<input type=\"text\" v-model=\"searchName\" v-focus v-color=\"'red'\" v-font-weight=\"900\">\n\n```\n\n\n\n## Vue 1.x 中 自定义元素指令【已废弃,了解即可】\n```\nVue.elementDirective('red-color', {\n  bind: function () {\n    this.el.style.color = 'red';\n  }\n});\n```\n使用方式：\n```\n<red-color>1232</red-color>\n```\n\n## 相关文章\n1. [vue.js 1.x 文档](https://v1-cn.vuejs.org/)\n2. [vue.js 2.x 文档](https://cn.vuejs.org/)\n3. [String.prototype.padStart(maxLength, fillString)](http://www.css88.com/archives/7715)\n4. [js 里面的键盘事件对应的键码](http://www.cnblogs.com/wuhua1/p/6686237.html)\n5. [Vue.js双向绑定的实现原理](http://www.cnblogs.com/kidney/p/6052935.html)","tags":["vue","vue2.0基础课程"],"categories":["vue2.0基础课程"]},{"title":"test_my_site","url":"/2021/04/25/test-my-site/","content":"\n#### test","tags":["test"]},{"title":"Hello World","url":"/2021/04/25/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["测试"]}]