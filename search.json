[{"title":"Vue.js - Day5","url":"/2021/05/04/vue/vue2.0基础课程/day5/","content":"\n# Vue.js - Day5 - Webpack\n\n## 在网页中会引用哪些常见的静态资源？\n+ JS\n - .js  .jsx  .coffee  .ts（TypeScript  类 C# 语言）\n+ CSS\n - .css  .less   .sass  .scss\n+ Images\n - .jpg   .png   .gif   .bmp   .svg\n+ 字体文件（Fonts）\n - .svg   .ttf   .eot   .woff   .woff2\n+ 模板文件\n - .ejs   .jade  .vue【这是在webpack中定义组件的方式，推荐这么用】\n\n\n## 网页中引入的静态资源多了以后有什么问题？？？\n1. 网页加载速度慢， 因为 我们要发起很多的二次请求；\n2. 要处理错综复杂的依赖关系\n\n\n## 如何解决上述两个问题\n1. 合并、压缩、精灵图、图片的Base64编码\n2. 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系；\n\n## 什么是webpack?\nwebpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；\n\n\n## 如何完美实现上述的2种解决方案\n1. 使用Gulp， 是基于 task 任务的；\n2. 使用Webpack， 是基于整个项目进行构建的；\n+ 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。\n+ 根据官网的图片介绍webpack打包的过程\n+ [webpack官网](http://webpack.github.io/)\n\n## webpack安装的两种方式\n1. 运行`npm i webpack -g`全局安装webpack，这样就能在全局使用webpack的命令\n2. 在项目根目录中运行`npm i webpack --save-dev`安装到项目依赖中\n\n## 初步使用webpack打包构建列表隔行变色案例\n1. 运行`npm init`初始化项目，使用npm管理项目中的依赖包\n2. 创建项目基本的目录结构\n3. 使用`cnpm i jquery --save`安装jquery类库\n4. 创建`main.js`并书写各行变色的代码逻辑：\n```\n\t// 导入jquery类库\n    import $ from 'jquery'\n\n    // 设置偶数行背景色，索引从0开始，0是偶数\n    $('#list li:even').css('backgroundColor','lightblue');\n    // 设置奇数行背景色\n    $('#list li:odd').css('backgroundColor','pink');\n```\n5. 直接在页面上引用`main.js`会报错，因为浏览器不认识`import`这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；\n6. 运行`webpack 入口文件路径 输出文件路径`对`main.js`进行处理：\n```\nwebpack src/js/main.js dist/bundle.js\n```\n\n## 使用webpack的配置文件简化打包时候的命令\n1. 在项目根目录中创建`webpack.config.js`\n2. 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在`webpack.config.js`中配置这两个路径：\n```\n    // 导入处理路径的模块\n    var path = require('path');\n\n    // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理\n    module.exports = {\n        entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件\n        output: { // 配置输出选项\n            path: path.resolve(__dirname, 'dist'), // 配置输出的路径\n            filename: 'bundle.js' // 配置输出的文件名\n        }\n    }\n```\n\n## 实现webpack的实时打包构建\n1. 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用`webpack-dev-server`来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。\n2. 运行`cnpm i webpack-dev-server --save-dev`安装到开发依赖\n3. 安装完成之后，在命令行直接运行`webpack-dev-server`来进行打包，发现报错，此时需要借助于`package.json`文件中的指令，来进行运行`webpack-dev-server`命令，在`scripts`节点下新增`\"dev\": \"webpack-dev-server\"`指令，发现可以进行实时打包，但是dist目录下并没有生成`bundle.js`文件，这是因为`webpack-dev-server`将打包好的文件放在了内存中\n + 把`bundle.js`放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快\n + 这个时候访问webpack-dev-server启动的`http://localhost:8080/`网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:`<script src=\"../bundle.js\"></script>`\n + 为了能在访问`http://localhost:8080/`的时候直接访问到index首页，可以使用`--contentBase src`指令来修改dev指令，指定启动的根目录：\n ```\n \"dev\": \"webpack-dev-server --contentBase src\"\n ```\n 同时修改index页面中script的src属性为`<script src=\"bundle.js\"></script>`\n\n## 使用`html-webpack-plugin`插件配置启动页面\n由于使用`--contentBase`指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用`html-webpack-plugin`插件配置启动页面.\n1. 运行`cnpm i html-webpack-plugin --save-dev`安装到开发依赖\n2. 修改`webpack.config.js`配置文件如下：\n```\n    // 导入处理路径的模块\n    var path = require('path');\n    // 导入自动生成HTMl文件的插件\n    var htmlWebpackPlugin = require('html-webpack-plugin');\n\n    module.exports = {\n        entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件\n        output: { // 配置输出选项\n            path: path.resolve(__dirname, 'dist'), // 配置输出的路径\n            filename: 'bundle.js' // 配置输出的文件名\n        },\n        plugins:[ // 添加plugins节点配置插件\n            new htmlWebpackPlugin({\n                template:path.resolve(__dirname, 'src/index.html'),//模板路径\n                filename:'index.html'//自动生成的HTML文件的名称\n            })\n        ]\n    }\n```\n3. 修改`package.json`中`script`节点中的dev指令如下：\n```\n\"dev\": \"webpack-dev-server\"\n```\n4. 将index.html中script标签注释掉，因为`html-webpack-plugin`插件会自动把bundle.js注入到index.html页面中！\n\n## 实现自动打开浏览器、热更新和配置浏览器的默认端口号\n**注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！**\n### 方式1：\n+ 修改`package.json`的script节点如下，其中`--open`表示自动打开浏览器，`--port 4321`表示打开的端口号为4321，`--hot`表示启用浏览器热更新：\n```\n\"dev\": \"webpack-dev-server --hot --port 4321 --open\"\n```\n\n### 方式2：\n1. 修改`webpack.config.js`文件，新增`devServer`节点如下：\n```\ndevServer:{\n        hot:true,\n        open:true,\n        port:4321\n    }\n```\n2. 在头部引入`webpack`模块：\n```\nvar webpack = require('webpack');\n```\n3. 在`plugins`节点下新增：\n```\nnew webpack.HotModuleReplacementPlugin()\n```\n\n## 使用webpack打包css文件\n1. 运行`cnpm i style-loader css-loader --save-dev`\n2. 修改`webpack.config.js`这个配置文件：\n```\nmodule: { // 用来配置第三方loader模块的\n        rules: [ // 文件的匹配规则\n            { test: /\\.css$/, use: ['style-loader', 'css-loader'] }//处理css文件的规则\n        ]\n    }\n```\n3. 注意：`use`表示使用哪些模块来处理`test`所匹配到的文件；`use`中相关loader模块的调用顺序是从后向前调用的；\n\n## 使用webpack打包less文件\n1. 运行`cnpm i less-loader less -D`\n2. 修改`webpack.config.js`这个配置文件：\n```\n{ test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] },\n```\n\n## 使用webpack打包sass文件\n1. 运行`cnpm i sass-loader node-sass --save-dev`\n2. 在`webpack.config.js`中添加处理sass文件的loader模块：\n```\n{ test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] }\n```\n\n## 使用webpack处理css中的路径\n1. 运行`cnpm i url-loader file-loader --save-dev`\n2. 在`webpack.config.js`中添加处理url路径的loader模块：\n```\n{ test: /\\.(png|jpg|gif)$/, use: 'url-loader' }\n```\n3. 可以通过`limit`指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：\n```\n{ test: /\\.(png|jpg|gif)$/, use: 'url-loader?limit=43960' },\n```\n\n## 使用babel处理高级JS语法\n1. 运行`cnpm i babel-core babel-loader babel-plugin-transform-runtime --save-dev`安装babel的相关loader包\n2. 运行`cnpm i babel-preset-es2015 babel-preset-stage-0 --save-dev`安装babel转换的语法\n3. 在`webpack.config.js`中添加相关loader模块，其中需要注意的是，一定要把`node_modules`文件夹添加到排除项：\n```\n{ test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ }\n```\n4. 在项目根目录中添加`.babelrc`文件，并修改这个配置文件如下：\n```\n{\n    \"presets\":[\"es2015\", \"stage-0\"],\n    \"plugins\":[\"transform-runtime\"]\n}\n```\n5. **注意：语法插件`babel-preset-es2015`可以更新为`babel-preset-env`，它包含了所有的ES相关的语法；**\n\n## 相关文章\n[babel-preset-env：你需要的唯一Babel插件](https://segmentfault.com/p/1210000008466178)\n[Runtime transform 运行时编译es6](https://segmentfault.com/a/1190000009065987)\n","tags":["vue2.0基础课程","Webpack"],"categories":["vue2.0基础课程"]},{"title":"安装Python","url":"/2021/05/04/python/安装Python/","content":"\n### [How to Install Python](https://linuxize.com/post/how-to-install-python-3-7-on-ubuntu-18-04/)\n```\napt-get install zlib1g-dev libbz2-dev libssl-dev libncurses5-dev  libsqlite3-dev libreadline-dev tk-dev libgdbm-dev libdb-dev libpcap-dev xz-utils libexpat1-dev   liblzma-dev libffi-dev  libc6-dev\n\n1. 下载源码包\n     wget   https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz\n2. mkdir -p /usr/local/python3\n3. mv Python-3.7.3.tgz /usr/local/python3\n4. tar -zxf Python-3.7.3.tgz\n5. cd python3.7.3\n6. ./configure --prefix=/usr/local/python3 --with-ssl  --enable-optimizations\n7. make\n8. make install\n```\n\n```\nln -s /usr/local/python3/bin/python3 /usr/bin/python3 [#确认是否是需要的版本]\nln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip3\n\n安装pip3 apt-get install python3-pip\n```\n\n### mac 安装python\n```\nbrew install python\nbrew install python@3.9 # 安装指定版本\n```\n","categories":["python"]},{"title":"python 列表加法\"+\"和\"extend\"的区别","url":"/2021/05/04/python/python 列表加法\"+\"和\"extend\"的区别/","content":"\n### 相同点:　　\n -  \"+\"和\"extend\"都能将两个列表成员拼接到到一起\n\n\n\n### 不同点:　　\n -  \\+ : 生成的是一个新列表(id改变)\n\n - extend : 是将一个列表的成员一个个取出添加到原列表中 , 改变的是原列表的值 , id不变\n\n<!--more-->\n\n![image](https://user-images.githubusercontent.com/28568478/117003180-21ed8780-ad17-11eb-97fc-fedcf041db5d.png)\n\n","tags":["list"],"categories":["python"]},{"title":"浅析深拷贝浅拷贝","url":"/2021/05/04/python/浅析深拷贝浅拷贝/","content":"\n本文主要介绍python中的深拷贝和浅拷贝究竟从底层ID来看是怎么回事\n\n<!--more-->\n![](https://user-images.githubusercontent.com/28568478/117002717-80663600-ad16-11eb-9151-ccd5e05a538b.png)\n\n\n![image](https://user-images.githubusercontent.com/28568478/117002786-94119c80-ad16-11eb-9c19-dd44d0494db8.png)\n![image](https://user-images.githubusercontent.com/28568478/117002798-996ee700-ad16-11eb-9a72-4cbcdd780596.png)\n![image](https://user-images.githubusercontent.com/28568478/117002811-9e339b00-ad16-11eb-9c55-2555f7bfc671.png)\n![image](https://user-images.githubusercontent.com/28568478/117002821-a2f84f00-ad16-11eb-8d56-7d4aa3dde512.png)\n![image](https://user-images.githubusercontent.com/28568478/117002835-a7246c80-ad16-11eb-8ce6-85764cfff7fe.png)\n![image](https://user-images.githubusercontent.com/28568478/117002847-abe92080-ad16-11eb-95f5-a8381a3042f4.png)\n\n","tags":["python 深拷贝浅拷贝"],"categories":["python"]},{"title":"Python中字典的键为什么要是不可变类型","url":"/2021/05/04/python/Python中字典的键为什么要是不可变类型/","content":"\n\n很多python初学者经常会有这样的疑问，为什么Python有tuple（元组）和list（列表）两种类型？为什么tuple可以作为字典的key，list不可以？要理解这个问题，首先要明白python的字典工作原理。\n\n<!--more-->\n\nPython的字典是如何工作的\n\n在Python中，字典也就是一个个的“映射”，将key映射到value：\n\n对一个特定的key可以得到一个value value = d[key]\n\n为了实现这个功能，Python必须能够做到，给出一个key，找到哪一个value与这个key对应。先来考虑一种比较简单的实现，将所有的key-value键值对存放到一个list中，每当需要的时候，就去遍历这个list，用key去和键值对的key匹配，如果相等，就拿到value。但是这种实现在数据量很大的时候就变得很低效。它的算法复杂度是O(n)，n是存放键值对的数量。\n\n为此，Python使用了hash（哈希）的方法来实现，要求每一个存放到字典中的对象都要实现hash函数，这个函数可以产生一个int值，叫做hash value（哈希值），通过这个int值，就可以快速确定对象在字典中的位置。\n\n这个查询的大致过程如下：\n\ndef lookup(d, key): '''字典的查询过程概括为下面3步: 1. 通过hash函数将key计算为哈希值. 2. 通过hash值确定一个位置，这个位置是一个存放着 可能存在冲突的元素的数组（很多地方叫做“桶”，bucket）， 每一个元素都是一个键值对，理想情况下，这个数组里只有1个元素. 3. 遍历这个数组，找到目标key，返回对应的value. ''' h = hash(key)# step 1 cl = d.data[h]# step 2 for pairin cl:# step 3 if key == pair[0]: return pair[1] else: raise KeyError, \"Key %s not found.\" % key\n\n要使这个查找过程正常工作，hash函数必须满足条件： 如果两个key产生了不同的hash value，那么这两个key对象是不想等的。 即\n\nfor alli1, i2, if hash(i1) != hash(i2), then i1 != i2\n\n否则的话，hash value不同，对象却相同，那么相同的对象产生不同的hash value，查找的时候就会进错桶（step 2），在错误的桶里永远也找不到你要找的value。\n\n另外，要让字典保持高查找效率，还要保证： 当两个key产生相同的hash value，那么他们是相等的。\n\nfor alli1, i2, if hash(i1) == hash(i2), then i1 == i2\n\n这样做的目的是，尽量满足每个hash桶只有一个元素。为什么要这样呢？ 考虑下面这个hash函数。\n\ndef hash(obj): return 1\n\n这个hash函数是满足上面我们谈的第一个条件的：如果两个key的hash value不同，那么两个key对象不相同。因为所有的对象产生的hash value都是1，所以不存在能产生不同hash value的key，也就不存在不满足的情况。但是这样做的坏处是，因为所有的hash value都相同，所以就把所有的对象分到了同一个地方。查找的时候，进行到第三步，遍历的效率就变成了O(n).\n\nHash函数应该保证所有的元素平均的分配到每一个桶中，理想的情况是，每一个位置只有一个元素。\n\n字典Key要满足的要求\n\n经过上面的讨论，我们应该明白Python为什么对字典的key有这样的要求了：\n\n要作为字典的key，对象必须要支持hash函数（即__hash__），相等比较(__eq__或__cmp__），并且满足上面我们讨论过的条件。\n\nList为什么不能作为key\n\n至于这个问题，最直接的答案就是：list没有支持__hash__方法，那么为什么呢？\n\n对于list的hash函数，我们可能有下面两种实现的方式：\n\n第一种，基于id。这满足条件，“如果hash值不同，那么他们的id当然不同”。但考虑到list一般是作为容器，基于id来hash可能会导致下面两种情况：\n\n用相同的list作为key去字典中找某个元素可能会得到不同的结果，因为是基于id hash的，所以即使他们的内容相同，字典依然将他们作为不同的元素对待。 创建一个一模一样的list用字典查找永远会得到一个KeyError。\n\n第二种，基于内容。tuple就是这样做的，但是要注意一点，list是可以修改的。当list修改之后，你就永远别想再从字典中拿回来了。见下面的代码。\n```\n>>> l = [1, 2]\n>>> d = {}\n>>> d[l] = 42\n>>> l.append(3)\n>>> d[l]\n# 原来的hash值是基于[1, 2]hash的，\n# 现在是基于[1, 2, 3]，所以找不到 Traceback (mostrecentcalllast): File \"\", line 1, in ? KeyError: [1, 2, 3]\n>>> d[[1, 2]] # 基于hash [1, 2]\n# 但是遍历的时候找不到key相等的键值对\n#（因为字典里的key变成了[1, 2, 3] Traceback (mostrecentcalllast): File \"\", line 1, in ? KeyError: [1, 2]\n```\n鉴于两种实现的方式都存在一定的副作用，所以Python规定：\n\n内置的list不能作为字典的key.\n\n但tuple是不可变，所以tuple可以作为字典的key。\n\n自定义的类型作为字典的Key\n\n用户自定义的类型就可以作为key了，默认的 hash(object) 是 id(object) , 默认的 cmp(object1,object2) 是 cmp(id(object1),id(object2))， 同样是可以修改的对象，为什么这里就没有上面说的问题呢？\n\n一般来说，在映射中比较常见的需求是用一个object替换掉原来的，所以id比内容更重要，就可以基于id来hash 如果内容重要的话，自定义的类型可以通过覆盖__hash__函数和__cmp__函数或__eq__函数来实现\n\n值得注意的是：将对象和一个value关联起来，更好的做法是将value设置为对象的一个属性。\n","tags":["不可变类型","字典"],"categories":["python"]},{"title":"python 生成器和迭代器","url":"/2021/05/04/python/python 生成器和迭代器/","content":"\n本节主要记录一下列表生成式，生成器和迭代器的知识点\n\n### **列表生成器**\n\n**首先举个例子**\n\n现在有个需求，看列表 [0，1，2，3，4，5，6，7，8，9]，要求你把列表里面的每个值加1，你怎么实现呢？\n\n方法一（简单）：\n```\ninfo = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nb = []\n# for index,i in enumerate(info):\n#     print(i+1)\n#     b.append(i+1)\n# print(b)\nfor index,i in enumerate(info):\n    info[index] +=1\nprint(info)\n```\n<!--more-->\n\n方法二（一般）：\n\n```\ninfo = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\na = map(lambda x:x+1,info)\nprint(a)\nfor i in a:\n    print(i)\n```\n\n方法三（高级）：\n```\ninfo = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\na = [i+1 for i in range(10)]\nprint(a)\n```\n### 　　生成器\n\n#### 什么是生成器？\n\n　　通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。\n\n　　所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，**在Python中，这种一边循环一边计算的机制，称为生成器：generator**\n\n　　生成器是一个特殊的程序，可以被用作控制循环的迭代行为，**python中生成器是迭代器的一种**，使用yield返回值函数，每次调用yield会暂停，而可以使用next()函数和send()函数恢复生成器。\n\n　　生成器类似于返回值为数组的一个函数，这个函数可以接受参数，可以被调用，但是，不同于一般的函数会一次性返回包括了所有数值的数组，生成器一次只能产生一个值，这样消耗的内存数量将大大减小，而且允许调用函数可以很快的处理前几个返回值，因此生成器看起来像是一个函数，但是表现得却像是迭代器\n\n#### python中的生成器\n\n　　要创建一个generator，有很多种方法，第一种方法很简单，**只有把一个列表生成式的[]中括号改为（）小括号，就创建一个generator**\n\n举例如下：\n```\n#列表生成式\nlis = [x*x for x in range(10)]\nprint(lis)\n#生成器\ngenerator_ex = (x*x for x in range(10))\nprint(generator_ex)\n\n结果：\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n<generator object <genexpr> at 0x000002A4CBF9EBA0>\n```\n　　那么创建list和generator_ex，的区别是什么呢？从表面看就是[  ]和（）,但是结果却不一样，一个打印出来是列表（因为是列表生成式），而第二个打印出来却是<generator object <genexpr> at 0x000002A4CBF9EBA0>，那么如何打印出来generator_ex的每一个元素呢？\n\n　　如果要一个个打印出来，可以通过next（）函数获得generator的下一个返回值：\n```\n#生成器\ngenerator_ex = (x*x for x in range(10))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\nprint(next(generator_ex))\n结果：\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\nTraceback (most recent call last):\n\n  File \"列表生成式.py\", line 42, in <module>\n\n    print(next(generator_ex))\n\nStopIteration\n```\n　　大家可以看到，generator保存的是算法，每次调用next(generaotr_ex)就计算出他的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出StopIteration的错误，而且上面这样不断调用是一个不好的习惯，正确的方法是使用for循环，因为generator也是可迭代对象：\n```\n#生成器\ngenerator_ex = (x*x for x in range(10))\nfor i in generator_ex:\n    print(i)\n\n结果：\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\n```\n　　所以我们创建一个generator后，基本上永远不会调用next()，而是通过for循环来迭代，并且不需要关心StopIteration的错误，generator非常强大，如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。\n\n比如著名的斐波那契数列，除第一个和第二个数外，任何一个数都可以由前两个相加得到：\n\n1，1，2，3，5，8，12，21，34.....\n\n斐波那契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：\n\n```\n#fibonacci数列\ndef fib(max):\n    n,a,b =0,0,1\n    while n < max:\n        a,b =b,a+b\n        n = n+1\n        print(a)\n    return 'done'\n\na = fib(10)\nprint(fib(10))\n```\n\n　　a,b = b ,a+b  其实相当于 t =a+b ,a =b ,b =t  ，所以不必写显示写出临时变量t，就可以输出斐波那契数列的前N个数字。上面输出的结果如下：\n\n```\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\ndone\n```\n　　仔细观察，可以看出，`fib`函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。\n\n　　也就是说上面的函数也可以用generator来实现，上面我们发现，print(b)每次函数运行都要打印，占内存，所以为了不占内存，我们也可以使用生成器，这里叫yield。如下：\n```\ndef fib(max):\n    n,a,b =0,0,1\n    while n < max:\n        yield b\n        a,b =b,a+b\n        n = n+1\n    return 'done'\n\na = fib(10)\nprint(fib(10))\n```\n　　但是返回的不再是一个值，而是一个生成器，和上面的例子一样，大家可以看一下结果：\n\n```\n<generator object fib at 0x000001C03AC34FC0>\n\n```\n　　那么这样就不占内存了，这里说一下generator和函数的执行流程，函数是顺序执行的，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次被next（）调用时候从上次的返回yield语句处急需执行，也就是用多少，取多少，不占内存。\n```\ndef fib(max):\n    n,a,b =0,0,1\n    while n < max:\n        yield b\n        a,b =b,a+b\n        n = n+1\n    return 'done'\n\na = fib(10)\nprint(fib(10))\nprint(a.__next__())\nprint(a.__next__())\nprint(a.__next__())\nprint(\"可以顺便干其他事情\")\nprint(a.__next__())\nprint(a.__next__())\n\n结果：\n<generator object fib at 0x0000023A21A34FC0>\n1\n1\n2\n可以顺便干其他事情\n3\n5\n```\n　　在上面fib的例子，我们在循环过程中不断调用`yield`，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。同样的，把函数改成generator后，我们基本上从来不会用`next()`来获取下一个返回值，而是直接使用`for`循环来迭代：\n```\ndef fib(max):\n    n,a,b =0,0,1\n    while n < max:\n        yield b\n        a,b =b,a+b\n        n = n+1\n    return 'done'\nfor i in fib(6):\n    print(i)\n\n结果：\n1\n1\n2\n3\n5\n8\n```\n　　但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果拿不到返回值，那么就会报错，所以为了不让报错，就要进行异常处理，拿到返回值，如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：\n```\ndef fib(max):\n    n,a,b =0,0,1\n    while n < max:\n        yield b\n        a,b =b,a+b\n        n = n+1\n    return 'done'\ng = fib(6)\nwhile True:\n    try:\n        x = next(g)\n        print('generator: ',x)\n    except StopIteration as e:\n        print(\"生成器返回值：\",e.value)\n        break\n\n\n结果：\ngenerator:  1\ngenerator:  1\ngenerator:  2\ngenerator:  3\ngenerator:  5\ngenerator:  8\n生成器返回值： done\n```\n**还可以通过yield实现在单线程的情况下实现并发运算的效果**\n\n```\nimport time\ndef consumer(name):\n    print(\"%s 准备学习啦!\" %name)\n    while True:\n       lesson = yield\n\n       print(\"开始[%s]了,[%s]老师来讲课了!\" %(lesson,name))\n\n\ndef producer(name):\n    c = consumer('A')\n    c2 = consumer('B')\n    c.__next__()\n    c2.__next__()\n    print(\"同学们开始上课 了!\")\n    for i in range(10):\n        time.sleep(1)\n        print(\"到了两个同学!\")\n        c.send(i)\n        c2.send(i)\n\n结果：\nA 准备学习啦!\nB 准备学习啦!\n同学们开始上课 了!\n到了两个同学!\n开始[0]了,[A]老师来讲课了!\n开始[0]了,[B]老师来讲课了!\n到了两个同学!\n开始[1]了,[A]老师来讲课了!\n开始[1]了,[B]老师来讲课了!\n到了两个同学!\n开始[2]了,[A]老师来讲课了!\n开始[2]了,[B]老师来讲课了!\n到了两个同学!\n开始[3]了,[A]老师来讲课了!\n开始[3]了,[B]老师来讲课了!\n到了两个同学!\n开始[4]了,[A]老师来讲课了!\n开始[4]了,[B]老师来讲课了!\n到了两个同学!\n开始[5]了,[A]老师来讲课了!\n开始[5]了,[B]老师来讲课了!\n到了两个同学!\n开始[6]了,[A]老师来讲课了!\n开始[6]了,[B]老师来讲课了!\n到了两个同学!\n```\n　　由上面的例子我么可以发现，python提供了两种基本的方式\n\n**生成器函数：也是用def定义的，利用关键字yield一次性返回一个结果，阻塞，重新开始**\n\n**生成器表达式：返回一个对象，这个对象只有在需要的时候才产生结果**\n\n#### ——生成器函数\n\n为什么叫生成器函数？因为它随着时间的推移生成了一个数值队列。一般的函数在执行完毕之后会返回一个值然后退出，但是生成器函数会自动挂起，然后重新拾起急需执行，他会利用yield关键字关起函数，给调用者返回一个值，同时保留了当前的足够多的状态，可以使函数继续执行，生成器和迭代协议是密切相关的，**迭代器都有一个__next__()__成员方法，**这个方法要么返回迭代的下一项，要买引起异常结束迭代。\n\n```\n# 函数有了yield之后，函数名+（）就变成了生成器\n# return在生成器中代表生成器的中止，直接报错\n# next的作用是唤醒并继续执行\n# send的作用是唤醒并继续执行，发送一个信息到生成器内部\n'''生成器'''\n\ndef create_counter(n):\n    print(\"create_counter\")\n    while True:\n        yield n\n        print(\"increment n\")\n        n +=1\n\ngen = create_counter(2)\nprint(gen)\nprint(next(gen))\nprint(next(gen))\n\n结果：\n<generator object create_counter at 0x0000023A1694A938>\ncreate_counter\n2\nincrement n\n3\nProcess finished with exit code 0\n```\n\n#### ——生成器表达式\n生成器表达式来源于迭代和列表解析的组合，生成器和列表解析类似，但是它使用尖括号而不是方括号\n```\n>>> # 列表解析生成列表\n>>> [ x ** 3 for x in range(5)]\n[0, 1, 8, 27, 64]\n>>>\n>>> # 生成器表达式\n>>> (x ** 3 for x in range(5))\n<generator object <genexpr> at 0x000000000315F678>\n>>> # 两者之间转换\n>>> list(x ** 3 for x in range(5))\n[0, 1, 8, 27, 64]\n```\n\n　　**一个迭代既可以被写成生成器函数，也可以被协程生成器表达式，均支持自动和手动迭代。而且这些生成器只支持一个active迭代，也就是说生成器的迭代器就是生成器本身。**\n\n### 迭代器（迭代就是循环）\n\n**　　迭代器包含有next方法的实现，在正确的范围内返回期待的数据以及超出范围后能够抛出StopIteration的错误停止迭代。**\n\n　　我们已经知道，可以直接作用于for循环的数据类型有以下几种：\n\n一类是集合数据类型，如list,tuple,dict,set,str等\n\n一类是generator，包括生成器和带yield的generator function\n\n这些可以直接作用于for 循环的对象统称为可迭代对象：Iterable\n\n可以使用isinstance()判断一个对象是否为可**Iterable**对象\n\n```\n>>> from collections import Iterable\n>>> isinstance([], Iterable)\nTrue\n>>> isinstance({}, Iterable)\nTrue\n>>> isinstance('abc', Iterable)\nTrue\n>>> isinstance((x for x in range(10)), Iterable)\nTrue\n>>> isinstance(100, Iterable)\nFalse\n```\n　　而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。\n\n所以这里讲一下迭代器\n\n**一个实现了iter方法的对象时可迭代的，一个实现next方法的对象是迭代器**\n\n**可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。**\n\n可以使用isinstance()判断一个对象是否是**Iterator**对象：\n\n```\n>>> from collections import Iterator\n>>> isinstance((x for x in range(10)), Iterator)\nTrue\n>>> isinstance([], Iterator)\nFalse\n>>> isinstance({}, Iterator)\nFalse\n>>> isinstance('abc', Iterator)\nFalse\n\n```\n生成器都是`Iterator`对象，但`list`、`dict`、`str`虽然是`Iterable（可迭代对象）`，却不是`Iterator（迭代器）`。\n\n**把`list`、`dict`、`str`等`Iterable`变成`Iterator`**可以使用`iter()`函数**：**\n\n```\n>>> isinstance(iter([]), Iterator)\nTrue\n>>> isinstance(iter('abc'), Iterator)\nTrue\n```\n你可能会问，为什么`list`、`dict`、`str`等数据类型不是`Iterator`？\n\n这是因为Python的`Iterator`对象表示的是一个**数据流**，Iterator对象可以被`next()`函数调用并不断返回下一个数据，直到没有数据时抛出`StopIteration`错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过`next()`函数实现按需计算下一个数据，所以`Iterator`的计算是惰性的，只有在需要返回下一个数据时它才会计算。\n\n`Iterator`甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。\n\n**判断下列数据类型是可迭代对象or迭代器**\n\n```\ns='hello'\nl=[1,2,3,4]\nt=(1,2,3)\nd={'a':1}\nset={1,2,3}\nf=open('a.txt')\n\ns='hello'     #字符串是可迭代对象，但不是迭代器\nl=[1,2,3,4]     #列表是可迭代对象，但不是迭代器\nt=(1,2,3)       #元组是可迭代对象，但不是迭代器\nd={'a':1}        #字典是可迭代对象，但不是迭代器\nset={1,2,3}     #集合是可迭代对象，但不是迭代器\n# *************************************\nf=open('test.txt') #文件是可迭代对象，是迭代器\n\n#如何判断是可迭代对象，只有__iter__方法，执行该方法得到的迭代器对象。\n# 及可迭代对象通过__iter__转成迭代器对象\nfrom collections import Iterator  #迭代器\nfrom collections import Iterable  #可迭代对象\n\nprint(isinstance(s,Iterator))     #判断是不是迭代器\nprint(isinstance(s,Iterable))       #判断是不是可迭代对象\n\n#把可迭代对象转换为迭代器\nprint(isinstance(iter(s),Iterator))\n```\n**　注意：文件的判断**\n```\nf = open('housing.csv')\nfrom collections import Iterator\nfrom collections import Iterable\n\nprint(isinstance(f,Iterator))\nprint(isinstance(f,Iterable))\n\nTrue\nTrue\n```\n\n　　**结论：文件是可迭代对象，也是迭代器**\n\n**小结：**\n\n*   凡是可作用于`for`循环的对象都是`Iterable`类型；\n*   凡是可作用于`next()`函数的对象都是`Iterator`类型，它们表示一个惰性计算的序列；\n*   集合数据类型如`list`、`dict`、`str`等是`Iterable`但不是`Iterator`，不过可以通过`iter()`函数获得一个`Iterator`对象。\n\nPython3的`for`循环本质上就是通过不断调用`next()`函数实现的，例如：\n\n```\nfor x in [1, 2, 3, 4, 5]:\n    pass\n```\n\n　实际上完全等价于\n```\n# 首先获得Iterator对象:\nit = iter([1, 2, 3, 4, 5])\n# 循环:\nwhile True:\n    try:\n        # 获得下一个值:\n        x = next(it)\n    except StopIteration:\n        # 遇到StopIteration就退出循环\n        break\n```\n### 对yield的总结\n\n　　（1）通常的for..in...循环中，in后面是一个数组，这个数组就是一个可迭代对象，类似的还有链表，字符串，文件。他可以是a = [1,2,3]，也可以是a = [x*x for x in range(3)]。\n\n它的缺点也很明显，就是所有数据都在内存里面，如果有海量的数据，将会非常耗内存。\n\n　　（2）生成器是可以迭代的，但是只可以读取它一次。因为用的时候才生成，比如a = (x*x for x in range(3))。!!!!注意这里是小括号而不是方括号。\n\n　　（3）生成器（generator）能够迭代的关键是他有next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。\n\n　　（4）带有yield的函数不再是一个普通的函数，而是一个生成器generator，可用于迭代\n\n　　（5）yield是一个类似return 的关键字，迭代一次遇到yield的时候就返回yield后面或者右面的值。而且下一次迭代的时候，从上一次迭代遇到的yield后面的代码开始执行\n\n　　（6）yield就是return返回的一个值，并且记住这个返回的位置。下一次迭代就从这个位置开始。\n\n　　（7）带有yield的函数不仅仅是只用于for循环，而且可用于某个函数的参数，只要这个函数的参数也允许迭代参数。\n\n　　（8）send()和next()的区别就在于send可传递参数给yield表达式，这时候传递的参数就会作为yield表达式的值，而yield的参数是返回给调用者的值，也就是说send可以强行修改上一个yield表达式值。\n\n　　（9）send()和next()都有返回值，他们的返回值是当前迭代遇到的yield的时候，yield后面表达式的值，其实就是当前迭代yield后面的参数。\n\n　　（10）第一次调用时候必须先next（）或send（）,否则会报错，send后之所以为None是因为这时候没有上一个yield，所以也可以认为next（）等同于send(None)\n\n\n##### [原文：python 生成器和迭代器有这篇就够了](https://www.cnblogs.com/wj-1314/p/8490822.html)\n","tags":["python生成器","python迭代器"],"categories":["python"]},{"title":"Python中tuple+=赋值的四个问题","url":"/2021/05/04/python/Python中tuple+=赋值的四个问题/","content":"\n## 问题\n\n首先看第一个问题, 如下面的代码段:\n\n```\n\n>>> t = (1,2, [30,40])\n\n>>> t[2] += [50,60]\n\n```\n会产生什么结果呢？ 给出了四个选项:\n1. `t` 变成 `[1,2, [30,40,50,60]` \n2. `TypeError is raised with the message 'tuple' object does not support item assignment` \n3\\. Neither 1 nor 2\n4\\. Both 1 and 2\n\n按照之前的理解, `tuple`里面的元素是不能被修改的，因此会选`2`. 如果真是这样的话，这篇笔记就没必要了，Fluent Python中也就不会拿出一节来讲了。 正确答案是`4`\n\n\n<!--more-->\n\n\n```\n\n>>> t = (1,2,[30,40])\n\n>>> t[2] += [50,60]\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: 'tuple' object does not support item assignment\n\n>>> t\n\n(1, 2, [30, 40, 50, 60])\n\n```\n\n问题来了，为什么异常都出来了， `t`还是变了? 再看第二种情况，稍微变化一下,将`+=`变为`=`:\n\n```\n>>> t = (1,2, [30,40])\n\n>>> t[2] = [50,60]\n\n```\n结果就成酱紫了:\n\n```\n>>> t = (1,2, [30,40])\n\n>>> t[2] = [50,60]\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: 'tuple' object does not support item assignment\n\n>>> t\n\n(1, 2, [30, 40])\n```\n\n再看第三种情况,只把`+=`换为`extend`或者`append`,:\n\n```\n>>> t = (1, 2, [30,40])\n\n>>> t[2].extend([50,60])\n\n>>> t\n\n(1, 2, [30, 40, 50, 60])\n\n>>> t[2].append(70)\n\n>>> t\n\n(1, 2, [30, 40, 50, 60, 70])\n\n```\n又正常了,没抛出异常?\n\n最后第四种情况, 用变量的形式:\n\n```\n>>> a = [30,40]\n\n>>> t = (1, 2, a)\n\n>>> a+=[50,60]\n\n>>> a\n\n[30, 40, 50, 60]\n\n>>> t\n\n(1, 2, [30, 40, 50, 60])\n\n>>> t[2] += [70,80]\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: 'tuple' object does not support item assignment\n\n>>> t\n\n(1, 2, [30, 40, 50, 60, 70, 80])\n\n```\n又是一种情况, 下面就探究一下其中的原因.\n\n## 原因\n\n首先需要重温`+=`这个运算符,如`a+=b`:\n\n*   对于可变对象(mutable object)如`list`, `+=`操作的结果会直接在`a`对应的变量进行修改，而`a`对应的地址不变.\n*   对于不可变对象(imutable object)如`tuple`, `+=`则是等价于`a = a+b` 会产生新的变量，然后绑定到`a`上而已.\n\n如下代码段, 可以看出来:\n\n```\n>>> a = [1,2,3]\n\n>>> id(a)\n\n53430752\n\n>>> a+=[4,5]\n\n>>> a\n\n[1, 2, 3, 4, 5]\n\n>>> id(a)\n\n53430752 # 地址没有变化\n\n>>> b = (1,2,3)\n\n>>> id(b)\n\n49134888\n\n>>> b += (4,5)\n\n>>> b\n\n(1, 2, 3, 4, 5)\n\n>>> id(b)\n\n48560912 # 地址变化了\n\n```\n\n此外还需要注意的是, python中的`tuple`作为不可变对象, 也就是我们平时说的元素不能改变, 实际上从报错信息`TypeError: 'tuple' object does not support item assignment`来看, 更准确的说法是指其中的元素不支持赋值操作`=`(**assignment**).\n\n先看最简单的第二种情况, 它的结果是符合我们的预期, 因为`=`产生了`assign`的操作.(在[由一个例子到python的名字空间](http://shomy.top/2016/03/01/python-namespace-1/) 中指出了赋值操作`=`就是创建新的变量), 因此`s[2]=[50,60]`就会抛出异常.\n\n再看第三种情况,包含`extend/append`的, 结果tuple中的列表值发生了变化,但是没有异常抛出. 这个其实也相对容易理解. 因为我们知道`tuple`中存储的其实是元素所对应的地址(id), 因此如果没有赋值操作且tuple中的元素的`id`不变,即可,而`list.extend/append`只是修改了列表的元素,而列表本身id并没有变化,看看下面的例子:\n\n```\n>>> a=(1,2,[30,40])\n\n>>> id(a[2])\n\n140628739513736\n\n>>> a[2].extend([50,60])\n\n>>> a\n\n(1, 2, [30, 40, 50, 60])\n\n>>> id(a[2])\n\n140628739513736\n```\n目前解决了第二个和第三个问题, 先梳理一下, 其实就是两点:\n\n*   tuple内部的元素不支持赋值操作\n*   在第一条的基础上, 如果元素的`id`没有变化, 元素其实是可以改变的.\n\n现在再来看最初的第一个问题: `t[2] += [50,60]` 按照上面的结论, 不应该抛异常啊,因为在我们看来`+=` 对于可变对象`t[2]`来说, 属于`in-place`操作,也就是直接修改自身的内容, `id`并不变, 确认下id并没有变化:\n\n```\n>>> a=(1,2,[30,40])\n\n>>> id(a[2])\n\n140628739587392\n\n>>> a[2]+=[50,60]\n\nTraceback (most recent call last):\n\n  File \"<stdin>\", line 1, in <module>\n\nTypeError: 'tuple' object does not support item assignment\n\n>>> a\n\n(1, 2, [30, 40, 50, 60])\n\n>>> id(a[2]) # ID 并没有发生改变\n\n140628739587392\n\n```\n跟第三个问题仅仅从`t[2].extend`改成了`t[2]+=`, 就抛出异常了,所以问题应该是出在`+=`上了. 下面用`dis`模块看看它俩执行的步骤: 对下面的代码块执行`dis`:\n\n```\nt = (1,2, [30,40])\n\nt[2] += [50,60]\n\nt[2].extend([70, 80])\n\n```\n执行`python -m dis test.py`,结果如下，下面只保留第2,3行代码的执行过程，以及关键步骤的注释如下:\n\n```\n2          21 LOAD_NAME                0 (t)\n\n           24 LOAD_CONST               1 (2)\n\n           27 DUP_TOPX                 2\n\n           30 BINARY_SUBSCR\n\n           31 LOAD_CONST               4 (50)\n\n           34 LOAD_CONST               5 (60)\n\n           37 BUILD_LIST               2\n\n           40 INPLACE_ADD\n\n           41 ROT_THREE\n\n           42 STORE_SUBSCR\n\n3          43 LOAD_NAME                0 (t)\n\n           46 LOAD_CONST               1 (2)\n\n           49 BINARY_SUBSCR\n\n           50 LOAD_ATTR                1 (extend)\n\n           53 LOAD_CONST               6 (70)\n\n           56 LOAD_CONST               7 (80)\n\n           59 BUILD_LIST               2\n\n           62 CALL_FUNCTION            1\n\n           65 POP_TOP\n\n           66 LOAD_CONST               8 (None)\n\n           69 RETURN_VALUE\n\n```\n解释一下关键的语句:\n\n*   `30 BINARY_SUBSCR`: 表示将`t[2]`的值放在TOS(Top of Stack)，这里是指`[30, 40]`这个列表\n*   `40 INPLACE_ADD`: 表示`TOS += [50,60]` 执行这一步是可以成功的，修改了TOS的列表为`[30,40,50,60]`\n*   `42 STORE_SUBSCR`: 表示`s[2] = TOS` 问题就出在这里了，这里产生了一个**赋值操作**，因此会抛异常！但是上述对列表的修改已经完成, 这也就解释了开篇的第一个问题。\n\n再看`extend`的过程，前面都一样，只有这一行:\n\n*   `62 CALL_FUNCTION`: 这个直接调用内置extend函数完成了对原列表的修改，其中并没有`assign`操作，因此可以正常执行。\n\n现在逐渐清晰了， 换句话说，`+=`**并不是原子操作**，相当于下面的两步:\n\n```\nt[2].extend([50,60])\n\nt[2] = t[2]\n\n```\n第一步可以正确执行，但是第二步有了`=`，肯定会抛异常的。 同样这也可以解释在使用`+=`的时候，为何`t[2]`的`id`明明没有变化，但是仍然抛出异常了。\n\n现在用一句话总结下:\n\n> tuple中元素不支持`assign`操作，但是对于那些是可变对象的元素如列表，字典等，在没有`assign`操作的基础上，比如一些`in-place`操作，是可以修改内容的\n\n可以用第四个问题来简单验证一下，使用一个指向`[30,40]`的名称`a`来作为元素的值，然后对`a`做`in-place`的修改，其中并没有涉及到对tuple的`assign`操作，那肯定是正常执行的。\n\n## 总结\n\n这个问题其实以前也就遇到过，但是没想过具体的原理，后来翻书的时候又看到了， 于是花了点时间把这一个系列查了部分资料以及结合自己的理解都整理了出来, 算是饭后茶点吧, 不严谨的地方烦请指出.\n\n部分参考如下:\n\n*   [python bugs](http://bugs.python.org/issue11562)\n*   [python faq](https://docs.python.org/2/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works)\n*   [stackoverflow](https://stackoverflow.com/questions/10397121/why-does-of-a-list-within-a-python-tuple-raise-typeerror-but-modify-the-list)\n*   Fluent Python\n\n\n本文链接: [http://shomy.top/2017/08/17/python-tuple-assign/](http://shomy.top/2017/08/17/python-tuple-assign/)\n","tags":["tuple"],"categories":["python"]},{"title":"Python3 利用string模块生成密码","url":"/2021/05/04/python/Python3 利用string模块生成密码/","content":"\n\nstring模块中定义了一些常用的属性，包含所有数字、字母、可打印的所有ascii码等\n\n实例\n\n1. ascii_letters 生成所有大小写字母（a-z A-Z）\n```\nimport string\n\nletters = string.ascii_letters\nprint(letters)\n\n>>> abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n<!--more-->\n\n2. ascii_lowercase 生成所有小写字母（a-z）\n```\nimport string\n\nlowercase = string.asscii_lowercase\nprint(lowercase)\n\n>>> abcdefghijklmnopqrstuvwxyz\n ```\n\n3. ascii_uppercase 生成所有大写字母（A-Z）\n```\nimport string\n\nuppercase = string.ascii_uppercase\nprint(uppercase)\n\n>>> ABCDEFGHIJKLMNOPQRSTUVWXYZ\n ```\n\n4. digits 生成所有数字（0-9）\n```\nimport string\n\ndigits = string.digits\nprint(digits)\n\n>>> 0123456789\n ```\n\n5. punctuation 生成所有标点符号\n```\nimport string\n\npunctuation = string.punctuation\nprint(punctuotion)\n\n>>> !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\n```\n\n#密码生成器\n ```\ndef main():\n    \"\"\"密码生成器\"\"\"\n    a = string.ascii_letters + string.digits + string.punctuation\n    key = random.sample(a, 16)\n    keys = \"\".join(key)\n    print(keys)\n```\n","tags":["密码","gen-secret"],"categories":["python"]},{"title":"paramiko 远程执行命令","url":"/2021/05/04/python/paramiko 远程执行命令/","content":"\n# [Python学习总结 06 paramiko 远程执行命令](https://www.cnblogs.com/wangshuo1/p/6265360.html)\n\n  有时会需要在远程的机器上执行一个命令，并获得其返回结果。对于这种情况，python 可以很容易的实现。\n\n# 1 工具\n\nPython paramiko\n\n1) Paramiko模块安装\n\n　　在Linux的Terminal中，直接输入pip install paramiko 命令安装。\n\n2）确定paramiko安装成功\n\n　　在python命令行输入import paramiko，确认是否安装成功，没报错就没问题。\n\n<!--more-->\n\n# 2 步骤\n\n1 导入 paramiko 模块\n\n```\n#!/usr/bin/python\nimport paramiko\n```\n\n2 创建 ssh 连接函数\n\n```\ndef ssh_connect( _host, _username, _password ):\n    try:\n        _ssh_fd = paramiko.SSHClient()\n        _ssh_fd.set_missing_host_key_policy( paramiko.AutoAddPolicy() )\n        _ssh_fd.connect( _host, username = _username, password = _password )\n    except Exception, e:\n        print( 'ssh %s@%s: %s' % (_username, _host, e) )\n        exit()\n    return _ssh_fd\n```\n\n3 创建命令执行函数\n\n```\ndef ssh_exec_cmd( _ssh_fd, _cmd ):\n    return _ssh_fd.exec_command( _cmd )\n```\n4 创建关闭 ssh 函数\n\n```\ndef ssh_close( _ssh_fd ):\n    _ssh_fd.close()\n```\n\n5 使用示例\n\n```def main():\n    hostname = '192.168.55.243'\n    port = 22\n    username = 'root'\n    password = 'P@ssw0rd'\n    cmd = \"ps -ef|grep java\"\n\n    sshd = ssh_connect( hostname , username , password )\n    stdin, stdout, stderr = ssh_exec_cmd( sshd, cmd )\n    err_list = stderr.readlines()\n\n    if len( err_list ) > 0:\n        print 'ERROR:' + err_list[0]\n        exit()\n\n    for item in stdout.readlines():\n        print item,\n    ssh_close( sshd )\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n　　如果执行脚本成功，会成功返回以下结果。\n\n```\nroot      2540  2536  2 14:13 pts/4    00:01:21 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.resource.App\nroot      3442  3387  0  2016 ?        01:09:00 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.product.App\nroot      3451  3390  0  2016 ?        01:04:54 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.report.App\nroot      3452  3388  0  2016 ?        00:51:00 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.workflow.launcher.App\nroot      3892  3886  0  2016 ?        00:29:59 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.charge.App\nroot      4509  4507  0 15:09 ?        00:00:00 bash -c ps -ef|grep java\nroot      4519  4509  0 15:09 ?        00:00:00 grep java\nroot     12861 12857  0 Jan06 ?        00:09:06 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.workorder.App\nroot     16484 16480  0  2016 ?        00:45:27 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.billing.App\nroot     18699 18694  0 Jan06 ?        00:09:30 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.order.App\nroot     21902 21898  0 Jan05 ?        00:18:46 java -Ddefault.client.encoding=UTF-8 -Dfile.encoding=UTF-8 -Duser.language=Zh -Duser.region=CN -Duser.timezone=GMT+08 cn.com.ctsi.csdp.user.launcher.App\n ```\n\n 　　在实际的开发中，每次更新模块的jar包时，都需要使用 ps -ef | grep java, 查看模块的进程号，然后使用使用命令 kill -9 进程号，处理掉进程，然后重新启动 模块。\n\n下面尝试使用python脚本来代替手工输入代码。\n\n# 3 实例\n\n1） 启动模块\n\n```\n# -*- coding: utf-8 -*-\n\nimport paramiko\nssh = paramiko.SSHClient()\nssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nssh.connect('192.168.55.243', username = 'root', password = 'P@ssw0rd', timeout = 5)\ncmd = 'nohup /csdp/charge_launcher-1.0-release/bin/run.sh > /csdp/charge_launcher-1.0-release/bin/nohup.out 2>&1 & \\r\\n'\n\npassword= 'P@ssw0rd'\n\nstdin, stdout, stderr = ssh.exec_command( cmd )\n##stdin, stdout, stderr = ssh.exec_command('sudo -S %s\\n' % cmd )\n##stdin.write('%s\\r\\n' % password)\n##stdin.flush()\nprint \"------------------------\"\n##print stdout.readlines()\n##print stderr.read()\n\n\nprint \"------------------------\"\ncmd = 'pwd'\nstdin, stdout, stderr = ssh.exec_command(cmd )\nprint stdout.readlines()\n\nssh.close()\n```\n2） 远程上传文件\n\n```\n# -*- coding: utf-8 -*-\nimport paramiko\n\nserverIp = '192.168.55.243'\nserverUser = 'root'\nserverPwd = 'P@ssw0rd'\n\nlocalFile = 'user-1.0-release.jar'\nlocalpath = r'D:\\workspace\\csdp201512041\\csdp-ningxia\\csdp_user\\user\\target' + os.sep + localFile\n\nremotepath = '/csdp/user_launcher-1.0-dev/lib/' + localFile\n\ndef ftpModuleFile():\n    t = paramiko.Transport(( serverIp ,22))\n    t.connect(username = serverUser , password = serverPwd)\n    sftp = paramiko.SFTPClient.from_transport(t)\n   # remotepath='/csdp/user_launcher-1.0-dev/user-1.0-release.jar'\n   # localpath= r'D:\\workspace\\csdp201512041\\csdp-ningxia\\csdp_user\\user\\target\\user-1.0-release.jar'\n    sftp.put(localpath,remotepath)\n    t.close()\n    print(\"：） 成功上传%s文件。\" % remotepath)\n\nif __name__ == '__main__':\n   ftpModuleFile()\n```\n3) 执行远程linux命令\n\n```\n# -*- coding: utf-8 -*-\nimport paramiko\n\n\nif __name__ == \"__main__\":\n    hostname = '192.168.55.243'\n    port = 22\n    username = 'root'\n    password = 'P@ssw0rd'\n    cmd = \"ps -ef|grep java\"\n\n    ssh = paramiko.SSHClient()\n    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    #ssh.connect( hostname ,22, username , password )\n    ssh.connect(hostname,username=username,password=password,allow_agent=False,look_for_keys=False)\n    stdin, stdout, stderr = ssh.exec_command(cmd )\n    list = stdout.readlines()\n    print( list )\n\n    ssh.close()\n```\n","tags":["paramiko"],"categories":["python"]},{"title":"python内置函数-排列组合函数","url":"/2021/05/04/python/python内置函数-排列组合函数/","content":"\nproduct 笛卡尔积　　（有放回抽样排列）\n\npermutations 排列　　（不放回抽样排列）\n\ncombinations 组合,没有重复　　（不放回抽样组合）\n\ncombinations_with_replacement 组合,有重复　　（有放回抽样组合）\n\n<!--more-->\n\n详细的参见[官网](https://docs.python.org/2/library/itertools.html)。\n```\n>>> for i in itertools.product('ABCD', repeat = 2):\n...     print(i)\n...\n('A', 'A') ('A', 'B') ('A', 'C') ('A', 'D') ('B', 'A') ('B', 'B') ('B', 'C') ('B', 'D') ('C', 'A') ('C', 'B') ('C', 'C') ('C', 'D') ('D', 'A') ('D', 'B') ('D', 'C') ('D', 'D')\n>>> for i in itertools.permutations('ABCD', 2):\n...     print(i)\n...\n('A', 'B') ('A', 'C') ('A', 'D') ('B', 'A') ('B', 'C') ('B', 'D') ('C', 'A') ('C', 'B') ('C', 'D') ('D', 'A') ('D', 'B') ('D', 'C')\n>>> for i in itertools.combinations('ABCD', 2):\n...     print(i)\n...\n('A', 'B') ('A', 'C') ('A', 'D') ('B', 'C') ('B', 'D') ('C', 'D')\n>>> for i in itertools.combinations_with_replacement('ABCD', 2):\n...     print(i)\n...\n('A', 'A') ('A', 'B') ('A', 'C') ('A', 'D') ('B', 'B') ('B', 'C') ('B', 'D') ('C', 'C') ('C', 'D') ('D', 'D')</pre>\n```\n\n还有就是，combinations和permutations返回的是对象地址，原因是在python3里面，返回值已经不再是list,而是iterators（迭代器）, 所以想要使用，只用将iterator 转换成list 即可， 还有其他一些函数返回的也是一个对象，需要list转换，比如 list(map())等\n\n","tags":["python内置函数"],"categories":["python"]},{"title":"Vue.js - Day4","url":"/2021/05/04/vue/vue2.0基础课程/day4/","content":"\n# Vue.js - Day4\n\n## 父组件向子组件传值\n1. 组件实例定义方式，注意：一定要使用`props`属性来定义父组件传递过来的数据\n```\n<script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        msg: '这是父组件中的消息'\n      },\n      components: {\n        son: {\n          template: '<h1>这是子组件 --- {{finfo}}</h1>',\n          props: ['finfo']\n        }\n      }\n    });\n  </script>\n```\n2. 使用`v-bind`或简化指令，将数据传递到子组件中：\n```\n<div id=\"app\">\n    <son :finfo=\"msg\"></son>\n  </div>\n```\n\n## 子组件向父组件传值\n1. 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；\n2. 父组件将方法的引用传递给子组件，其中，`getMsg`是父组件中`methods`中定义的方法名称，`func`是子组件调用传递过来方法时候的方法名称\n```\n<son @func=\"getMsg\"></son>\n```\n3. 子组件内部通过`this.$emit('方法名', 要传递的数据)`方式，来调用父组件中的方法，同时把数据传递给父组件使用\n```\n<div id=\"app\">\n    <!-- 引用父组件 -->\n    <son @func=\"getMsg\"></son>\n\n    <!-- 组件模板定义 -->\n    <script type=\"x-template\" id=\"son\">\n      <div>\n        <input type=\"button\" value=\"向父组件传值\" @click=\"sendMsg\" />\n      </div>\n    </script>\n  </div>\n\n  <script>\n    // 子组件的定义方式\n    Vue.component('son', {\n      template: '#son', // 组件模板Id\n      methods: {\n        sendMsg() { // 按钮的点击事件\n          this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去\n        }\n      }\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {\n        getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义\n          alert(val);\n        }\n      }\n    });\n  </script>\n```\n\n## 组件中data和props的区别\n\n## 评论列表案例\n目标：主要练习父子组件之间传值\n\n## 使用 `this.$refs` 来获取元素和组件\n```\n  <div id=\"app\">\n    <div>\n      <input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" />\n      <!-- 使用 ref 获取元素 -->\n      <h1 ref=\"myh1\">这是一个大大的H1</h1>\n\n      <hr>\n      <!-- 使用 ref 获取子组件 -->\n      <my-com ref=\"mycom\"></my-com>\n    </div>\n  </div>\n\n  <script>\n    Vue.component('my-com', {\n      template: '<h5>这是一个子组件</h5>',\n      data() {\n        return {\n          name: '子组件'\n        }\n      }\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {\n        getElement() {\n          // 通过 this.$refs 来获取元素\n          console.log(this.$refs.myh1.innerText);\n          // 通过 this.$refs 来获取组件\n          console.log(this.$refs.mycom.name);\n        }\n      }\n    });\n  </script>\n```\n\n## 什么是路由\n1. **后端路由：**对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；\n\n2. **前端路由：**对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；\n\n3. 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；\n\n## 在 vue 中使用 vue-router\n1. 导入 vue-router 组件类库：\n```\n<!-- 1. 导入 vue-router 组件类库 -->\n  <script src=\"./lib/vue-router-2.7.0.js\"></script>\n```\n2. 使用 router-link 组件来导航\n```\n<!-- 2. 使用 router-link 组件来导航 -->\n<router-link to=\"/login\">登录</router-link>\n<router-link to=\"/register\">注册</router-link>\n```\n3. 使用 router-view 组件来显示匹配到的组件\n```\n<!-- 3. 使用 router-view 组件来显示匹配到的组件 -->\n<router-view></router-view>\n```\n4. 创建使用`Vue.extend`创建组件\n```\n    // 4.1 使用 Vue.extend 来创建登录组件\n    var login = Vue.extend({\n      template: '<h1>登录组件</h1>'\n    });\n\n    // 4.2 使用 Vue.extend 来创建注册组件\n    var register = Vue.extend({\n      template: '<h1>注册组件</h1>'\n    });\n```\n5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则\n```\n// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则\n    var router = new VueRouter({\n      routes: [\n        { path: '/login', component: login },\n        { path: '/register', component: register }\n      ]\n    });\n```\n6. 使用 router 属性来使用路由规则\n```\n// 6. 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      router: router // 使用 router 属性来使用路由规则\n    });\n```\n\n## 使用tag属性指定router-link渲染的标签类型\n\n## 设置路由重定向\n\n## 设置路由高亮\n\n## 设置路由切换动效\n\n## 在路由规则中定义参数\n1. 在规则中定义参数：\n```\n{ path: '/register/:id', component: register }\n```\n2. 通过 `this.$route.params`来获取路由中的参数：\n```\nvar register = Vue.extend({\n      template: '<h1>注册组件 --- {{this.$route.params.id}}</h1>'\n    });\n```\n\n## 使用 `children` 属性实现路由嵌套\n```\n  <div id=\"app\">\n    <router-link to=\"/account\">Account</router-link>\n\n    <router-view></router-view>\n  </div>\n\n  <script>\n    // 父路由中的组件\n    const account = Vue.extend({\n      template: `<div>\n        这是account组件\n        <router-link to=\"/account/login\">login</router-link> |\n        <router-link to=\"/account/register\">register</router-link>\n        <router-view></router-view>\n      </div>`\n    });\n\n    // 子路由中的 login 组件\n    const login = Vue.extend({\n      template: '<div>登录组件</div>'\n    });\n\n    // 子路由中的 register 组件\n    const register = Vue.extend({\n      template: '<div>注册组件</div>'\n    });\n\n    // 路由实例\n    var router = new VueRouter({\n      routes: [\n        { path: '/', redirect: '/account/login' }, // 使用 redirect 实现路由重定向\n        {\n          path: '/account',\n          component: account,\n          children: [ // 通过 children 数组属性，来实现路由的嵌套\n            { path: 'login', component: login }, // 注意，子路由的开头位置，不要加 / 路径符\n            { path: 'register', component: register }\n          ]\n        }\n      ]\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      components: {\n        account\n      },\n      router: router\n    });\n  </script>\n```\n\n## 命名视图实现经典布局\n1. 标签代码结构：\n```\n<div id=\"app\">\n    <router-view></router-view>\n    <div class=\"content\">\n      <router-view name=\"a\"></router-view>\n      <router-view name=\"b\"></router-view>\n    </div>\n  </div>\n```\n2. JS代码：\n```\n<script>\n    var header = Vue.component('header', {\n      template: '<div class=\"header\">header</div>'\n    });\n\n    var sidebar = Vue.component('sidebar', {\n      template: '<div class=\"sidebar\">sidebar</div>'\n    });\n\n    var mainbox = Vue.component('mainbox', {\n      template: '<div class=\"mainbox\">mainbox</div>'\n    });\n\n    // 创建路由对象\n    var router = new VueRouter({\n      routes: [\n        {\n          path: '/', components: {\n            default: header,\n            a: sidebar,\n            b: mainbox\n          }\n        }\n      ]\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      router\n    });\n  </script>\n```\n3. CSS 样式：\n```\n  <style>\n    .header {\n      border: 1px solid red;\n    }\n\n    .content{\n      display: flex;\n    }\n    .sidebar {\n      flex: 2;\n      border: 1px solid green;\n      height: 500px;\n    }\n    .mainbox{\n      flex: 8;\n      border: 1px solid blue;\n      height: 500px;\n    }\n  </style>\n```\n\n## `watch`属性的使用\n考虑一个问题：想要实现 `名` 和 `姓` 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）\n\n1. 监听`data`中属性的改变：\n```\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\"> +\n    <input type=\"text\" v-model=\"lastName\"> =\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen',\n        fullName: 'jack - chen'\n      },\n      methods: {},\n      watch: {\n        'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据\n          this.fullName = newVal + ' - ' + this.lastName;\n        },\n        'lastName': function (newVal, oldVal) {\n          this.fullName = this.firstName + ' - ' + newVal;\n        }\n      }\n    });\n  </script>\n```\n2. 监听路由对象的改变：\n```\n<div id=\"app\">\n    <router-link to=\"/login\">登录</router-link>\n    <router-link to=\"/register\">注册</router-link>\n\n    <router-view></router-view>\n  </div>\n\n  <script>\n    var login = Vue.extend({\n      template: '<h1>登录组件</h1>'\n    });\n\n    var register = Vue.extend({\n      template: '<h1>注册组件</h1>'\n    });\n\n    var router = new VueRouter({\n      routes: [\n        { path: \"/login\", component: login },\n        { path: \"/register\", component: register }\n      ]\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      router: router,\n      watch: {\n        '$route': function (newVal, oldVal) {\n          if (newVal.path === '/login') {\n            console.log('这是登录组件');\n          }\n        }\n      }\n    });\n  </script>\n```\n\n## `computed`计算属性的使用\n1. 默认只有`getter`的计算属性：\n```\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\"> +\n    <input type=\"text\" v-model=\"lastName\"> =\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen'\n      },\n      methods: {},\n      computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值\n        fullName() {\n          return this.firstName + ' - ' + this.lastName;\n        }\n      }\n    });\n  </script>\n```\n2. 定义有`getter`和`setter`的计算属性：\n```\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\">\n    <input type=\"text\" v-model=\"lastName\">\n    <!-- 点击按钮重新为 计算属性 fullName 赋值 -->\n    <input type=\"button\" value=\"修改fullName\" @click=\"changeName\">\n\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen'\n      },\n      methods: {\n        changeName() {\n          this.fullName = 'TOM - chen2';\n        }\n      },\n      computed: {\n        fullName: {\n          get: function () {\n            return this.firstName + ' - ' + this.lastName;\n          },\n          set: function (newVal) {\n            var parts = newVal.split(' - ');\n            this.firstName = parts[0];\n            this.lastName = parts[1];\n          }\n        }\n      }\n    });\n  </script>\n```\n\n## `watch`、`computed`和`methods`之间的对比\n1. `computed`属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；\n2. `methods`方法表示一个具体的操作，主要书写业务逻辑；\n3. `watch`一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是`computed`和`methods`的结合体；\n\n## `nrm`的安装使用\n作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；\n什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；\n1. 运行`npm i nrm -g`全局安装`nrm`包；\n2. 使用`nrm ls`查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；\n3. 使用`nrm use npm`或`nrm use taobao`切换不同的镜像源地址；\n\n> 注意： nrm 只是单纯的提供了几个常用的 下载包的 URL地址，并能够让我们在 这几个 地址之间，很方便的进行切换，但是，我们每次装包的时候，使用的 装包工具，都是  npm\n\n## 相关文件\n1. [URL中的hash（井号）](http://www.cnblogs.com/joyho/articles/4430148.html)\n","tags":["vue","vue2.0基础课程"],"categories":["vue2.0基础课程"]},{"title":"Vue.js - Day3","url":"/2021/05/04/vue/vue2.0基础课程/day3/","content":"\n# Vue.js - Day3\n\n## 定义Vue组件\n什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；\n组件化和模块化的不同：\n + 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；\n + 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；\n### 全局组件定义的三种方式\n1. 使用 Vue.extend 配合 Vue.component 方法：\n```\nvar login = Vue.extend({\n      template: '<h1>登录</h1>'\n    });\n    Vue.component('login', login);\n```\n2. 直接使用 Vue.component 方法：\n```\nVue.component('register', {\n      template: '<h1>注册</h1>'\n    });\n```\n3. 将模板字符串，定义到script标签种：\n```\n<script id=\"tmpl\" type=\"x-template\">\n      <div><a href=\"#\">登录</a> | <a href=\"#\">注册</a></div>\n    </script>\n```\n同时，需要使用 Vue.component 来定义组件：\n```\nVue.component('account', {\n      template: '#tmpl'\n    });\n```\n\n> 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！\n\n### 组件中展示数据和响应事件\n1. 在组件中，`data`需要被定义为一个方法，例如：\n```\nVue.component('account', {\n      template: '#tmpl',\n      data() {\n        return {\n          msg: '大家好！'\n        }\n      },\n      methods:{\n        login(){\n          alert('点击了登录按钮');\n        }\n      }\n    });\n```\n2. 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的`data`属性中的值，需要使用`this`来访问；\n\n### 【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象\n1. 通过计数器案例演示\n\n### 使用`components`属性定义局部子组件\n1. 组件实例定义方式：\n```\n<script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      components: { // 定义子组件\n        account: { // account 组件\n          template: '<div><h1>这是Account组件{{name}}</h1><login></login></div>', // 在这里使用定义的子组件\n          components: { // 定义子组件的子组件\n            login: { // login 组件\n              template: \"<h3>这是登录组件</h3>\"\n            }\n          }\n        }\n      }\n    });\n  </script>\n```\n2. 引用组件：\n```\n<div id=\"app\">\n    <account></account>\n  </div>\n```\n\n## 使用`flag`标识符结合`v-if`和`v-else`切换组件\n1. 页面结构：\n```\n<div id=\"app\">\n    <input type=\"button\" value=\"toggle\" @click=\"flag=!flag\">\n    <my-com1 v-if=\"flag\"></my-com1>\n    <my-com2 v-else=\"flag\"></my-com2>\n  </div>\n```\n2. Vue实例定义：\n```\n<script>\n    Vue.component('myCom1', {\n      template: '<h3>奔波霸</h3>'\n    })\n\n    Vue.component('myCom2', {\n      template: '<h3>霸波奔</h3>'\n    })\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        flag: true\n      },\n      methods: {}\n    });\n  </script>\n```\n\n## 使用`:is`属性来切换不同的子组件,并添加切换动画\n1. 组件实例定义方式：\n```\n  // 登录组件\n    const login = Vue.extend({\n      template: `<div>\n        <h3>登录组件</h3>\n      </div>`\n    });\n    Vue.component('login', login);\n\n    // 注册组件\n    const register = Vue.extend({\n      template: `<div>\n        <h3>注册组件</h3>\n      </div>`\n    });\n    Vue.component('register', register);\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: { comName: 'login' },\n      methods: {}\n    });\n```\n2. 使用`component`标签，来引用组件，并通过`:is`属性来指定要加载的组件：\n```\n  <div id=\"app\">\n    <a href=\"#\" @click.prevent=\"comName='login'\">登录</a>\n    <a href=\"#\" @click.prevent=\"comName='register'\">注册</a>\n    <hr>\n    <transition mode=\"out-in\">\n      <component :is=\"comName\"></component>\n    </transition>\n  </div>\n```\n3. 添加切换样式：\n```\n  <style>\n    .v-enter,\n    .v-leave-to {\n      opacity: 0;\n      transform: translateX(30px);\n    }\n\n    .v-enter-active,\n    .v-leave-active {\n      position: absolute;\n      transition: all 0.3s ease;\n    }\n\n    h3{\n      margin: 0;\n    }\n  </style>\n```\n\n## 父组件向子组件传值\n1. 组件实例定义方式，注意：一定要使用`props`属性来定义父组件传递过来的数据\n```\n<script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        msg: '这是父组件中的消息'\n      },\n      components: {\n        son: {\n          template: '<h1>这是子组件 --- {{finfo}}</h1>',\n          props: ['finfo']\n        }\n      }\n    });\n  </script>\n```\n2. 使用`v-bind`或简化指令，将数据传递到子组件中：\n```\n<div id=\"app\">\n    <son :finfo=\"msg\"></son>\n  </div>\n```\n\n## 子组件向父组件传值\n1. 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；\n2. 父组件将方法的引用传递给子组件，其中，`getMsg`是父组件中`methods`中定义的方法名称，`func`是子组件调用传递过来方法时候的方法名称\n```\n<son @func=\"getMsg\"></son>\n```\n3. 子组件内部通过`this.$emit('方法名', 要传递的数据)`方式，来调用父组件中的方法，同时把数据传递给父组件使用\n```\n<div id=\"app\">\n    <!-- 引用父组件 -->\n    <son @func=\"getMsg\"></son>\n\n    <!-- 组件模板定义 -->\n    <script type=\"x-template\" id=\"son\">\n      <div>\n        <input type=\"button\" value=\"向父组件传值\" @click=\"sendMsg\" />\n      </div>\n    </script>\n  </div>\n\n  <script>\n    // 子组件的定义方式\n    Vue.component('son', {\n      template: '#son', // 组件模板Id\n      methods: {\n        sendMsg() { // 按钮的点击事件\n          this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去\n        }\n      }\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {\n        getMsg(val){ // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义\n          alert(val);\n        }\n      }\n    });\n  </script>\n```\n\n## 评论列表案例\n目标：主要练习父子组件之间传值\n\n## 使用 `this.$refs` 来获取元素和组件\n```\n  <div id=\"app\">\n    <div>\n      <input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" />\n      <!-- 使用 ref 获取元素 -->\n      <h1 ref=\"myh1\">这是一个大大的H1</h1>\n\n      <hr>\n      <!-- 使用 ref 获取子组件 -->\n      <my-com ref=\"mycom\"></my-com>\n    </div>\n  </div>\n\n  <script>\n    Vue.component('my-com', {\n      template: '<h5>这是一个子组件</h5>',\n      data() {\n        return {\n          name: '子组件'\n        }\n      }\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {\n        getElement() {\n          // 通过 this.$refs 来获取元素\n          console.log(this.$refs.myh1.innerText);\n          // 通过 this.$refs 来获取组件\n          console.log(this.$refs.mycom.name);\n        }\n      }\n    });\n  </script>\n```\n\n## 什么是路由\n1. 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；\n\n2. 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；\n\n3. 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；\n\n## 在 vue 中使用 vue-router\n1. 导入 vue-router 组件类库：\n```\n<!-- 1. 导入 vue-router 组件类库 -->\n  <script src=\"./lib/vue-router-2.7.0.js\"></script>\n```\n2. 使用 router-link 组件来导航\n```\n<!-- 2. 使用 router-link 组件来导航 -->\n<router-link to=\"/login\">登录</router-link>\n<router-link to=\"/register\">注册</router-link>\n```\n3. 使用 router-view 组件来显示匹配到的组件\n```\n<!-- 3. 使用 router-view 组件来显示匹配到的组件 -->\n<router-view></router-view>\n```\n4. 创建使用`Vue.extend`创建组件\n```\n    // 4.1 使用 Vue.extend 来创建登录组件\n    var login = Vue.extend({\n      template: '<h1>登录组件</h1>'\n    });\n\n    // 4.2 使用 Vue.extend 来创建注册组件\n    var register = Vue.extend({\n      template: '<h1>注册组件</h1>'\n    });\n```\n5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则\n```\n// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则\n    var router = new VueRouter({\n      routes: [\n        { path: '/login', component: login },\n        { path: '/register', component: register }\n      ]\n    });\n```\n6. 使用 router 属性来使用路由规则\n```\n// 6. 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      router: router // 使用 router 属性来使用路由规则\n    });\n```\n\n## 设置路由高亮\n\n## 设置路由切换动效\n\n## 在路由规则中定义参数\n1. 在规则中定义参数：\n```\n{ path: '/register/:id', component: register }\n```\n2. 通过 `this.$route.params`来获取路由中的参数：\n```\nvar register = Vue.extend({\n      template: '<h1>注册组件 --- {{this.$route.params.id}}</h1>'\n    });\n```\n\n## 使用 `children` 属性实现路由嵌套\n```\n  <div id=\"app\">\n    <router-link to=\"/account\">Account</router-link>\n\n    <router-view></router-view>\n  </div>\n\n  <script>\n    // 父路由中的组件\n    const account = Vue.extend({\n      template: `<div>\n        这是account组件\n        <router-link to=\"/account/login\">login</router-link> |\n        <router-link to=\"/account/register\">register</router-link>\n        <router-view></router-view>\n      </div>`\n    });\n\n    // 子路由中的 login 组件\n    const login = Vue.extend({\n      template: '<div>登录组件</div>'\n    });\n\n    // 子路由中的 register 组件\n    const register = Vue.extend({\n      template: '<div>注册组件</div>'\n    });\n\n    // 路由实例\n    var router = new VueRouter({\n      routes: [\n        { path: '/', redirect: '/account/login' }, // 使用 redirect 实现路由重定向\n        {\n          path: '/account',\n          component: account,\n          children: [ // 通过 children 数组属性，来实现路由的嵌套\n            { path: 'login', component: login }, // 注意，子路由的开头位置，不要加 / 路径符\n            { path: 'register', component: register }\n          ]\n        }\n      ]\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      components: {\n        account\n      },\n      router: router\n    });\n  </script>\n```\n\n## 命名视图实现经典布局\n1. 标签代码结构：\n```\n<div id=\"app\">\n    <router-view></router-view>\n    <div class=\"content\">\n      <router-view name=\"a\"></router-view>\n      <router-view name=\"b\"></router-view>\n    </div>\n  </div>\n```\n2. JS代码：\n```\n<script>\n    var header = Vue.component('header', {\n      template: '<div class=\"header\">header</div>'\n    });\n\n    var sidebar = Vue.component('sidebar', {\n      template: '<div class=\"sidebar\">sidebar</div>'\n    });\n\n    var mainbox = Vue.component('mainbox', {\n      template: '<div class=\"mainbox\">mainbox</div>'\n    });\n\n    // 创建路由对象\n    var router = new VueRouter({\n      routes: [\n        {\n          path: '/', components: {\n            default: header,\n            a: sidebar,\n            b: mainbox\n          }\n        }\n      ]\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      router\n    });\n  </script>\n```\n3. CSS 样式：\n```\n  <style>\n    .header {\n      border: 1px solid red;\n    }\n\n    .content{\n      display: flex;\n    }\n    .sidebar {\n      flex: 2;\n      border: 1px solid green;\n      height: 500px;\n    }\n    .mainbox{\n      flex: 8;\n      border: 1px solid blue;\n      height: 500px;\n    }\n  </style>\n```\n\n## `watch`属性的使用\n考虑一个问题：想要实现 `名` 和 `姓` 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）\n\n1. 监听`data`中属性的改变：\n```\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\"> +\n    <input type=\"text\" v-model=\"lastName\"> =\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen',\n        fullName: 'jack - chen'\n      },\n      methods: {},\n      watch: {\n        'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据\n          this.fullName = newVal + ' - ' + this.lastName;\n        },\n        'lastName': function (newVal, oldVal) {\n          this.fullName = this.firstName + ' - ' + newVal;\n        }\n      }\n    });\n  </script>\n```\n2. 监听路由对象的改变：\n```\n<div id=\"app\">\n    <router-link to=\"/login\">登录</router-link>\n    <router-link to=\"/register\">注册</router-link>\n\n    <router-view></router-view>\n  </div>\n\n  <script>\n    var login = Vue.extend({\n      template: '<h1>登录组件</h1>'\n    });\n\n    var register = Vue.extend({\n      template: '<h1>注册组件</h1>'\n    });\n\n    var router = new VueRouter({\n      routes: [\n        { path: \"/login\", component: login },\n        { path: \"/register\", component: register }\n      ]\n    });\n\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {},\n      methods: {},\n      router: router,\n      watch: {\n        '$route': function (newVal, oldVal) {\n          if (newVal.path === '/login') {\n            console.log('这是登录组件');\n          }\n        }\n      }\n    });\n  </script>\n```\n\n## `computed`计算属性的使用\n1. 默认只有`getter`的计算属性：\n```\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\"> +\n    <input type=\"text\" v-model=\"lastName\"> =\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen'\n      },\n      methods: {},\n      computed: { // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值\n        fullName() {\n          return this.firstName + ' - ' + this.lastName;\n        }\n      }\n    });\n  </script>\n```\n2. 定义有`getter`和`setter`的计算属性：\n```\n<div id=\"app\">\n    <input type=\"text\" v-model=\"firstName\">\n    <input type=\"text\" v-model=\"lastName\">\n    <!-- 点击按钮重新为 计算属性 fullName 赋值 -->\n    <input type=\"button\" value=\"修改fullName\" @click=\"changeName\">\n\n    <span>{{fullName}}</span>\n  </div>\n\n  <script>\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        firstName: 'jack',\n        lastName: 'chen'\n      },\n      methods: {\n        changeName() {\n          this.fullName = 'TOM - chen2';\n        }\n      },\n      computed: {\n        fullName: {\n          get: function () {\n            return this.firstName + ' - ' + this.lastName;\n          },\n          set: function (newVal) {\n            var parts = newVal.split(' - ');\n            this.firstName = parts[0];\n            this.lastName = parts[1];\n          }\n        }\n      }\n    });\n  </script>\n```\n\n## `watch`、`computed`和`methods`之间的对比\n1. `computed`属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；\n2. `methods`方法表示一个具体的操作，主要书写业务逻辑；\n3. `watch`一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是`computed`和`methods`的结合体；\n\n## `nrm`的安装使用\n作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；\n什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；\n1. 运行`npm i nrm -g`全局安装`nrm`包；\n2. 使用`nrm ls`查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；\n3. 使用`nrm use npm`或`nrm use taobao`切换不同的镜像源地址；\n\n## 相关文件\n1. [URL中的hash（井号）](http://www.cnblogs.com/joyho/articles/4430148.html)\n","tags":["vue","vue2.0基础课程"],"categories":["vue2.0基础课程"]},{"title":"Vue.js - Day2","url":"/2021/05/02/vue/vue2.0基础课程/day2/","content":"\n# Vue.js - Day2\n\n## 品牌管理案例\n\n### 添加新品牌\n\n### 删除品牌\n\n### 根据条件筛选品牌\n\n1. 1.x 版本中的filterBy指令，在2.x中已经被废除：\n\n[filterBy - 指令](https://v1-cn.vuejs.org/api/#filterBy)\n\n```\n\n<tr v-for=\"item in list | filterBy searchName in 'name'\">\n\n  <td>{{item.id}}</td>\n\n  <td>{{item.name}}</td>\n\n  <td>{{item.ctime}}</td>\n\n  <td>\n\n    <a href=\"#\" @click.prevent=\"del(item.id)\">删除</a>\n\n  </td>\n\n</tr>\n\n```\n\n2. 在2.x版本中[手动实现筛选的方式](https://cn.vuejs.org/v2/guide/list.html#显示过滤-排序结果)：\n\n+ 筛选框绑定到 VM 实例中的 `searchName` 属性：\n\n```\n\n<hr> 输入筛选名称：\n\n<input type=\"text\" v-model=\"searchName\">\n\n```\n\n+ 在使用 `v-for` 指令循环每一行数据的时候，不再直接 `item in list`，而是 `in` 一个 过滤的methods 方法，同时，把过滤条件`searchName`传递进去：\n\n```\n\n<tbody>\n\n      <tr v-for=\"item in search(searchName)\">\n\n        <td>{{item.id}}</td>\n\n        <td>{{item.name}}</td>\n\n        <td>{{item.ctime}}</td>\n\n        <td>\n\n          <a href=\"#\" @click.prevent=\"del(item.id)\">删除</a>\n\n        </td>\n\n      </tr>\n\n    </tbody>\n\n```\n\n+ `search` 过滤方法中，使用 数组的 `filter` 方法进行过滤：\n\n```\n\nsearch(name) {\n\n  return this.list.filter(x => {\n\n    return x.name.indexOf(name) != -1;\n\n  });\n\n}\n\n```\n\n## Vue调试工具`vue-devtools`的安装步骤和使用\n\n[Vue.js devtools - 翻墙安装方式 - 推荐](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN)\n\n## 过滤器\n\n概念：Vue.js 允许你自定义过滤器，**可被用作一些常见的文本格式化**。过滤器可以用在两个地方：**mustache 插值和 v-bind 表达式**。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；\n\n### 私有过滤器\n\n1. HTML元素：\n\n```\n\n<td>{{item.ctime | dataFormat('yyyy-mm-dd')}}</td>\n\n```\n\n2. 私有 `filters` 定义方式：\n\n```\n\nfilters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用\n\n    dataFormat(input, pattern = \"\") { // 在参数列表中 通过 pattern=\"\" 来指定形参默认值，防止报错\n\n      var dt = new Date(input);\n\n      // 获取年月日\n\n      var y = dt.getFullYear();\n\n      var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n\n      var d = dt.getDate().toString().padStart(2, '0');\n\n\n\n      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日\n\n      // 否则，就返回  年-月-日 时：分：秒\n\n      if (pattern.toLowerCase() === 'yyyy-mm-dd') {\n\n        return `${y}-${m}-${d}`;\n\n      } else {\n\n        // 获取时分秒\n\n        var hh = dt.getHours().toString().padStart(2, '0');\n\n        var mm = dt.getMinutes().toString().padStart(2, '0');\n\n        var ss = dt.getSeconds().toString().padStart(2, '0');\n\n\n\n        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n\n      }\n\n    }\n\n  }\n\n```\n\n\n\n> 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString='') 或 String.prototype.padEnd(maxLength, fillString='')来填充字符串；\n\n\n\n\n\n### 全局过滤器\n\n```\n\n// 定义一个全局过滤器\n\nVue.filter('dataFormat', function (input, pattern = '') {\n\n  var dt = new Date(input);\n\n  // 获取年月日\n\n  var y = dt.getFullYear();\n\n  var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n\n  var d = dt.getDate().toString().padStart(2, '0');\n\n\n\n  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日\n\n  // 否则，就返回  年-月-日 时：分：秒\n\n  if (pattern.toLowerCase() === 'yyyy-mm-dd') {\n\n    return `${y}-${m}-${d}`;\n\n  } else {\n\n    // 获取时分秒\n\n    var hh = dt.getHours().toString().padStart(2, '0');\n\n    var mm = dt.getMinutes().toString().padStart(2, '0');\n\n    var ss = dt.getSeconds().toString().padStart(2, '0');\n\n\n\n    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n\n  }\n\n});\n\n```\n\n\n\n> 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！\n\n\n\n## 键盘修饰符以及自定义键盘修饰符\n\n### 1.x中自定义键盘修饰符【了解即可】\n\n```\n\nVue.directive('on').keyCodes.f2 = 113;\n\n```\n\n### [2.x中自定义键盘修饰符](https://cn.vuejs.org/v2/guide/events.html#键值修饰符)\n\n1. 通过`Vue.config.keyCodes.名称 = 按键值`来自定义案件修饰符的别名：\n\n```\n\nVue.config.keyCodes.f2 = 113;\n\n```\n\n2. 使用自定义的按键修饰符：\n\n```\n\n<input type=\"text\" v-model=\"name\" @keyup.f2=\"add\">\n\n```\n\n\n\n\n\n## [自定义指令](https://cn.vuejs.org/v2/guide/custom-directive.html)\n\n1. 自定义全局和局部的 自定义指令：\n\n```\n\n    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：\n\n    Vue.directive('focus', {\n\n      inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用\n\n        el.focus();\n\n      }\n\n    });\n\n\n\n    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：\n\n      directives: {\n\n        color: { // 为元素设置指定的字体颜色\n\n          bind(el, binding) {\n\n            el.style.color = binding.value;\n\n          }\n\n        },\n\n        'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数\n\n          el.style.fontWeight = binding2.value;\n\n        }\n\n      }\n\n```\n\n2. 自定义指令的使用方式：\n\n```\n\n<input type=\"text\" v-model=\"searchName\" v-focus v-color=\"'red'\" v-font-weight=\"900\">\n\n```\n\n\n\n## Vue 1.x 中 自定义元素指令【已废弃,了解即可】\n```\nVue.elementDirective('red-color', {\n  bind: function () {\n    this.el.style.color = 'red';\n  }\n});\n```\n使用方式：\n```\n<red-color>1232</red-color>\n```\n\n\n## [vue实例的生命周期](https://cn.vuejs.org/v2/guide/instance.html#实例生命周期)\n+ 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！\n+ [生命周期钩子](https://cn.vuejs.org/v2/api/#选项-生命周期钩子)：就是生命周期事件的别名而已；\n+ 生命周期钩子 = 生命周期函数 = 生命周期事件\n+ 主要的生命周期函数分类：\n - 创建期间的生命周期函数：\n  \t+ beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性\n  \t+ created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板\n  \t+ beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中\n  \t+ mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示\n - 运行期间的生命周期函数：\n \t+ beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点\n \t+ updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！\n - 销毁期间的生命周期函数：\n \t+ beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。\n \t+ destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。\n![lifecycle](https://user-images.githubusercontent.com/28568478/116815239-3b63c780-ab8f-11eb-9453-11e40b354c4e.png)\n\n\n## [vue-resource 实现 get, post, jsonp请求](https://github.com/pagekit/vue-resource)\n除了 vue-resource 之外，还可以使用 `axios` 的第三方包实现实现数据的请求\n1. 之前的学习中，如何发起数据请求？\n2. 常见的数据请求类型？  get  post jsonp\n3. 测试的URL请求资源地址：\n + get请求地址： http://vue.studyit.io/api/getlunbo\n + post请求地址：http://vue.studyit.io/api/post\n + jsonp请求地址：http://vue.studyit.io/api/jsonp\n4. JSONP的实现原理\n + 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；\n + 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；\n + 具体实现过程：\n \t- 先在客户端定义一个回调方法，预定义对数据的操作；\n \t- 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口；\n \t- 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行；\n \t- 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；\n + 带大家通过 Node.js ，来手动实现一个JSONP的请求例子；\n ```\n    const http = require('http');\n    // 导入解析 URL 地址的核心模块\n    const urlModule = require('url');\n\n    const server = http.createServer();\n    // 监听 服务器的 request 请求事件，处理每个请求\n    server.on('request', (req, res) => {\n      const url = req.url;\n\n      // 解析客户端请求的URL地址\n      var info = urlModule.parse(url, true);\n\n      // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据\n      if (info.pathname === '/getjsonp') {\n        // 获取客户端指定的回调函数的名称\n        var cbName = info.query.callback;\n        // 手动拼接要返回给客户端的数据对象\n        var data = {\n          name: 'zs',\n          age: 22,\n          gender: '男',\n          hobby: ['吃饭', '睡觉', '运动']\n        }\n        // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法：\n        var result = `${cbName}(${JSON.stringify(data)})`;\n        // 将拼接好的方法的调用，返回给客户端去解析执行\n        res.end(result);\n      } else {\n        res.end('404');\n      }\n    });\n\n    server.listen(3000, () => {\n      console.log('server running at http://127.0.0.1:3000');\n    });\n ```\n5. vue-resource 的配置步骤：\n + 直接在页面中，通过`script`标签，引入 `vue-resource` 的脚本文件；\n + 注意：引用的先后顺序是：先引用 `Vue` 的脚本文件，再引用 `vue-resource` 的脚本文件；\n6. 发送get请求：\n```\ngetInfo() { // get 方式获取数据\n  this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res => {\n    console.log(res.body);\n  })\n}\n```\n7. 发送post请求：\n```\npostInfo() {\n  var url = 'http://127.0.0.1:8899/api/post';\n  // post 方法接收三个参数：\n  // 参数1： 要请求的URL地址\n  // 参数2： 要发送的数据对象\n  // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded\n  this.$http.post(url, { name: 'zs' }, { emulateJSON: true }).then(res => {\n    console.log(res.body);\n  });\n}\n```\n8. 发送JSONP请求获取数据：\n```\njsonpInfo() { // JSONP形式从服务器获取数据\n  var url = 'http://127.0.0.1:8899/api/jsonp';\n  this.$http.jsonp(url).then(res => {\n    console.log(res.body);\n  });\n}\n```\n\n## 配置本地数据库和数据接口API\n1. 先解压安装 `PHPStudy`;\n2. 解压安装 `Navicat` 这个数据库可视化工具，并激活；\n3. 打开 `Navicat` 工具，新建空白数据库，名为 `dtcmsdb4`;\n4. 双击新建的数据库，连接上这个空白数据库，在新建的数据库上`右键` -> `运行SQL文件`，选择并执行 `dtcmsdb4.sql` 这个数据库脚本文件；如果执行不报错，则数据库导入完成；\n5. 进入文件夹 `vuecms3_nodejsapi` 内部，执行 `npm i` 安装所有的依赖项；\n6. 先确保本机安装了 `nodemon`, 没有安装，则运行 `npm i nodemon -g` 进行全局安装，安装完毕后，进入到 `vuecms3_nodejsapi`目录 -> `src`目录 -> 双击运行 `start.bat`\n7. 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 `app.js` 中第 `14行` 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root\n\n## 品牌管理改造\n### 展示品牌列表\n\n### 添加品牌数据\n\n### 删除品牌数据\n\n## [Vue中的动画](https://cn.vuejs.org/v2/guide/transitions.html)\n为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；\n\n### 使用过渡类名\n1. HTML结构：\n```\n<div id=\"app\">\n    <input type=\"button\" value=\"动起来\" @click=\"myAnimate\">\n    <!-- 使用 transition 将需要过渡的元素包裹起来 -->\n    <transition name=\"fade\">\n      <div v-show=\"isshow\">动画哦</div>\n    </transition>\n  </div>\n```\n2. VM 实例：\n```\n// 创建 Vue 实例，得到 ViewModel\nvar vm = new Vue({\n  el: '#app',\n  data: {\n    isshow: false\n  },\n  methods: {\n    myAnimate() {\n      this.isshow = !this.isshow;\n    }\n  }\n});\n```\n3. 定义两组类样式：\n```\n/* 定义进入和离开时候的过渡状态 */\n    .fade-enter-active,\n    .fade-leave-active {\n      transition: all 0.2s ease;\n      position: absolute;\n    }\n\n    /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */\n    .fade-enter,\n    .fade-leave-to {\n      opacity: 0;\n      transform: translateX(100px);\n    }\n```\n\n### [使用第三方 CSS 动画库](https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名)\n1. 导入动画类库：\n```\n<link rel=\"stylesheet\" type=\"text/css\" href=\"./lib/animate.css\">\n```\n2. 定义 transition 及属性：\n```\n<transition\n\tenter-active-class=\"fadeInRight\"\n    leave-active-class=\"fadeOutRight\"\n    :duration=\"{ enter: 500, leave: 800 }\">\n  \t<div class=\"animated\" v-show=\"isshow\">动画哦</div>\n</transition>\n```\n\n### 使用动画钩子函数\n1. 定义 transition 组件以及三个钩子函数：\n```\n<div id=\"app\">\n    <input type=\"button\" value=\"切换动画\" @click=\"isshow = !isshow\">\n    <transition\n    @before-enter=\"beforeEnter\"\n    @enter=\"enter\"\n    @after-enter=\"afterEnter\">\n      <div v-if=\"isshow\" class=\"show\">OK</div>\n    </transition>\n  </div>\n```\n2. 定义三个 methods 钩子方法：\n```\nmethods: {\n        beforeEnter(el) { // 动画进入之前的回调\n          el.style.transform = 'translateX(500px)';\n        },\n        enter(el, done) { // 动画进入完成时候的回调\n          el.offsetWidth;\n          el.style.transform = 'translateX(0px)';\n          done();\n        },\n        afterEnter(el) { // 动画进入完成之后的回调\n          this.isshow = !this.isshow;\n        }\n      }\n```\n3. 定义动画过渡时长和样式：\n```\n.show{\n      transition: all 0.4s ease;\n    }\n```\n\n\n### [v-for 的列表过渡](https://cn.vuejs.org/v2/guide/transitions.html#列表的进入和离开过渡)\n1. 定义过渡样式：\n```\n<style>\n    .list-enter,\n    .list-leave-to {\n      opacity: 0;\n      transform: translateY(10px);\n    }\n\n    .list-enter-active,\n    .list-leave-active {\n      transition: all 0.3s ease;\n    }\n</style>\n```\n2. 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：\n```\n  <div id=\"app\">\n    <input type=\"text\" v-model=\"txt\" @keyup.enter=\"add\">\n\n    <transition-group tag=\"ul\" name=\"list\">\n      <li v-for=\"(item, i) in list\" :key=\"i\">{{item}}</li>\n    </transition-group>\n  </div>\n```\n3. 定义 VM中的结构：\n```\n    // 创建 Vue 实例，得到 ViewModel\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        txt: '',\n        list: [1, 2, 3, 4]\n      },\n      methods: {\n        add() {\n          this.list.push(this.txt);\n          this.txt = '';\n        }\n      }\n    });\n```\n\n\n### 列表的排序过渡\n`<transition-group>` 组件还有一个特殊之处。不仅可以进入和离开动画，**还可以改变定位**。要使用这个新功能只需了解新增的 `v-move` 特性，**它会在元素的改变定位的过程中应用**。\n+ `v-move` 和 `v-leave-active` 结合使用，能够让列表的过渡更加平缓柔和：\n```\n.v-move{\n  transition: all 0.8s ease;\n}\n.v-leave-active{\n  position: absolute;\n}\n```\n\n\n\n## 相关文章\n1. [vue.js 1.x 文档](https://v1-cn.vuejs.org/)\n2. [vue.js 2.x 文档](https://cn.vuejs.org/)\n3. [String.prototype.padStart(maxLength, fillString)](http://www.css88.com/archives/7715)\n4. [js 里面的键盘事件对应的键码](http://www.cnblogs.com/wuhua1/p/6686237.html)\n5. [pagekit/vue-resource](https://github.com/pagekit/vue-resource)\n6. [navicat如何导入sql文件和导出sql文件](https://jingyan.baidu.com/article/a65957f4976aad24e67f9b9b.html)\n7. [贝塞尔在线生成器](http://cubic-bezier.com/#.4,-0.3,1,.33)\n","tags":["vue","vue2.0基础课程"],"categories":["vue2.0基础课程"]},{"title":"Vue.js - Day1","url":"/2021/05/02/vue/vue2.0基础课程/day1/","content":"\n# Vue.js - Day1\n\n## 课程介绍\n前5天： 都在学习Vue基本的语法和概念；打包工具 Webpack , Gulp\n后5天： 以项目驱动教学；\n\n\n### 什么是Vue.js\n\n+ Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）\n\n+ Vue.js 是前端的**主流框架之一**，和Angular.js、React.js 一起，并成为前端三大主流框架！\n\n+ Vue.js 是一套构建用户界面的框架，**只关注视图层**，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）\n\n+ 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；\n\n\n\n\n\n## 为什么要学习流行框架\n + 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；\n  - 企业中，使用框架，能够提高开发的效率；\n\n\n\n + 提高开发效率的发展历程：原生JS -> Jquery之类的类库 -> 前端模板引擎 -> Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】）\n + 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑；\n\n\n\n + 增强自己就业时候的竞争力\n  - 人无我有，人有我优\n  - 你平时不忙的时候，都在干嘛？\n\n## 框架和库的区别\n\n\n\n + 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。\n\n  - node 中的 express；\n\n\n\n + 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。\n  - 1. 从Jquery 切换到 Zepto\n  - 2. 从 EJS 切换到 art-template\n\n\n\n\n\n\n\n## Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别\n\n + MVC 是后端的分层开发概念；\n + MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel\n\n + 为什么有了MVC还要有MVVM\n\n\n\n## Vue.js 基本代码 和 MVVM 之间的对应关系\n![01 MVC和MVVM的关系图解](https://user-images.githubusercontent.com/28568478/116802575-5b22cd80-ab46-11eb-8f55-8b75473b6d4a.png)\n\n## Vue之 - `基本的代码结构`和`插值表达式`、`v-cloak`\n\n## Vue指令之`v-text`和`v-html`\n\n## Vue指令之`v-bind`的三种用法\n\n1. 直接使用指令`v-bind`\n\n2. 使用简化指令`:`\n\n3. 在绑定的时候，拼接绑定内容：`:title=\"btnTitle + ', 这是追加的内容'\"`\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <!-- <script src=\"./lib/vue.js\"></script> -->\n    <style>\n        /* 默认加入v-cloak的元素 隐藏 */\n        [v-cloak] {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"app\">\n        <!-- 使用v-cloak能够解决插值表达式闪烁的问题 -->\n        <p v-cloak>{{msg}}</p>\n        <!-- 默认v-text是没有闪烁问题的\n            v-text 会覆盖元素中原本的内容，但是插值表达式 只会替换自己的这个占位符 不会吧扎鞥个元素内容清空\n        -->\n        <h4 v-text=\"msg\"></h4>\n\n        <!-- v-html会解析html格式字符串 -->\n        <div>{{msg2}}</div>\n        <div v-text=\"msg2\"></div>\n        <div v-html=\"msg2\"></div>\n\n         <!-- v-bind 是vue中提供用于绑定属性的指令 -->\n         <input type=\"button\" value=\"按钮\" title=\"123\">\n         <input type=\"button\" value=\"按钮\" title=\"mytitle\">\n         <input type=\"button\" value=\"按钮\" v-bind:title=\"mytitle\">\n         <input type=\"button\" value=\"按钮\" v-bind:title=\"mytitle+'123'\">\n         <!-- 简化写 -->\n         <input type=\"button\" value=\"按钮\" :title=\"mytitle+'456'\">\n\n\n         <!-- vue中 提供了v-on 事件绑定机制 -->\n         <!-- 这样写会报错 未定义alert方法 -->\n         <input type=\"button\" value=\"按钮\" :title=\"mytitle+' v-on'\" v-on:click=\"alert('报警')\">\n         <!-- 貌似v-bind:title不生效 -->\n         <input type=\"button\" value=\"按钮\" :title=\"show_title\" v-on:click=\"show\">\n         <input type=\"button\" value=\"按钮\" :title=\"show_title\" v-on:mouseover=\"show\">\n         <!-- v-on缩写 用@代替 v-on:-->\n         <input type=\"button\" value=\"按钮\" :title=\"show_title\" @mouseover=\"show\">\n\n\n    </div>\n\n\n\n    <!-- vue.js放在这里时 如果网速过慢 会导致 {{msg}} 展现在页面\n        需要加v-cloak 设置样式为none 这样在网速慢的时候加载出来不会出现{{msg}}\n        而是当msg数据返回时才会展示信息\n    -->\n    <script src=\"./lib/vue.js\"></script>\n    <script>\n        var vm = new Vue({\n            el: \"#app\",\n            data: {\n                msg:123,\n                msg2:'<h1>哈哈 我是一个大大的H1</h1>',\n                mytitle:\"这是一个自己定义的title\"\n            },\n            methods:{ // 这个methods 属性中国定义了当前vue实例所有可用的方法\n                show: function () {\n                    alert(\"报警\")\n                 }\n            }\n        })\n    </script>\n\n</body>\n</html>\n```\n\n\n## Vue指令之`v-on`和`跑马灯效果`\n\n\n\n### 跑马灯效果\n\n1. HTML结构：\n\n```\n\n<div id=\"app\">\n\n    <p>{{info}}</p>\n\n    <input type=\"button\" value=\"开启\" v-on:click=\"go\">\n\n    <input type=\"button\" value=\"停止\" v-on:click=\"stop\">\n\n  </div>\n\n```\n\n2. Vue实例：\n\n```\n\n\t// 创建 Vue 实例，得到 ViewModel\n\n    var vm = new Vue({\n\n      el: '#app',\n\n      data: {\n\n        info: '猥琐发育，别浪~！',\n\n        intervalId: null\n\n      },\n\n      methods: {\n\n        go() {\n\n          // 如果当前有定时器在运行，则直接return\n\n          if (this.intervalId != null) {\n\n            return;\n\n          }\n\n          // 开始定时器\n\n          this.intervalId = setInterval(() => {\n\n            this.info = this.info.substring(1) + this.info.substring(0, 1);\n\n          }, 500);\n\n        },\n\n        stop() {\n\n          clearInterval(this.intervalId);\n\n        }\n\n      }\n\n    });\n\n```\n\n\n\n\n\n\n\n## Vue指令之`v-on的缩写`和`事件修饰符`\n\n\n\n### 事件修饰符：\n\n+ .stop       阻止冒泡\n\n+ .prevent    阻止默认事件\n\n+ .capture    添加事件侦听器时使用事件捕获模式\n\n+ .self       只当事件在该元素本身（比如不是子元素）触发时触发回调\n\n+ .once       事件只触发一次\n\n\n\n\n\n\n\n## Vue指令之`v-model`和`双向数据绑定`\n\n\n\n\n\n\n\n## 简易计算器案例\n\n1. HTML 代码结构\n\n```\n\n  <div id=\"app\">\n\n    <input type=\"text\" v-model=\"n1\">\n\n    <select v-model=\"opt\">\n\n      <option value=\"0\">+</option>\n\n      <option value=\"1\">-</option>\n\n      <option value=\"2\">*</option>\n\n      <option value=\"3\">÷</option>\n\n    </select>\n\n    <input type=\"text\" v-model=\"n2\">\n\n    <input type=\"button\" value=\"=\" v-on:click=\"getResult\">\n\n    <input type=\"text\" v-model=\"result\">\n\n  </div>\n\n```\n\n2. Vue实例代码：\n\n```\n\n\t// 创建 Vue 实例，得到 ViewModel\n\n    var vm = new Vue({\n\n      el: '#app',\n\n      data: {\n\n        n1: 0,\n\n        n2: 0,\n\n        result: 0,\n\n        opt: '0'\n\n      },\n\n      methods: {\n\n        getResult() {\n\n          switch (this.opt) {\n\n            case '0':\n\n              this.result = parseInt(this.n1) + parseInt(this.n2);\n\n              break;\n\n            case '1':\n\n              this.result = parseInt(this.n1) - parseInt(this.n2);\n\n              break;\n\n            case '2':\n\n              this.result = parseInt(this.n1) * parseInt(this.n2);\n\n              break;\n\n            case '3':\n\n              this.result = parseInt(this.n1) / parseInt(this.n2);\n\n              break;\n\n          }\n\n        }\n\n      }\n\n    });\n\n```\n\n\n\n\n\n\n\n\n\n## 在Vue中使用样式\n\n\n\n### 使用class样式\n\n1. 数组\n```\n<h1 :class=\"['red', 'thin']\">这是一个邪恶的H1</h1>\n```\n\n2. 数组中使用三元表达式\n```\n<h1 :class=\"['red', 'thin', isactive?'active':'']\">这是一个邪恶的H1</h1>\n```\n\n3. 数组中嵌套对象\n```\n<h1 :class=\"['red', 'thin', {'active': isactive}]\">这是一个邪恶的H1</h1>\n```\n\n4. 直接使用对象\n```\n<h1 :class=\"{red:true, italic:true, active:true, thin:true}\">这是一个邪恶的H1</h1>\n```\n\n\n\n### 使用内联样式\n\n1. 直接在元素上通过 `:style` 的形式，书写样式对象\n```\n<h1 :style=\"{color: 'red', 'font-size': '40px'}\">这是一个善良的H1</h1>\n```\n\n2. 将样式对象，定义到 `data` 中，并直接引用到 `:style` 中\n + 在data上定义样式：\n```\ndata: {\n        h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }\n}\n```\n + 在元素中，通过属性绑定的形式，将样式对象应用到元素中：\n```\n<h1 :style=\"h1StyleObj\">这是一个善良的H1</h1>\n```\n\n3. 在 `:style` 中通过数组，引用多个 `data` 上的样式对象\n + 在data上定义样式：\n```\ndata: {\n        h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' },\n        h1StyleObj2: { fontStyle: 'italic' }\n}\n```\n + 在元素中，通过属性绑定的形式，将样式对象应用到元素中：\n```\n<h1 :style=\"[h1StyleObj, h1StyleObj2]\">这是一个善良的H1</h1>\n```\n\n\n\n## Vue指令之`v-for`和`key`属性\n\n1. 迭代数组\n\n```\n<ul>\n  <li v-for=\"(item, i) in list\">索引：{{i}} --- 姓名：{{item.name}} --- 年龄：{{item.age}}</li>\n</ul>\n```\n\n2. 迭代对象中的属性\n\n```\n\n\t<!-- 循环遍历对象身上的属性 -->\n\n    <div v-for=\"(val, key, i) in userInfo\">{{val}} --- {{key}} --- {{i}}</div>\n\n```\n\n3. 迭代数字\n\n```\n\n<p v-for=\"i in 10\">这是第 {{i}} 个P标签</p>\n\n```\n\n\n\n> 2.2.0+ 的版本里，**当在组件中使用** v-for 时，key 现在是必须的。\n\n\n\n当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “**就地复用**” 策略。如果数据项的顺序被改变，Vue将**不是移动 DOM 元素来匹配数据项的顺序**， 而是**简单复用此处每个元素**，并且确保它在特定索引下显示已被渲染过的每个元素。\n\n\n\n为了给 Vue 一个提示，**以便它能跟踪每个节点的身份，从而重用和重新排序现有元素**，你需要为每项提供一个唯一 key 属性。\n\n\n\n\n\n\n\n## Vue指令之`v-if`和`v-show`\n\n\n\n\n\n\n\n> 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。\n\n\n\n\n\n\n\n## 品牌管理案例\n\n\n\n### 添加新品牌\n\n\n\n### 删除品牌\n\n\n\n### 根据条件筛选品牌\n\n1. 1.x 版本中的filterBy指令，在2.x中已经被废除：\n\n[filterBy - 指令](https://v1-cn.vuejs.org/api/#filterBy)\n\n```\n\n<tr v-for=\"item in list | filterBy searchName in 'name'\">\n\n  <td>{{item.id}}</td>\n\n  <td>{{item.name}}</td>\n\n  <td>{{item.ctime}}</td>\n\n  <td>\n\n    <a href=\"#\" @click.prevent=\"del(item.id)\">删除</a>\n\n  </td>\n\n</tr>\n\n```\n\n2. 在2.x版本中[手动实现筛选的方式](https://cn.vuejs.org/v2/guide/list.html#显示过滤-排序结果)：\n\n+ 筛选框绑定到 VM 实例中的 `searchName` 属性：\n\n```\n\n<hr> 输入筛选名称：\n\n<input type=\"text\" v-model=\"searchName\">\n\n```\n\n+ 在使用 `v-for` 指令循环每一行数据的时候，不再直接 `item in list`，而是 `in` 一个 过滤的methods 方法，同时，把过滤条件`searchName`传递进去：\n\n```\n\n<tbody>\n\n      <tr v-for=\"item in search(searchName)\">\n\n        <td>{{item.id}}</td>\n\n        <td>{{item.name}}</td>\n\n        <td>{{item.ctime}}</td>\n\n        <td>\n\n          <a href=\"#\" @click.prevent=\"del(item.id)\">删除</a>\n\n        </td>\n\n      </tr>\n\n    </tbody>\n\n```\n\n+ `search` 过滤方法中，使用 数组的 `filter` 方法进行过滤：\n\n```\n\nsearch(name) {\n\n  return this.list.filter(x => {\n\n    return x.name.indexOf(name) != -1;\n\n  });\n\n}\n\n```\n\n\n\n\n\n\n\n## Vue调试工具`vue-devtools`的安装步骤和使用\n\n[Vue.js devtools - 翻墙安装方式 - 推荐](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN)\n\n\n\n\n\n## 过滤器\n\n概念：Vue.js 允许你自定义过滤器，**可被用作一些常见的文本格式化**。过滤器可以用在两个地方：**mustache 插值和 v-bind 表达式**。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；\n\n### 私有过滤器\n\n1. HTML元素：\n\n```\n\n<td>{{item.ctime | dataFormat('yyyy-mm-dd')}}</td>\n\n```\n\n2. 私有 `filters` 定义方式：\n\n```\n\nfilters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用\n\n    dataFormat(input, pattern = \"\") { // 在参数列表中 通过 pattern=\"\" 来指定形参默认值，防止报错\n\n      var dt = new Date(input);\n\n      // 获取年月日\n\n      var y = dt.getFullYear();\n\n      var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n\n      var d = dt.getDate().toString().padStart(2, '0');\n\n\n\n      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日\n\n      // 否则，就返回  年-月-日 时：分：秒\n\n      if (pattern.toLowerCase() === 'yyyy-mm-dd') {\n\n        return `${y}-${m}-${d}`;\n\n      } else {\n\n        // 获取时分秒\n\n        var hh = dt.getHours().toString().padStart(2, '0');\n\n        var mm = dt.getMinutes().toString().padStart(2, '0');\n\n        var ss = dt.getSeconds().toString().padStart(2, '0');\n\n\n\n        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n\n      }\n\n    }\n\n  }\n\n```\n\n\n\n> 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString='') 或 String.prototype.padEnd(maxLength, fillString='')来填充字符串；\n\n\n\n\n\n### 全局过滤器\n\n```\n\n// 定义一个全局过滤器\n\nVue.filter('dataFormat', function (input, pattern = '') {\n\n  var dt = new Date(input);\n\n  // 获取年月日\n\n  var y = dt.getFullYear();\n\n  var m = (dt.getMonth() + 1).toString().padStart(2, '0');\n\n  var d = dt.getDate().toString().padStart(2, '0');\n\n\n\n  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日\n\n  // 否则，就返回  年-月-日 时：分：秒\n\n  if (pattern.toLowerCase() === 'yyyy-mm-dd') {\n\n    return `${y}-${m}-${d}`;\n\n  } else {\n\n    // 获取时分秒\n\n    var hh = dt.getHours().toString().padStart(2, '0');\n\n    var mm = dt.getMinutes().toString().padStart(2, '0');\n\n    var ss = dt.getSeconds().toString().padStart(2, '0');\n\n\n\n    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;\n\n  }\n\n});\n\n```\n\n\n\n> 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！\n\n\n\n## 键盘修饰符以及自定义键盘修饰符\n\n### 1.x中自定义键盘修饰符【了解即可】\n\n```\n\nVue.directive('on').keyCodes.f2 = 113;\n\n```\n\n### [2.x中自定义键盘修饰符](https://cn.vuejs.org/v2/guide/events.html#键值修饰符)\n\n1. 通过`Vue.config.keyCodes.名称 = 按键值`来自定义案件修饰符的别名：\n\n```\n\nVue.config.keyCodes.f2 = 113;\n\n```\n\n2. 使用自定义的按键修饰符：\n\n```\n\n<input type=\"text\" v-model=\"name\" @keyup.f2=\"add\">\n\n```\n\n\n\n\n\n## [自定义指令](https://cn.vuejs.org/v2/guide/custom-directive.html)\n\n1. 自定义全局和局部的 自定义指令：\n\n```\n\n    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：\n\n    Vue.directive('focus', {\n\n      inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用\n\n        el.focus();\n\n      }\n\n    });\n\n\n\n    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：\n\n      directives: {\n\n        color: { // 为元素设置指定的字体颜色\n\n          bind(el, binding) {\n\n            el.style.color = binding.value;\n\n          }\n\n        },\n\n        'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数\n\n          el.style.fontWeight = binding2.value;\n\n        }\n\n      }\n\n```\n\n2. 自定义指令的使用方式：\n\n```\n\n<input type=\"text\" v-model=\"searchName\" v-focus v-color=\"'red'\" v-font-weight=\"900\">\n\n```\n\n\n\n## Vue 1.x 中 自定义元素指令【已废弃,了解即可】\n```\nVue.elementDirective('red-color', {\n  bind: function () {\n    this.el.style.color = 'red';\n  }\n});\n```\n使用方式：\n```\n<red-color>1232</red-color>\n```\n\n## 相关文章\n1. [vue.js 1.x 文档](https://v1-cn.vuejs.org/)\n2. [vue.js 2.x 文档](https://cn.vuejs.org/)\n3. [String.prototype.padStart(maxLength, fillString)](http://www.css88.com/archives/7715)\n4. [js 里面的键盘事件对应的键码](http://www.cnblogs.com/wuhua1/p/6686237.html)\n5. [Vue.js双向绑定的实现原理](http://www.cnblogs.com/kidney/p/6052935.html)\n","tags":["vue","vue2.0基础课程"],"categories":["vue2.0基础课程"]}]